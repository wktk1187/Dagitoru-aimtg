This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
app/api/notion-sync/route.ts
app/api/slack/events/route.ts
app/api/slack/intake/route.ts
app/api/start-task/route.ts
app/api/summarize-task/route.ts
app/api/upload-url/route.ts
app/globals.css
app/lib/supabase-client.ts
app/scripts/upload-slack-file.ts
app/utils/slack-to-supabase-uploader.ts
cloudrun-transcriber/.dockerignore
cloudrun-transcriber/.gcloudignore
cloudrun-transcriber/Dockerfile
cloudrun-transcriber/index.js
cloudrun-transcriber/package.json
deno.lock
docs/slack_video_summary_spec_detailed.md
docs/testing-steps.md
next-env.d.ts
package.json
postcss.config.js
README.md
supabase/.branches/_current_branch
supabase/.temp/cli-latest
supabase/.temp/gotrue-version
supabase/.temp/pooler-url
supabase/.temp/postgres-version
supabase/.temp/project-ref
supabase/.temp/rest-version
supabase/.temp/storage-version
supabase/config.toml
supabase/deno.json
supabase/deno.lock
supabase/functions/process-video-task/.npmrc
supabase/functions/process-video-task/index.ts
supabase/functions/summarize_dispatch/index.ts
supabase/functions/transcribe_with_whisper/index.ts
supabase/functions/upload_file_to_storage/index.ts
supabase/migrations/20231105_create_upload_logs.sql
supabase/migrations/20250517181202_remote_schema.sql
supabase/migrations/20250517181203_create_transcription_task_trigger.sql
tailwind.config.js
tsconfig.json
vercel.json

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

================
File: app/lib/supabase-client.ts
================
import { createClient } from '@supabase/supabase-js';

// Supabaseã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ– (ç’°å¢ƒå¤‰æ•°ã‹ã‚‰URLã¨anonã‚­ãƒ¼ã‚’å–å¾—)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error('Missing Supabase URL or anon key environment variables.');
}

// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–
export const supabase = supabaseUrl && supabaseAnonKey 
  ? createClient(supabaseUrl, supabaseAnonKey) 
  : null;

// ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ (ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®ã¿ã§ä½¿ç”¨)
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

export const supabaseAdmin = supabaseUrl && supabaseServiceKey 
  ? createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }) 
  : null;

================
File: app/utils/slack-to-supabase-uploader.ts
================
import fetch from 'node-fetch';
import { Readable, Transform } from 'stream';
import { pipeline } from 'stream/promises';
import { supabaseAdmin as supabase } from '../lib/supabase-client';

// ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface UploadStatus {
  id: string;
  task_id?: string;
  file_name: string;
  storage_path: string;
  status: 'preparing' | 'uploading' | 'uploaded' | 'processing' | 'completed' | 'failed';
  content_type: string;
  file_size?: number;
  progress?: number;
  error_message?: string;
  metadata?: Record<string, any>;
  slack_file_id?: string;
  slack_download_url?: string;
  created_at?: Date;
  updated_at?: Date;
}

// ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
export interface UploadOptions {
  slackFileUrl: string;
  slackToken: string;
  uploadEndpoint: string;
  webhookSecret: string;
  maxRetries?: number;
  logProgress?: boolean;
  metadata?: Record<string, any>;
}

/**
 * é€²æ—ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ç”¨ã®Transformã‚¹ãƒˆãƒªãƒ¼ãƒ 
 */
class ProgressTransform extends Transform {
  private transferred = 0;
  private lastProgressPercent = 0;
  private lastLogged = 0;

  constructor(
    private readonly total: number,
    private readonly onProgress: (transferred: number, total: number, percent: number) => void,
    private readonly logInterval = 262144 // 256KBã”ã¨ã«ãƒ­ã‚°
  ) {
    super();
  }

  _transform(chunk: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {
    this.transferred += chunk.length;
    const percent = Math.floor((this.transferred / this.total) * 100);
    
    // ãƒ­ã‚°é–“éš”ã¾ãŸã¯ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å¤‰åŒ–ã§é€šçŸ¥
    if (this.transferred - this.lastLogged >= this.logInterval || percent > this.lastProgressPercent) {
      this.onProgress(this.transferred, this.total, percent);
      this.lastLogged = this.transferred;
      this.lastProgressPercent = percent;
    }
    
    callback(null, chunk);
  }
}

/**
 * æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã«ã‚ˆã‚‹è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤é–¢æ•°
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>, 
  maxRetries: number = 3, 
  initialDelay: number = 1000,
  onRetry?: (attempt: number, delay: number, error: Error) => void
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      // æœ€å¾Œã®è©¦è¡Œãªã‚‰ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼
      if (attempt === maxRetries - 1) {
        throw lastError;
      }
      
      // ãƒªãƒˆãƒ©ã‚¤é–“éš”ã‚’è¨ˆç®—ï¼ˆæŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ï¼‰
      const delay = initialDelay * Math.pow(2, attempt);
      
      if (onRetry) {
        onRetry(attempt + 1, delay, lastError);
      }
      
      // å¾…æ©Ÿ
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // ã“ã“ã«åˆ°é”ã™ã‚‹ã“ã¨ã¯ãªã„ã¯ãšã ãŒã€TypeScriptã®å‹å®‰å…¨æ€§ã®ãŸã‚
  throw lastError || new Error('Unknown error during retry');
}

/**
 * Slackãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—ã—ã¦Supabaseã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 * ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ãƒ™ãƒ«å®Ÿè£… - é€²æ—ç›£è¦–ã€è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ã€ãƒ­ã‚°è¨˜éŒ²æ©Ÿèƒ½ä»˜ã
 */
export async function uploadSlackFileToSupabase({
  slackFileUrl,
  slackToken,
  uploadEndpoint,
  webhookSecret,
  maxRetries = 3,
  logProgress = true,
  metadata = {}
}: UploadOptions): Promise<UploadStatus> {
  
  // æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯ - mp4ã®ã¿è¨±å¯
  if (!slackFileUrl.endsWith('.mp4')) {
    throw new Error('Only .mp4 files are supported at this time');
  }
  
  // Slackã®URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åéƒ¨åˆ†ã‚’æŠ½å‡º
  const slackFileName = slackFileUrl.split('/').pop() || `slack_file_${Date.now()}.mp4`;
  
  // ä¸€æ„ã®IDã‚’ç”Ÿæˆï¼ˆã‚¿ã‚¹ã‚¯è¿½è·¡ç”¨ï¼‰
  const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  const fileName = `slack_${uploadId}.mp4`;
  
  // DBã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ³ãƒˆãƒªä½œæˆ
  let uploadStatus: UploadStatus = {
    id: uploadId,
    file_name: fileName,
    storage_path: '',
    status: 'preparing',
    content_type: 'video/mp4',
    slack_file_id: slackFileUrl.includes('/') ? slackFileUrl.split('/').slice(-2)[0] : undefined,
    slack_download_url: slackFileUrl,
    metadata: {
      original_file_name: slackFileName,
      source: 'slack',
      ...metadata
    },
    created_at: new Date(),
    updated_at: new Date(),
  };
  
  // Supabaseãƒ†ãƒ¼ãƒ–ãƒ«ã«åˆæœŸçŠ¶æ…‹ã‚’è¨˜éŒ²
  await logToDatabase(uploadStatus);
  
  try {
    // 1. Slackãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã‚’å–å¾—ï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
    const fileInfo = await retryWithBackoff(async () => {
      updateStatus('preparing', 'Checking file headers from Slack');
      
      const slackRes = await fetch(slackFileUrl, {
        method: 'HEAD',
        headers: {
          Authorization: `Bearer ${slackToken}`,
          'Accept': 'video/mp4',
        },
      });
      
      if (!slackRes.ok) {
        throw new Error(`Slack HEAD request failed (${slackRes.status}): ${slackRes.statusText}`);
      }
      
      // Content-Typeã‚’ç¢ºèªï¼ˆmp4ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼‰
      const contentType = slackRes.headers.get('content-type');
      if (contentType && !contentType.includes('video/mp4')) {
        throw new Error(`Unsupported content type: ${contentType}. Only video/mp4 is supported.`);
      }
      
      return {
        contentType: contentType || 'video/mp4',
        contentLength: parseInt(slackRes.headers.get('content-length') || '0', 10)
      };
    }, maxRetries, 1000, (attempt, delay, error) => {
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for file header check: ${error.message}`);
    });
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã‚’è¨˜éŒ²
    uploadStatus.file_size = fileInfo.contentLength;
    uploadStatus.content_type = fileInfo.contentType;
    await logToDatabase(uploadStatus);
    
    // 2. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‹ã‚‰ç½²åä»˜ãURLå–å¾—ï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
    const { uploadUrl, storagePath } = await retryWithBackoff(async () => {
      updateStatus('preparing', 'Requesting upload URL');
      
      const uploadRes = await fetch(uploadEndpoint, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${webhookSecret}`
        },
        body: JSON.stringify({ 
          fileName, 
          contentType: 'video/mp4',
          metadata: {
            uploadId,
            source: 'slack',
            originalFileName: slackFileName
          }
        }),
      });
      
      if (!uploadRes.ok) {
        const errorData = await uploadRes.json().catch(() => ({ error: uploadRes.statusText }));
        throw new Error(`Upload URL error: ${errorData.error || 'Unknown error'}`);
      }
      
      const data = await uploadRes.json();
      if (!data.uploadUrl) {
        throw new Error('No upload URL returned from server');
      }
      
      return {
        uploadUrl: data.uploadUrl,
        storagePath: data.storagePath
      };
    }, maxRetries, 1000, (attempt, delay, error) => {
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for upload URL: ${error.message}`);
    });
    
    uploadStatus.storage_path = storagePath;
    await logToDatabase(uploadStatus);
    
    // 3. Slackã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã€ç›´æ¥Supabaseã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    await retryWithBackoff(async () => {
      updateStatus('uploading', 'Downloading from Slack and uploading to storage');
      
      // Slackã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒˆãƒªãƒ¼ãƒ å–å¾—
      const slackRes = await fetch(slackFileUrl, {
        headers: {
          Authorization: `Bearer ${slackToken}`,
          'Accept': 'video/mp4',
        },
      });
      
      if (!slackRes.ok) {
        throw new Error(`Slack fetch failed (${slackRes.status}): ${slackRes.statusText}`);
      }
      
      // â€»ç†æƒ³çš„ã«ã¯ã“ã“ã§ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½¿ã†ãŒã€node-fetchã®åˆ¶ç´„ã«ã‚ˆã‚Šç°¡ç•¥åŒ–
      const fileBuffer = await slackRes.buffer();
      
      // é€²æ—æ›´æ–°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
      const updateProgressCallback = (transferred: number, total: number, percent: number) => {
        if (logProgress) {
          console.log(`[${new Date().toISOString()}] Progress: ${percent}% (${transferred}/${total} bytes)`);
        }
        
        // 10%ã”ã¨ã«DBã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
        if (percent % 10 === 0 || percent === 100) {
          uploadStatus.progress = percent;
          logToDatabase(uploadStatus).catch(console.error);
        }
      };
      
      // ã‚¹ãƒˆãƒªãƒ¼ãƒ ä½œæˆã¨é€²æ—å‡¦ç†ï¼ˆå®Ÿéš›ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ å®Ÿè£…ã®å ´åˆï¼‰
      /*
      const downloadStream = Readable.from(slackRes.body);
      const progressStream = new ProgressTransform(
        uploadStatus.file_size || 0,
        updateProgressCallback
      );
      */
      
      // ã‚µã‚¤ã‚ºã‚’ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å ´åˆã¯ProgressTransformã‚’ä½¿ã†ï¼‰
      let transferred = 0;
      const total = uploadStatus.file_size || fileBuffer.length;
            
      // PUTãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      const putRes = await fetch(uploadUrl, {
        method: 'PUT',
        headers: { 'Content-Type': 'video/mp4' },
        body: fileBuffer,
      });
      
      // é€²æ—ã‚’100%ã¨ã—ã¦æ›´æ–°
      updateProgressCallback(total, total, 100);
      
      if (!putRes.ok) {
        const errorText = await putRes.text().catch(() => putRes.statusText);
        throw new Error(`Upload failed (${putRes.status}): ${errorText}`);
      }
      
      updateStatus('uploaded', 'File successfully uploaded');
      
      return true;
    }, maxRetries, 1000, (attempt, delay, error) => {
      updateStatus('uploading', `Retry ${attempt}/${maxRetries} after ${delay}ms: ${error.message}`);
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for upload: ${error.message}`);
    });
    
    // æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° - å‡¦ç†å¾…ã¡çŠ¶æ…‹ã«
    updateStatus('processing', 'Awaiting transcription processing');
    
    return uploadStatus;
    
  } catch (err) {
    // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚
    const errorMessage = err instanceof Error ? err.message : String(err);
    console.error(`[${new Date().toISOString()}] âŒ Upload failed:`, errorMessage);
    
    uploadStatus.status = 'failed';
    uploadStatus.error_message = errorMessage;
    uploadStatus.updated_at = new Date();
    await logToDatabase(uploadStatus);
    
    throw err;
  }
  
  // å†…éƒ¨é–¢æ•°: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
  async function updateStatus(status: UploadStatus['status'], message?: string) {
    uploadStatus.status = status;
    uploadStatus.updated_at = new Date();
    if (message) {
      uploadStatus.metadata = { ...uploadStatus.metadata, lastMessage: message, lastUpdated: new Date().toISOString() };
    }
    await logToDatabase(uploadStatus);
    console.log(`[${new Date().toISOString()}] Status updated to '${status}'${message ? `: ${message}` : ''}`);
  }
  
  // å†…éƒ¨é–¢æ•°: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒ­ã‚°è¨˜éŒ²
  async function logToDatabase(status: UploadStatus) {
    try {
      if (!supabase) {
        console.warn('[Upload Logger] Supabase client not available, skipping log.');
        return;
      }
      
      const { error } = await supabase
        .from('upload_logs')
        .upsert({
          id: status.id,
          task_id: status.task_id,
          file_name: status.file_name,
          storage_path: status.storage_path,
          status: status.status,
          content_type: status.content_type,
          file_size: status.file_size,
          progress: status.progress,
          error_message: status.error_message,
          metadata: status.metadata,
          slack_file_id: status.slack_file_id,
          slack_download_url: status.slack_download_url,
          // created_at ã¨ updated_at ã¯DBã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¨æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼ã«ä»»ã›ã‚‹
        }, { onConflict: 'id' });
      
      if (error) {
        console.warn(`[${new Date().toISOString()}] Failed to log upload status:`, error);
      }
    } catch (e) {
      console.warn(`[${new Date().toISOString()}] Error logging to database:`, e);
      // ãƒ­ã‚°è¨˜éŒ²å¤±æ•—ã¯ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ‰±ã‚ãªã„ï¼ˆãƒ¡ã‚¤ãƒ³å‡¦ç†ã¯ç¶™ç¶šï¼‰
    }
  }
}

================
File: cloudrun-transcriber/.dockerignore
================
# Node.js dependencies from parent dir
../node_modules/
# Dependencies will be installed inside the container
node_modules/

# .git directory
.git/

# Logs
npm-debug.log
yarn-debug.log
yarn-error.log

# dotenv files
../.env
../.env.local
.env
.env.local
.env.example

# Env and config files
gcp_creds.json
.deno_cache/

# Test files
*.test.*
repomix-output.txt

# Video files
*.mp4
*.webm
*.mov
*.mp3

# Remove node_modules from the list
node_modules

================
File: cloudrun-transcriber/.gcloudignore
================
# Default gcloudignore from https://sdk.cloud.google.com/gcloud/reference/topic/gcloudignore
# Lines starting with '#' are comments.
# Affects 'gcloud run deploy --source .' and other gcloud commands.

.gcloudignore
# If you would like to upload your .git directory, .gitignore file or
# files from your .gitignore file, remove the corresponding line
# below:
.git
.gitignore

# Node.js dependencies:
node_modules/

# Specific to this project:
.deno_cache/
*.log
*.test.*
repomix-output.txt

# Sensitive files (if deployment context is not carefully managed)
# These are usually handled by placing .gcloudignore at the repo root
# but added here for explicitness if running deploy from within cloudrun-transcriber
# .env
# .env.local
# .env.example
# service-account.json

================
File: cloudrun-transcriber/Dockerfile
================
FROM node:18-slim

WORKDIR /app
COPY . .

RUN npm install

ENV PATH="/app/node_modules/ffmpeg-static:${PATH}"

CMD ["node", "index.js"]

================
File: cloudrun-transcriber/package.json
================
{
  "name": "cloudrun-transcriber",
  "version": "1.0.0",
  "main": "index.js",
  "type": "commonjs",
  "dependencies": {
    "@google-cloud/storage": "^6.9.0",
    "@google-cloud/speech": "^5.4.0",
    "node-fetch": "^2.6.7",
    "fluent-ffmpeg": "^2.1.2",
    "ffmpeg-static": "^4.4.0",
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  }
}

================
File: docs/slack_video_summary_spec_detailed.md
================
# è©³ç´°ä»•æ§˜æ›¸ï¼šSlackå‹•ç”»è¦ç´„ãƒœãƒƒãƒˆ

## ğŸ›  ä½¿ç”¨æŠ€è¡“ãƒ»ã‚µãƒ¼ãƒ“ã‚¹è©³ç´°

| é …ç›®       | æŠ€è¡“/ã‚µãƒ¼ãƒ“ã‚¹                         | å‚™è€ƒ |
|------------|----------------------------------------|------|
| å‹•ç”»é€ä¿¡å…ƒ   | Slack Bot                            | Events API, `file_shared` ã‚¤ãƒ™ãƒ³ãƒˆä½¿ç”¨ |
| Webhookå—ä¿¡ | Vercel (Next.js API Routes)          | èªè¨¼ä¸è¦ã§ç°¡ä¾¿ã€Slackç½²åæ¤œè¨¼ã‚ã‚Š |
| ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸   | Supabase Storage                     | `uploadFromUrl`ã‚’åˆ©ç”¨ |
| éŸ³å£°èªè­˜     | Whisperï¼ˆPythonï¼‰                    | `base` or `medium` ãƒ¢ãƒ‡ãƒ«æ¨å¥¨ |
| è¦ç´„        | Gemini API (Generative Language API) | Gemini 1.5 Pro ã¾ãŸã¯ Gemini 1.0 |
| é€šçŸ¥/ç™»éŒ²å…ˆ | Slack API / Notion API               | è¦ç´„çµæœã‚’é€šçŸ¥ or æ°¸ç¶šåŒ–ä¿å­˜ |

---

## ğŸ“‚ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è¨­è¨ˆï¼ˆSupabaseï¼‰

| ãƒ‘ã‚¹                            | å†…å®¹                     |
|---------------------------------|--------------------------|
| `/uploads/{uuid}.mp4`           | Slackã‹ã‚‰å–å¾—ã—ãŸå…ƒå‹•ç”» |
| `/transcripts/{uuid}.txt`       | Whisperã«ã‚ˆã‚‹æ–‡å­—èµ·ã“ã— |
| `/summaries/{uuid}.md`          | Geminiè¦ç´„æ–‡             |

---

## ğŸ”„ å„å‡¦ç†è©³ç´°

### 1. Slack Webhookå—ä¿¡
- `@slack/events-api` ã§ `file_shared` ã‚’å—ä¿¡
- Slackãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿æƒ…å ± (`url_private`, `id`, `name`) ã‚’å–å¾—
- Slack Bot Token ã«ã‚ˆã‚‹èªè¨¼DLï¼ˆBearer Tokenï¼‰

### 2. Supabase Storageã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
- Vercelå†…ã§ `fetch()` ã«ã‚ˆã‚ŠSlackã‹ã‚‰å‹•ç”»DL
- `supabase.storage.from().upload()` ã§ `/uploads/{uuid}` ã«ä¿å­˜
- æˆåŠŸæ™‚ã€UUIDã§ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’è¿”å´ãƒ»ãƒ­ã‚°å‡ºåŠ›

### 3. Whisperï¼ˆPythonï¼‰ã«ã‚ˆã‚‹æ–‡å­—èµ·ã“ã—
- Supabaseã® `/uploads/*.mp4` ã‚’DL
- Whisperã§ `.mp4` ã‚’ `.txt` ã«å¤‰æ›
- ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ› `/transcripts/{uuid}.txt`
- Whisperã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ­ã‚° + Slacké€šçŸ¥

### 4. Gemini APIã«ã‚ˆã‚‹è¦ç´„
- Whisperå‡ºåŠ›ï¼ˆæœ€å¤§8000å­—ï¼‰ã‚’ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«æŒ¿å…¥
- Geminiå‘¼ã³å‡ºã—ç”¨JSONæ§‹é€ ã‚’çµ„ã¿ç«‹ã¦
- `/summaries/{uuid}.md` ã«å‡ºåŠ›

### 5. Slacké€šçŸ¥ or Notionç™»éŒ²
- Slack: `chat.postMessage` ã§é€šçŸ¥ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«å + è¦ç´„ + GCSãƒªãƒ³ã‚¯ï¼‰
- Notion: `pages.create()` ã§è¦ç´„çµæœã‚’DBã«è¿½åŠ 

---

## âœ… å®Œäº†è¦ä»¶ï¼ˆç²¾ç·»åŒ–ï¼‰

| é …ç›® | å®Œäº†æ¡ä»¶ |
|------|----------|
| Slack Webhooké€£æº | `file_shared` ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ­£ã—ãå—ä¿¡ã—ã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã‚‹ |
| å‹•ç”»ä¿å­˜           | Slackã® `url_private` ã‹ã‚‰å‹•ç”»ã‚’å–å¾—ã—ã€Supabaseã«ä¿å­˜ã§ãã‚‹ï¼ˆUUIDå‘½åï¼‰ |
| Whisperå‡¦ç†        | ä¿å­˜å‹•ç”»ã‚’æ­£ç¢ºã«æ–‡å­—èµ·ã“ã—ã—ã€æœ€å¤§èª¤å·®5%ä»¥å†…ã§å‡ºåŠ›å¯èƒ½ |
| Geminiè¦ç´„         | Geminiã§ã®è¦ç´„çµæœãŒæœ€ä½70%ä»¥ä¸Šã®ç²¾åº¦ã§æ¦‚è¦ã‚’æ‰ãˆã¦ã„ã‚‹ |
| Slacké€šçŸ¥           | è¦ç´„æ–‡ã‚’Slackã«é€ä¿¡ã€ãƒªãƒ³ã‚¯ãŒæœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ |
| Notionç™»éŒ²          | ã‚¿ã‚¤ãƒˆãƒ«/æœ¬æ–‡å½¢å¼ã§DBã«ç™»éŒ²ã€‚æ–‡å­—èµ·ã“ã—å…¨æ–‡ãƒªãƒ³ã‚¯ä»˜ã |
| ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°  | DLãƒ»å¤‰æ›ãƒ»APIã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«Slackã§ã‚¢ãƒ©ãƒ¼ãƒˆãŒé£›ã¶ |
| CLIå†å‡¦ç†           | UUIDæŒ‡å®šã§å†åº¦Whisper + è¦ç´„å‡¦ç†ãŒå¯èƒ½ãªCLIã‚¹ã‚¯ãƒªãƒ—ãƒˆå­˜åœ¨ |
| ãƒ­ã‚°è¨˜éŒ²           | å„å·¥ç¨‹ã®ãƒ­ã‚°ãŒ Supabase Functions ã¾ãŸã¯ Vercel Log ã«æ®‹ã‚‹ã“ã¨ |

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆé …ç›®ï¼ˆæŠœç²‹ï¼‰

- [ ] Slack ã§ãƒ•ã‚¡ã‚¤ãƒ«å…±æœ‰ â†’ webhook ç™ºç«ã‚’ç¢ºèª
- [ ] Supabase ã«å‹•ç”»ä¿å­˜ç¢ºèªï¼ˆã‚µã‚¤ã‚º1.5GBã¾ã§å¯¾å¿œï¼‰
- [ ] Whisper ã«ã‚ˆã‚Šæ­£ç¢ºã«æ–‡å­—èµ·ã“ã—ã•ã‚Œã‚‹
- [ ] Gemini ã§è¦ç´„ãŒè¿”ã‚‹ï¼ˆ3æ–‡ä»¥ä¸Šã§æ„å‘³ãŒé€šã‚‹ï¼‰
- [ ] Slack/Notion ã«é€šçŸ¥ãƒ»ç™»éŒ²ã§ãã‚‹

## æ©Ÿèƒ½è¦ä»¶

## éæ©Ÿèƒ½è¦ä»¶

## ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³

## APIä»•æ§˜

### Slack Events API å—ä¿¡ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

## ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

================
File: docs/testing-steps.md
================
# æ–‡å­—èµ·ã“ã—ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ¤œè¨¼æ‰‹é †æ›¸

ã“ã®æ–‡æ›¸ã§ã¯ã€Slackâ†’Vercelâ†’Supabaseâ†’Cloud Runâ†’Vercelã®æ–‡å­—èµ·ã“ã—ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒæ­£ã—ãæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹ãŸã‚ã®æ‰‹é †ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## å‰ææ¡ä»¶

- å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒã™ã¹ã¦è¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨
  - NEXT_PUBLIC_SUPABASE_URL
  - NEXT_PUBLIC_SUPABASE_ANON_KEY
  - SUPABASE_SERVICE_ROLE_KEY
  - SLACK_BOT_TOKEN
  - WEBHOOK_SECRET
  - NEXT_PUBLIC_APP_URL
  - CLOUD_RUN_TRANSCRIBE_URL
  - GCS_BUCKET
  - SUMMARIZE_TASK_ENDPOINT
  - GEMINI_API_KEY (è¦ç´„ç”¨)

## æ¤œè¨¼æ‰‹é †

### 1. å…¨ä½“ãƒ•ãƒ­ãƒ¼ã®ç¢ºèª

#### ãƒ•ã‚§ãƒ¼ã‚º1: Slack â†’ Vercel â†’ Supabase

1. Slackã§`/transcribe`ã‚³ãƒãƒ³ãƒ‰ã¾ãŸã¯å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
2. Vercelã®ãƒ­ã‚°ã‚’ç¢ºèª:
   - `/api/slack/intake`ã®ãƒ­ã‚°ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå—ä¿¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - Supabaseã¸ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - `transcription_tasks`ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ã‚¿ã‚¹ã‚¯è¿½åŠ ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - `/api/start-task`ã®å‘¼ã³å‡ºã—ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

#### ãƒ•ã‚§ãƒ¼ã‚º2: Vercel â†’ Cloud Run

3. `/api/start-task`ã®ãƒ­ã‚°ã‚’ç¢ºèª:
   - ã‚¿ã‚¹ã‚¯ã®å–å¾—ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - ç½²åä»˜ãURLå–å¾—ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - Cloud Runã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ãŒæˆåŠŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

4. Google Cloud Consoleã§ Cloud Run ã®ãƒ­ã‚°ã‚’ç¢ºèª:
   - Cloud Runã‚µãƒ¼ãƒ“ã‚¹ã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒåˆ°é”ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - ãƒ­ã‚°ã«`req.body:`ã¨ã—ã¦ã€é€ä¿¡ã—ãŸãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - æ–‡å­—èµ·ã“ã—ãƒ—ãƒ­ã‚»ã‚¹ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

#### ãƒ•ã‚§ãƒ¼ã‚º3: Cloud Run â†’ Vercel (è¦ç´„)

5. æ–‡å­—èµ·ã“ã—å®Œäº†å¾Œã€Cloud Runã‹ã‚‰`/api/summarize-task`ã¸ã®POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒé€ä¿¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
6. `/api/summarize-task`ã®ãƒ­ã‚°ã‚’ç¢ºèª:
   - ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå—ä¿¡ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - transcriptãŒæ­£ã—ãå—ã‘å–ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - Geminiã§ã®è¦ç´„å‡¦ç†ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

#### ãƒ•ã‚§ãƒ¼ã‚º4: æœ€çµ‚ç¢ºèª

7. Supabaseã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ç¢ºèª:
   - `transcription_tasks`ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã€ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ`completed`ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
   - `final_summary`ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¦ç´„çµæœãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

## ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã¨èª¿æŸ»æ–¹æ³•

### Slack â†’ Vercel (ãƒ•ã‚§ãƒ¼ã‚º1)ã§ã®ã‚¨ãƒ©ãƒ¼

- Slackã‚³ãƒãƒ³ãƒ‰ãŒå¿œç­”ã—ãªã„:
  - Slackã‚¢ãƒ—ãƒªã®è¨­å®šã‚’ç¢ºèª
  - Vercelã®ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ…‹ã‚’ç¢ºèª
  - `/api/slack/intake`ã®URLãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª

- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—:
  - Vercelã®ãƒ­ã‚°ã‚’ç¢ºèª
  - Supabaseã®æ¥ç¶šè¨­å®šã‚’ç¢ºèª
  - Supabaseã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒã‚±ãƒƒãƒˆè¨­å®šã‚’ç¢ºèª

### Vercel â†’ Cloud Run (ãƒ•ã‚§ãƒ¼ã‚º2)ã§ã®ã‚¨ãƒ©ãƒ¼

- Cloud Runã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤±æ•—:
  - `CLOUD_RUN_TRANSCRIBE_URL`ç’°å¢ƒå¤‰æ•°ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  - Cloud Runã‚µãƒ¼ãƒ“ã‚¹ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ç¢ºèª
  - Cloud Runã®ãƒ­ã‚°ã§ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèª
  - æ¨©é™è¨­å®šã«å•é¡ŒãŒãªã„ã‹ç¢ºèª

### Cloud Run â†’ Vercel (ãƒ•ã‚§ãƒ¼ã‚º3)ã§ã®ã‚¨ãƒ©ãƒ¼

- è¦ç´„ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒå¤±æ•—:
  - Cloud Runã®`SUMMARIZE_TASK_ENDPOINT`ç’°å¢ƒå¤‰æ•°ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  - Cloud Runã®ãƒ­ã‚°ã§ã‚¨ãƒ©ãƒ¼ã‚’ç¢ºèª
  - `/api/summarize-task`ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒæ­£ã—ãæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ç¢ºèª

## ãƒ­ã‚°èª¿æŸ»ã®ãƒã‚¤ãƒ³ãƒˆ

- Vercelã®ãƒ­ã‚°:
  - ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ > ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ > Deployments > æœ€æ–°ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ > Logs
  - ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§æ™‚ç³»åˆ—ã‚’ç¢ºèª
  - `/api/slack/intake`ã€`/api/start-task`ã€`/api/summarize-task`ã®å„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ­ã‚°ã‚’ç¢ºèª

- Cloud Runã®ãƒ­ã‚°:
  - Google Cloud Console > Cloud Run > transcriber-service > ãƒ­ã‚°
  - ãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡ã€ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹é€ä¿¡ã®å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç¢ºèª

- Supabaseã®ãƒ‡ãƒ¼ã‚¿:
  - Supabaseãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ > ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ > transcription_tasks
  - ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–ã‚’ç¢ºèª
  - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç¢ºèª

## ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰

ã‚µãƒ³ãƒ—ãƒ«ãƒ“ãƒ‡ã‚ªã‚’ä½¿ã£ã¦ãƒ†ã‚¹ãƒˆã™ã‚‹å ´åˆ:

```bash
# é–‹ç™ºç’°å¢ƒã®ãƒ†ã‚¹ãƒˆ
npm run dev:webhook
npm run upload-slack -- <slack-file-url>
```

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: supabase/.branches/_current_branch
================
main

================
File: supabase/.temp/cli-latest
================
v2.22.12

================
File: supabase/.temp/gotrue-version
================
v2.172.1

================
File: supabase/.temp/pooler-url
================
postgresql://postgres.tqeprgfaybkvknmzeraj:[YOUR-PASSWORD]@aws-0-ap-northeast-1.pooler.supabase.com:6543/postgres

================
File: supabase/.temp/postgres-version
================
15.8.1.085

================
File: supabase/.temp/project-ref
================
tqeprgfaybkvknmzeraj

================
File: supabase/.temp/rest-version
================
v12.2.3

================
File: supabase/.temp/storage-version
================
custom-metadata

================
File: supabase/deno.json
================
{
  "compilerOptions": {
    "lib": ["deno.ns", "dom"],
    "strict": true
  },
  "lock": "deno.lock",
  "tasks": {
    "dev": "supabase functions serve --env-file ../.env.local --config ./config.toml"
  }
}

================
File: supabase/deno.lock
================
{
  "version": "3",
  "remote": {
    "https://deno.land/std@0.177.0/http/server.ts": "cbb17b594651215ba95c01a395700684e569c165a567e4e04bba327f41197433",
    "https://esm.sh/@supabase/supabase-js@2": "5975c1df8b2c6c0e865b79f1a17093fb4389f96dea159aa52fd60fe534b81ed6"
  }
}

================
File: supabase/functions/process-video-task/.npmrc
================
# Configuration for private npm package dependencies
# For more information on using private registries with Edge Functions, see:
# https://supabase.com/docs/guides/functions/import-maps#importing-from-private-registries

================
File: supabase/functions/summarize_dispatch/index.ts
================
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

// ã“ã‚Œã‚‰ã®ç’°å¢ƒå¤‰æ•°ã¯Supabaseãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®Edge Functionè¨­å®šã§å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
const VERCEL_SUMMARIZE_WEBHOOK_URL = Deno.env.get("VERCEL_SUMMARIZE_WEBHOOK_URL")!;
const WEBHOOK_SECRET = Deno.env.get("WEBHOOK_SECRET")!;

console.log("Function summarize_dispatch initialized.");
console.log(`VERCEL_SUMMARIZE_WEBHOOK_URL: ${VERCEL_SUMMARIZE_WEBHOOK_URL ? 'Loaded' : 'NOT LOADED'}`);
console.log(`WEBHOOK_SECRET: ${WEBHOOK_SECRET ? 'Loaded' : 'NOT LOADED'}`);

serve(async (req: Request) => {
  console.log("[summarize_dispatch] Received request");

  if (req.method !== "POST") {
    console.log(`[summarize_dispatch] Method Not Allowed: ${req.method}`);
    return new Response("Method Not Allowed", { status: 405 });
  }

  try {
    const payload = await req.json();
    // DBãƒˆãƒªã‚¬ãƒ¼ã‹ã‚‰ã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰æ§‹é€ ã‚’æƒ³å®š (record, old_record, type, table, schema)
    // ç‰¹ã«ã€payload.recordã«å¿…è¦ãªæƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    const record = payload.record;
    console.log("[summarize_dispatch] Payload received:", JSON.stringify(record, null, 2));

    if (!record || !record.id || record.transcription_result === undefined || record.transcription_result === null) {
      console.error("[summarize_dispatch] Invalid payload: Missing id or transcription_result", record);
      return new Response("Invalid payload: Missing id or transcription_result", { status: 400 });
    }

    const taskId = record.id as string;
    const transcriptionText = record.transcription_result as string;

    console.log(`[summarize_dispatch] Processing task: ${taskId}`);

    if (!VERCEL_SUMMARIZE_WEBHOOK_URL || !WEBHOOK_SECRET) {
      console.error("[summarize_dispatch] Environment variables VERCEL_SUMMARIZE_WEBHOOK_URL or WEBHOOK_SECRET are not set.");
      return new Response("Internal Server Error: Webhook URL or Secret not configured", { status: 500 });
    }

    const response = await fetch(VERCEL_SUMMARIZE_WEBHOOK_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${WEBHOOK_SECRET}`, // Vercelå´ã§ã“ã®Secretã‚’æ¤œè¨¼
      },
      body: JSON.stringify({ taskId, transcriptionText }),
    });

    const responseText = await response.text(); // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£ã‚’å…ˆã«å–å¾—
    console.log(`[summarize_dispatch] Vercel webhook response for task ${taskId}: ${response.status} ${responseText}`);

    if (!response.ok) {
      // Vercelã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãã®ã¾ã¾è¿”ã™ã‹ã€ã‚ã‚‹ã„ã¯ç‰¹å®šã®å‡¦ç†ã‚’è¡Œã†
      return new Response(`Vercel API call failed: ${response.status} ${responseText}`, {
        status: response.status, // Vercelã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ä¸­ç¶™
        headers: { 'Content-Type': 'application/json' } // å¿…è¦ã«å¿œã˜ã¦
      }); 
    }

    // Vercel APIãŒæˆåŠŸã—ãŸå ´åˆ (2xxãƒ¬ã‚¹ãƒãƒ³ã‚¹)
    // é€šå¸¸ã€ã“ã®Functionã¯Vercelã¸ã®ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãŒæˆåŠŸã™ã‚Œã°200ã‚’è¿”ã™
    return new Response(JSON.stringify({ message: "Successfully dispatched to Vercel for summarization", taskId, vercelResponse: responseText }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });

  } catch (e) {
    const error = e as Error; // Type assertion
    console.error("[summarize_dispatch] Error processing request:", error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred' }), { status: 500 });
  }
});

================
File: supabase/functions/transcribe_with_whisper/index.ts
================
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";

// ç’°å¢ƒå¤‰æ•°ã‹ã‚‰Supabaseã®æƒ…å ±ã‚’å–å¾—
const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
// const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY")!;
const supabaseServiceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const openaiApiKey = Deno.env.get("OPENAI_API_KEY")!;

interface TaskPayloadRecord {
  id: string;
  storage_path: string;
  status?: string; // old_record ã«ã¯ status ãŒã‚ã‚‹æƒ³å®š
  // ä»–ã®taskã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚å¿…è¦ã«å¿œã˜ã¦è¿½åŠ 
}
interface TaskPayload {
  type: "UPDATE";
  table: string;
  schema: string;
  record: TaskPayloadRecord;
  old_record: TaskPayloadRecord;
}

async function updateTaskStatus(supabase: SupabaseClient, taskId: string, status: string, transcription_result?: string) {
  const updateData: { status: string; transcription_result?: string; updated_at: string } = {
    status,
    updated_at: new Date().toISOString(),
  };
  if (transcription_result) {
    updateData.transcription_result = transcription_result;
  }

  const { error: updateError } = await supabase
    .from("transcription_tasks")
    .update(updateData)
    .eq("id", taskId);

  if (updateError) {
    console.error(`Error updating task ${taskId} to status ${status}:`, updateError);
  } else {
    console.log(`Task ${taskId} status successfully updated to ${status}.`);
  }
}

serve(async (req: Request) => {
  console.log("Function transcribe_with_whisper called");

  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  let taskIdForErrorHandling: string | undefined;

  try {
    const payload: TaskPayload = await req.json();
    console.log("Received payload:", JSON.stringify(payload, null, 2));

    const { id: taskId, storage_path: storagePath } = payload.record;
    taskIdForErrorHandling = taskId; // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç”¨ã«ä¿æŒ

    if (!taskId || !storagePath) {
      console.error("Missing taskId or storage_path in payload");
      return new Response("Missing taskId or storage_path", { status: 400 });
    }

    console.log(`Processing task ID: ${taskId}, Storage Path: ${storagePath}`);

    // const supabase = createClient(supabaseUrl, supabaseAnonKey, {
    const supabase = createClient(supabaseUrl, supabaseServiceRoleKey, {
      global: {
        // headers: { Authorization: `Bearer ${supabaseAnonKey}` }, 
        headers: { Authorization: `Bearer ${supabaseServiceRoleKey}` },
      },
    });

    // 1. Supabase Storageã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾— (ArrayBuffer)
    console.log(`Fetching file from Supabase Storage: ${storagePath}`);
    const { data: fileData, error: downloadError } = await supabase.storage
      .from("videos") // tasksãƒ†ãƒ¼ãƒ–ãƒ«ã®storage_pathã«åˆã‚ã›ã¦ãƒã‚±ãƒƒãƒˆåã‚’æŒ‡å®š
      .download(storagePath);

    if (downloadError || !fileData) {
      console.error("Error downloading file:", downloadError);
      await updateTaskStatus(supabase, taskId, "transcribe_failed", `Error downloading file: ${downloadError?.message}`);
      return new Response(`Failed to download file: ${downloadError?.message}`, { status: 500 });
    }
    console.log("File downloaded successfully.");
    const fileArrayBuffer = await fileData.arrayBuffer();

    // 2. FormDataã®æ§‹ç¯‰ (Denoã§ã®å¯¾å¿œ)
    const { File } = await import("https://deno.land/x/formdata_polyfill@v4.0.12/mod.ts");

    // 1. ãƒ•ã‚¡ã‚¤ãƒ«åã¨MIMEã‚¿ã‚¤ãƒ—æ¨å®š
    const fileName = storagePath.split("/").pop() || "audio.unknown"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨­å®š
    const getMimeType = (name: string): string => {
      if (name.endsWith(".mp3")) return "audio/mpeg";
      if (name.endsWith(".mp4")) return "video/mp4"; // Whisperã¯mp4ã‚‚å¯
      if (name.endsWith(".mpeg")) return "video/mpeg";
      if (name.endsWith(".mpga")) return "audio/mpeg";
      if (name.endsWith(".m4a")) return "audio/mp4";
      if (name.endsWith(".wav")) return "audio/wav";
      if (name.endsWith(".webm")) return "video/webm";
      // å¿…è¦ã«å¿œã˜ã¦ä»–ã®MIMEã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ 
      console.warn(`Unknown file type for ${name}, defaulting to application/octet-stream`);
      return "application/octet-stream"; // ä¸æ˜ãªå ´åˆã¯æ±ç”¨çš„ãªMIMEã‚¿ã‚¤ãƒ—
    };
    const mimeType = getMimeType(fileName);
    console.log(`Determined fileName: ${fileName}, mimeType: ${mimeType}`);

    // 2. Fileã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
    const file = new File([fileArrayBuffer], fileName, { type: mimeType });

    // 3. FormDataã®æ§‹ç¯‰
    const formData = new FormData();
    formData.append("file", file);
    formData.append("model", "whisper-1");
    // formData.append("language", "ja"); // å¿…è¦ã«å¿œã˜ã¦è¨€èªæŒ‡å®š
    // formData.append("prompt", "ã“ã‚“ã«ã¡ã¯ã€‚"); // å¿…è¦ã«å¿œã˜ã¦ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¿½åŠ 
    // formData.append("response_format", "json"); // verbose_jsonã‚„srtãªã©ã‚‚æŒ‡å®šå¯èƒ½
    // formData.append("temperature", "0"); // 0-1ã§æŒ‡å®šã€é«˜ã„ã»ã©ãƒ©ãƒ³ãƒ€ãƒ 

    console.log("FormData constructed successfully.");


    // 3. OpenAI Whisper APIã«é€ä¿¡
    console.log(`Sending data to OpenAI Whisper API for task: ${taskId}`);
    const whisperApiUrl = "https://api.openai.com/v1/audio/transcriptions";
    
    let whisperResponse;
    try {
      whisperResponse = await fetch(whisperApiUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${openaiApiKey}`,
          // 'Content-Type': 'multipart/form-data' ã¯fetchãŒè‡ªå‹•ã§è¨­å®šã™ã‚‹ (boundaryå«ã‚€)
        },
        body: formData,
      });
    } catch (e) {
      const fetchError = e as Error; // å‹ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
      console.error(`[${taskId}] Fetch error calling Whisper API:`, fetchError);
      await updateTaskStatus(supabase, taskId, "transcribe_failed", `Fetch error: ${fetchError.message ? fetchError.message.slice(0,300) : 'Unknown fetch error'}`);
      return new Response(`Whisper API fetch error: ${fetchError.message || 'Unknown fetch error'}`, { status: 500 });
    }
    

    if (!whisperResponse.ok) {
      const errorText = await whisperResponse.text();
      console.error(`[${taskId}] Whisper API Error: ${whisperResponse.status}`, errorText);
      // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã™ãã‚‹å ´åˆãŒã‚ã‚‹ã®ã§ã€DBã«ã¯ä¸€éƒ¨ã‚’ä¿å­˜
      const dbErrorMessage = `Whisper API Error ${whisperResponse.status}: ${errorText.slice(0, 250)}`;
      await updateTaskStatus(supabase, taskId, "transcribe_failed", dbErrorMessage);
      return new Response(`Whisper API failed: ${errorText}`, { status: whisperResponse.status });
    }

    const result = await whisperResponse.json();
    const transcribedText = result.text || ""; // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«textãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨ã—ãªã„å ´åˆã‚‚è€ƒæ…®
    
    if (typeof transcribedText !== 'string' || transcribedText.trim() === "") {
        console.warn(`[${taskId}] Whisper API returned empty or invalid text. Result:`, JSON.stringify(result));
        await updateTaskStatus(supabase, taskId, "transcribe_failed", "Whisper API returned empty or invalid text.");
        return new Response("Whisper API returned empty or invalid text.", { status: 500 });
    }

    console.log(`[${taskId}] Transcription success (first 100 chars):`, transcribedText.slice(0, 100));

    // 4. ã‚¿ã‚¹ã‚¯ã‚’æ›´æ–° (transcription_result ã¨ status)
    await updateTaskStatus(supabase, taskId, "transcribed", transcribedText);
    console.log(`Task ${taskId} status updated to transcribed.`);

    return new Response(JSON.stringify({ message: "Transcription successful", taskId, transcribedText: transcribedText.slice(0,100) + "..." }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });

  } catch (e) {
    const error = e as Error;
    console.error("Error in function:", error);
    if (taskIdForErrorHandling) {
      // const supabase = createClient(supabaseUrl, supabaseAnonKey); // å†åˆæœŸåŒ–
      const supabase = createClient(supabaseUrl, supabaseServiceRoleKey); // å†åˆæœŸåŒ–æ™‚ã‚‚service_role_keyã‚’ä½¿ç”¨
      await updateTaskStatus(supabase, taskIdForErrorHandling, "transcribe_failed", `Function error: ${error.message}`);
    }
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
});

================
File: supabase/migrations/20250517181202_remote_schema.sql
================
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."transcription_tasks" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "storage_path" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "original_file_name" "text",
    "transcript_path" "text",
    "summary_path" "text",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transcription_tasks_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."transcription_tasks" OWNER TO "postgres";


COMMENT ON TABLE "public"."transcription_tasks" IS 'Stores tasks for video transcription and summarization, including status and paths to generated files.';



COMMENT ON COLUMN "public"."transcription_tasks"."id" IS 'Primary key, unique identifier for the task (UUID).';



COMMENT ON COLUMN "public"."transcription_tasks"."storage_path" IS 'Full path to the original video file in Supabase Storage (e.g., uploads/uuid.mp4). Provided by the webhook.';



COMMENT ON COLUMN "public"."transcription_tasks"."status" IS 'Current status of the transcription task (e.g., pending, processing, completed, failed).';



COMMENT ON COLUMN "public"."transcription_tasks"."original_file_name" IS 'Original name of the file as uploaded from Slack.';



COMMENT ON COLUMN "public"."transcription_tasks"."transcript_path" IS 'Path to the generated transcript text file in Supabase Storage.';



COMMENT ON COLUMN "public"."transcription_tasks"."summary_path" IS 'Path to the generated summary markdown file in Supabase Storage.';



COMMENT ON COLUMN "public"."transcription_tasks"."error_message" IS 'Stores any error message if the task processing failed.';



COMMENT ON COLUMN "public"."transcription_tasks"."created_at" IS 'Timestamp indicating when the task record was created.';



COMMENT ON COLUMN "public"."transcription_tasks"."updated_at" IS 'Timestamp indicating when the task record was last updated (automatically managed by a trigger).';



ALTER TABLE ONLY "public"."transcription_tasks"
    ADD CONSTRAINT "transcription_tasks_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_transcription_tasks_created_at" ON "public"."transcription_tasks" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_transcription_tasks_status" ON "public"."transcription_tasks" USING "btree" ("status");



CREATE OR REPLACE TRIGGER "update_transcription_tasks_updated_at" BEFORE UPDATE ON "public"."transcription_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE POLICY "Allow full access for service_role" ON "public"."transcription_tasks" USING (true) WITH CHECK (true);



ALTER TABLE "public"."transcription_tasks" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";











































































































































































GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";


















GRANT ALL ON TABLE "public"."transcription_tasks" TO "anon";
GRANT ALL ON TABLE "public"."transcription_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."transcription_tasks" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;

================
File: supabase/migrations/20250517181203_create_transcription_task_trigger.sql
================
-- pg_net æ‹¡å¼µæ©Ÿèƒ½ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª (ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æœ€åˆã®æ–¹ã§ä¸€åº¦ã ã‘å®Ÿè¡Œã™ã‚Œã°ã‚ˆã„)
-- create extension if not exists pg_net with schema extensions;

-- ãƒˆãƒªã‚¬ãƒ¼é–¢æ•°ã‚’ä½œæˆ
create or replace function public.handle_new_transcription_task()
returns trigger
language plpgsql
security definer -- FunctionãŒDBæ“ä½œç­‰ã§æ˜‡æ ¼ã•ã‚ŒãŸæ¨©é™ã‚’å¿…è¦ã¨ã™ã‚‹å ´åˆ
as $$
begin
  perform net.http_post(
    url:='http://127.0.0.1:54321/functions/v1/process-video-task', -- ãƒ­ãƒ¼ã‚«ãƒ«Supabase Functionã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    body:=jsonb_build_object( -- jsonbå‹ã§payloadã‚’æ§‹ç¯‰
      'type', TG_OP,
      'table', TG_TABLE_NAME,
      'schema', TG_TABLE_SCHEMA,
      'record', row_to_json(new)
      -- 'old_record' ã¯INSERTæ™‚ã«ã¯ä¸è¦ãªã®ã§çœç•¥ã‚‚å¯
    ),
    headers:=jsonb_build_object( -- jsonbå‹ã§ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ§‹ç¯‰
      'Content-Type', 'application/json',
      'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0'
    )
  );
  return new;
end;
$$;

-- transcription_tasks ãƒ†ãƒ¼ãƒ–ãƒ«ã«ãƒˆãƒªã‚¬ãƒ¼ã‚’è¨­å®š
create trigger on_new_transcription_task
  after insert on public.transcription_tasks
  for each row execute procedure public.handle_new_transcription_task();

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: '#0070f3',
      },
    },
  },
  plugins: [],
}

================
File: app/api/summarize-task/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { GoogleGenerativeAI } from '@google/generative-ai';

// --- ç’°å¢ƒå¤‰æ•° -----------------------------------------------------------------
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY; // DBæ›´æ–°ç”¨ã«Service Role Keyã‚’æ¨å¥¨
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const NEXT_PUBLIC_APP_URL = process.env.NEXT_PUBLIC_APP_URL;

// --- å®šæ•° -------------------------------------------------------------------
const MAX_TRANSCRIPT_TOKENS = 15000; // ä»®ã®å€¤ã€‚å®Ÿéš›ã®Geminiã®ãƒ¢ãƒ‡ãƒ«ã«åˆã‚ã›ã¦èª¿æ•´ã€‚

// --- Supabase ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ– -----------------------------------------------
let supabase: SupabaseClient | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
    auth: {
      persistSession: false, // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã®å‡¦ç†ãªã®ã§ã‚»ãƒƒã‚·ãƒ§ãƒ³æ°¸ç¶šåŒ–ã¯ä¸è¦
      autoRefreshToken: false, // è‡ªå‹•ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚‚ä¸è¦
    }
  });
} else {
  console.error('[summarize-task/route.ts] Missing Supabase URL or Service Role Key env vars.');
}

// --- Gemini ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ– -------------------------------------------------
let genAI: GoogleGenerativeAI | null = null;
if (GEMINI_API_KEY) {
  genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
} else {
  console.error('[summarize-task/route.ts] Missing GEMINI_API_KEY env var.');
}

// --- å‹å®šç¾© -------------------------------------------------------------------
interface SummarizeTaskPayload {
  taskId: string;
  transcript: string;
  // metadataã¯Supabaseã‹ã‚‰å–å¾—ã™ã‚‹ã®ã§ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã«ã¯å«ã‚ãªã„è¨­è¨ˆã¨ã—ã¾ã™ã€‚
  // ã‚‚ã—å‘¼ã³å‡ºã—å…ƒãŒmetadataã‚’æ¸¡ã™å ´åˆã¯ã€ã“ã“ã®å‹å®šç¾©ã¨å‡¦ç†ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
}

interface TaskMetadata {
  consultant_name?: string;
  company_name?: string;
  company_type?: string;
  company_problem?: string;
  meeting_date?: string;
  meeting_count?: string | number; // DBã®å‹ã«åˆã‚ã›ã¦èª¿æ•´
  meeting_type?: string;
  support_area?: string;
  // company_phase, internal_sharing_items ã‚‚å¿…è¦ã«å¿œã˜ã¦è¿½åŠ 
}

// --- ãƒ¡ã‚¤ãƒ³å‡¦ç† -----------------------------------------------------------------
export async function POST(request: NextRequest) {
  console.log(`[${new Date().toISOString()}] /api/summarize-task: POST request received.`);

  // 1. èªå¯ãƒã‚§ãƒƒã‚¯ (WEBHOOK_SECRET)
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET || !authHeader || !authHeader.startsWith('Bearer ') || authHeader.substring(7) !== WEBHOOK_SECRET) {
    console.warn(`[${new Date().toISOString()}] /api/summarize-task: Unauthorized access attempt.`);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  console.log(`[${new Date().toISOString()}] /api/summarize-task: Authorization successful.`);

  // 2. Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨Geminiã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®åˆ©ç”¨å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
  if (!supabase) {
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Supabase client is not initialized.`);
    return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
  }
  // Geminiã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯å¾Œç¶šã®ãƒ•ã‚§ãƒ¼ã‚ºã§ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŒã€ã“ã“ã§ã‚‚å­˜åœ¨ç¢ºèªã¯å¯èƒ½
  if (!genAI) {
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Gemini AI client is not initialized.`);
    return NextResponse.json({ error: 'Server configuration error: Gemini AI client not available.' }, { status: 500 });
  }

  // 3. ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒ‘ãƒ¼ã‚¹
  let payload: SummarizeTaskPayload;
  try {
    payload = await request.json();
    if (!payload.taskId || typeof payload.taskId !== 'string' || !payload.transcript || typeof payload.transcript !== 'string') {
      throw new Error('Invalid request body: taskId and transcript are required and must be strings.');
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error parsing request body.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error parsing request body: ${errorMessage}`);
    return NextResponse.json({ error: 'Invalid request body', details: errorMessage }, { status: 400 });
  }
  const { taskId, transcript } = payload;
  console.log(`[${new Date().toISOString()}] /api/summarize-task: Parsed request for taskId: ${taskId}`);

  // 4. Supabaseã‹ã‚‰ã‚¿ã‚¹ã‚¯ã®ãƒ¡ã‚¿æƒ…å ±ã‚’å–å¾—
  let taskMeta: TaskMetadata | null = null;
  try {
    const { data: metaData, error: metaError } = await supabase
      .from('transcription_tasks')
      .select('consultant_name, company_name, company_type, company_problem, meeting_date, meeting_count, meeting_type, support_area')
      .eq('id', taskId)
      .single();

    if (metaError) {
      if (metaError.code === 'PGRST116') { // PostgREST error code for "Not found"
        console.warn(`[${new Date().toISOString()}] /api/summarize-task: Task not found in DB for taskId: ${taskId}`);
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
      }
      throw metaError; // ãã®ä»–ã®DBã‚¨ãƒ©ãƒ¼
    }
    taskMeta = metaData;
    console.log(`[${new Date().toISOString()}] /api/summarize-task: Successfully fetched metadata for taskId ${taskId}:`, taskMeta);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown DB error.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error fetching metadata from DB for taskId ${taskId}: ${errorMessage}`);
    return NextResponse.json({ error: 'Failed to fetch task metadata', details: errorMessage }, { status: 500 });
  }

  // 5. ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ 'summarizing' ã«æ›´æ–°
  try {
    const { error: updateError } = await supabase
      .from('transcription_tasks')
      .update({ status: 'summarizing', updated_at: new Date().toISOString() })
      .eq('id', taskId);

    if (updateError) {
      throw updateError;
    }
    console.log(`[${new Date().toISOString()}] /api/summarize-task: Successfully updated status to 'summarizing' for taskId: ${taskId}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown DB error during status update.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error updating status to summarizing for taskId ${taskId}: ${errorMessage}`);
    // ã“ã“ã§ãƒªã‚¿ãƒ¼ãƒ³ã—ã¦ã‚‚è‰¯ã„ãŒã€å¾Œç¶šã®å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã®æœ€çµ‚çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚‚ã‚ã‚‹ãŸã‚ã€ä¸€æ—¦å‡¦ç†ã‚’ç¶šã‘ã‚‹ã“ã¨ã‚‚è€ƒãˆã‚‰ã‚Œã‚‹ã€‚
    // ãŸã ã—ã€è‡´å‘½çš„ãªå ´åˆã¯ãƒªã‚¿ãƒ¼ãƒ³ã™ã¹ãã€‚
    return NextResponse.json({ error: 'Failed to update task status', details: errorMessage }, { status: 500 });
  }

  // --- ã“ã“ã¾ã§ãŒåˆå¼¾ --- 
  // ã“ã®å¾Œã€ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å‰å‡¦ç†ã€Gemini Phase 1-4ã®å®Ÿè¡Œã€çµæœä¿å­˜ã€æœ€çµ‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãŒç¶šã

  console.log(`[${new Date().toISOString()}] /api/summarize-task: Initial processing complete for taskId: ${taskId}. Transcript length: ${transcript.length}`);
  console.log("Task Metadata:", taskMeta);

  // -------- ãƒˆãƒ©ãƒ³ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ãƒˆãƒªãƒŸãƒ³ã‚° -----------------------------
  // Geminiã®ãƒˆãƒ¼ã‚¯ãƒ³ä¸Šé™ã«åˆã‚ã›ã¦éƒ¨åˆ†æ–‡å­—åˆ—ã‚’å–å¾—ï¼ˆãŠãŠã‚ˆã1ãƒˆãƒ¼ã‚¯ãƒ³=4æ–‡å­—ã¨ä»®å®šï¼‰
  const approxCharLimit = MAX_TRANSCRIPT_TOKENS * 4;
  const trimmedTranscript = transcript.length > approxCharLimit
    ? transcript.slice(-approxCharLimit)
    : transcript;

  // -------- Gemini ã«ã‚ˆã‚‹å„ãƒ•ã‚§ãƒ¼ã‚ºã®å‡¦ç† ----------------------------
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const metaPrompt = (meta: TaskMetadata | null) => {
    if (!meta) return "";
    const entries = Object.entries(meta)
      .filter(([_, v]) => v !== null && v !== undefined && v !== "")
      .map(([k, v]) => `- ${k}: ${v}`)
      .join("\n");
    return entries ? `ä»¥ä¸‹ã¯ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã®ãƒ¡ã‚¿æƒ…å ±ã§ã™:\n${entries}\n` : "";
  };

  type PhaseResult = {
    json: any;
    rawText: string;
  };

  const runPhase = async (phase: "phase1" | "phase2" | "phase3", meta: TaskMetadata | null, transcriptChunk: string): Promise<PhaseResult> => {
    let instruction = "";
    switch (phase) {
      case "phase1":
        instruction = `ã‚ãªãŸã¯å„ªç§€ãªè­°äº‹éŒ²ä½œæˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚${metaPrompt(meta)}\nã€Œè­°äº‹ã®è¦ç‚¹ã€ã‚’æ—¥æœ¬èªã§ç®‡æ¡æ›¸ãï¼ˆæœ€å¤§10é …ç›®ï¼‰ã«ã¾ã¨ã‚ã€ä»¥ä¸‹ã®JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ã€‚\n{\n  \"key_points\": string[]\n}`;
        break;
      case "phase2":
        instruction = `ã‚ãªãŸã¯å„ªç§€ãªè­°äº‹éŒ²ä½œæˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚${metaPrompt(meta)}\nä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‚’è«–ç†çš„ãªç« ç«‹ã¦ï¼ˆã‚¢ã‚¸ã‚§ãƒ³ãƒ€ï¼‰ã«åˆ†å‰²ã—ã€å„ç« ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚JSONå½¢å¼:\n{\n  \"sections\": { \"title\": string, \"summary\": string }[]\n}`;
        break;
      case "phase3":
        instruction = `ã‚ãªãŸã¯å„ªç§€ãªè­°äº‹éŒ²ä½œæˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚${metaPrompt(meta)}\nä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‚’è©±è€…ã”ã¨ã«ã¾ã¨ã‚ã€å„è©±è€…ã”ã¨ã«ç™ºè¨€è¦ç´„ã‚’ä½œæˆã—ã€é‡è¦ãƒã‚¤ãƒ³ãƒˆã‚’æŠ½å‡ºã—ã¦ãã ã•ã„ã€‚JSONå½¢å¼:\n{\n  \"speakers\": { \"name\": string, \"summary\": string }[]\n}`;
        break;
    }

    const prompt = `${instruction}\n--- æ–‡å­—èµ·ã“ã—ã“ã“ã‹ã‚‰ ---\n${transcriptChunk}\n--- æ–‡å­—èµ·ã“ã—ã“ã“ã¾ã§ ---`;

    try {
      const result = await model.generateContent(prompt);
      const raw = result.response.text();
      const firstJsonMatch = raw.match(/\{[\s\S]*\}/);
      if (!firstJsonMatch) throw new Error("JSON not found in model output");
      const parsed = JSON.parse(firstJsonMatch[0]);
      return { json: parsed, rawText: raw };
    } catch (err) {
      console.error(`[summarize-task] ${phase} failed:`, err);
      throw new Error(`${phase}_failed`);
    }
  };

  let phase1: PhaseResult | null = null;
  let phase2: PhaseResult | null = null;
  let phase3: PhaseResult | null = null;

  try {
    [phase1, phase2, phase3] = await Promise.all([
      runPhase("phase1", taskMeta, trimmedTranscript),
      runPhase("phase2", taskMeta, trimmedTranscript),
      runPhase("phase3", taskMeta, trimmedTranscript),
    ]);
    console.log(`[summarize-task] Phase1-3 completed for taskId ${taskId}`);
  } catch (e) {
    // ã„ãšã‚Œã‹ã®ãƒ•ã‚§ãƒ¼ã‚ºã§å¤±æ•—
    const errMsg = e instanceof Error ? e.message : String(e);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Summarization failed', details: errMsg }, { status: 500 });
  }

  // -------- Phase4: çµ±åˆ -----------------------------------------------
  let finalSummary = "";
  try {
    const consolidationPrompt = `ã‚ãªãŸã¯ãƒ—ãƒ­ã®ã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸãƒ•ã‚§ãƒ¼ã‚º1-3ã®çµæœã‚’ã‚‚ã¨ã«ã€ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°è­°äº‹éŒ²ã‚’æ—¥æœ¬èªã§1000å­—ä»¥å†…ã®Markdownã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚\n\n## ãƒ¡ã‚¿æƒ…å ±\n${metaPrompt(taskMeta)}\n\n## ãƒ•ã‚§ãƒ¼ã‚º1 è¦ç‚¹\n${JSON.stringify(phase1.json)}\n\n## ãƒ•ã‚§ãƒ¼ã‚º2 ç« ç«‹ã¦\n${JSON.stringify(phase2.json)}\n\n## ãƒ•ã‚§ãƒ¼ã‚º3 è©±è€…åˆ¥ã¾ã¨ã‚\n${JSON.stringify(phase3.json)}\n\n## å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ\n- ã‚¿ã‚¤ãƒˆãƒ«è¡Œã¨ã—ã¦ \"# è­°äº‹ãƒ¡ãƒ¢\" ã‚’å«ã‚ã‚‹\n- é©åˆ‡ãªMarkdownè¦‹å‡ºã—ã‚’ç”¨ã„ã‚‹\n- 1000å­—ä»¥å†…ã«åã‚ã‚‹`;

    const phase4Res = await model.generateContent(consolidationPrompt);
    finalSummary = phase4Res.response.text();
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`[summarize-task] Phase4 failed:`, errMsg);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Final summary generation failed', details: errMsg }, { status: 500 });
  }

  // -------- Supabase ã¸ã®ä¿å­˜ ---------------------------------------------
  try {
    const { error: saveError } = await supabase.from('transcription_tasks').update({
      phase1_output: phase1.json,
      phase2_output: phase2.json,
      phase3_output: phase3.json,
      final_summary: finalSummary,
      status: 'completed',
      updated_at: new Date().toISOString(),
    }).eq('id', taskId);

    if (saveError) throw saveError;
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : 'Unknown DB error';
    console.error(`[summarize-task] DB save failed for taskId ${taskId}:`, errMsg);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Failed to save summary', details: errMsg }, { status: 500 });
  }

  // -------- å®Œäº† -----------------------------------------------------------
  console.log(`[summarize-task] All phases completed for taskId ${taskId}`);
  return NextResponse.json({
    message: 'Summarization completed',
    taskId,
    phase1: phase1.json,
    phase2: phase2.json,
    phase3: phase3.json,
    finalSummary,
  });

  // -------- Notion é€£æºã‚’éåŒæœŸã§å‘¼ã³å‡ºã— -------------------------------
  try {
    if (NEXT_PUBLIC_APP_URL && WEBHOOK_SECRET) {
      fetch(`${NEXT_PUBLIC_APP_URL}/api/notion-sync`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${WEBHOOK_SECRET}`,
        },
        body: JSON.stringify({ taskId }),
      }).then(res => res.text()).then(txt => console.log(`[summarize-task] notion-sync response:`, txt)).catch(err => console.error(`[summarize-task] notion-sync fetch error:`, err));
    } else {
      console.warn('[summarize-task] NEXT_PUBLIC_APP_URL or WEBHOOK_SECRET not set; skipping notion-sync call.');
    }
  } catch (err) {
    console.error('[summarize-task] Error triggering notion-sync:', err);
  }
}

================
File: app/scripts/upload-slack-file.ts
================
#!/usr/bin/env node
import { config } from 'dotenv';
import { uploadSlackFileToSupabase } from '../utils/slack-to-supabase-uploader';

// .envã‹ã‚‰ç’°å¢ƒå¤‰æ•°ã‚’èª­ã¿è¾¼ã‚€
config();

async function main() {
  // ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã‹ã‚‰Slackãƒ•ã‚¡ã‚¤ãƒ«URLã‚’å–å¾—
  const slackFileUrl = process.argv[2];
  
  if (!slackFileUrl) {
    console.error('ã‚¨ãƒ©ãƒ¼: Slackãƒ•ã‚¡ã‚¤ãƒ« URL ãŒå¿…è¦ã§ã™');
    console.error('ä½¿ç”¨æ–¹æ³•: npm run upload-slack <slack-file-url>');
    console.error('ä¾‹: npm run upload-slack https://files.slack.com/files-pri/T12345-F67890/meeting.mp4');
    process.exit(1);
  }
  
  // å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã®ãƒã‚§ãƒƒã‚¯
  const requiredEnvVars = [
    'SLACK_BOT_TOKEN',
    'UPLOAD_API_ENDPOINT',
    'WEBHOOK_SECRET',
  ];
  
  const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
  if (missingVars.length > 0) {
    console.error(`ã‚¨ãƒ©ãƒ¼: å¿…è¦ãªç’°å¢ƒå¤‰æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${missingVars.join(', ')}`);
    console.error('ç’°å¢ƒå¤‰æ•°ã®è¨­å®šã¾ãŸã¯.envãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„');
    process.exit(1);
  }
  
  try {
    console.log(`ğŸš€ Slackãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–‹å§‹: ${slackFileUrl}`);
    
    const result = await uploadSlackFileToSupabase({
      slackFileUrl,
      slackToken: process.env.SLACK_BOT_TOKEN!,
      uploadEndpoint: process.env.UPLOAD_API_ENDPOINT!,
      webhookSecret: process.env.WEBHOOK_SECRET!,
      logProgress: true,
      maxRetries: 3,
      metadata: {
        cli_executed_at: new Date().toISOString(),
        cli_version: '1.0.0'
      }
    });
    
    console.log('âœ… ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ­£å¸¸çµ‚äº†!');
    console.log('ğŸ“Š ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰è©³ç´°:');
    console.log(`  - ID: ${result.id}`);
    console.log(`  - ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${result.status}`);
    console.log(`  - ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ‘ã‚¹: ${result.storage_path}`);
    console.log(`  - ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: ${result.file_size} ãƒã‚¤ãƒˆ`);
    
    if (result.status === 'processing') {
      console.log('\nğŸ¬ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:');
      console.log('  ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ­£å¸¸ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã€ç¾åœ¨ã¯æ–‡å­—èµ·ã“ã—å‡¦ç†å¾…ã¡ã§ã™ã€‚');
      console.log('  å‡¦ç†çŠ¶æ³ã¯ Supabase ã® upload_logs ãƒ†ãƒ¼ãƒ–ãƒ«ã§ç¢ºèªã§ãã¾ã™ã€‚');
    }
    
    // å‡¦ç†ãŒå®Œäº†ã—ãŸå ´åˆã®ã¿çµ‚äº†ã‚³ãƒ¼ãƒ‰0
    process.exit(0);
  } catch (error) {
    console.error('âŒ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—:', error instanceof Error ? error.message : error);
    // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯çµ‚äº†ã‚³ãƒ¼ãƒ‰1
    process.exit(1);
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
main();

================
File: deno.lock
================
{
  "version": "5",
  "specifiers": {
    "jsr:@std/dotenv@0.224": "0.224.2",
    "npm:@google/generative-ai@~0.24.1": "0.24.1",
    "npm:@notionhq/client@^3.0.1": "3.0.1",
    "npm:@slack/web-api@^7.9.1": "7.9.1",
    "npm:@supabase/auth-js@2.69.1": "2.69.1",
    "npm:@supabase/functions-js@2.4.4": "2.4.4",
    "npm:@supabase/node-fetch@2.6.15": "2.6.15",
    "npm:@supabase/postgrest-js@1.19.4": "1.19.4",
    "npm:@supabase/realtime-js@2.11.2": "2.11.2",
    "npm:@supabase/storage-js@2.7.1": "2.7.1",
    "npm:@supabase/supabase-js@2.43.4": "2.43.4",
    "npm:@supabase/supabase-js@^2.49.4": "2.49.4",
    "npm:@types/node@*": "22.15.15",
    "npm:@types/node@^22.15.18": "22.15.18",
    "npm:@types/react@^19.1.4": "19.1.4",
    "npm:@types/uuid@10": "10.0.0",
    "npm:formdata-node@^6.0.3": "6.0.3",
    "npm:next@^15.3.2": "15.3.2_react@19.1.0_react-dom@19.1.0__react@19.1.0",
    "npm:openai@^4.100.0": "4.100.0",
    "npm:supabase@2.22.12": "2.22.12",
    "npm:supabase@^2.22.12": "2.22.12",
    "npm:typescript@^5.8.3": "5.8.3",
    "npm:uuid@^11.1.0": "11.1.0"
  },
  "jsr": {
    "@std/dotenv@0.224.2": {
      "integrity": "29081695357e4534696c9e986b2560be29c141ccf52daa32b6c20ff5b5c64ab9"
    }
  },
  "npm": {
    "@emnapi/runtime@1.4.3": {
      "integrity": "sha512-pBPWdu6MLKROBX05wSNKcNb++m5Er+KQ9QkB+WVM+pW2Kx9hoSrVTnu3BdkI5eBLZoKu/J6mW/B6i6bJB2ytXQ==",
      "dependencies": [
        "tslib"
      ]
    },
    "@google/generative-ai@0.24.1": {
      "integrity": "sha512-MqO+MLfM6kjxcKoy0p1wRzG3b4ZZXtPI+z2IE26UogS2Cm/XHO+7gGRBh6gcJsOiIVoH93UwKvW4HdgiOZCy9Q=="
    },
    "@img/sharp-darwin-arm64@0.34.1": {
      "integrity": "sha512-pn44xgBtgpEbZsu+lWf2KNb6OAf70X68k+yk69Ic2Xz11zHR/w24/U49XT7AeRwJ0Px+mhALhU5LPci1Aymk7A==",
      "optionalDependencies": [
        "@img/sharp-libvips-darwin-arm64"
      ],
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@img/sharp-darwin-x64@0.34.1": {
      "integrity": "sha512-VfuYgG2r8BpYiOUN+BfYeFo69nP/MIwAtSJ7/Zpxc5QF3KS22z8Pvg3FkrSFJBPNQ7mmcUcYQFBmEQp7eu1F8Q==",
      "optionalDependencies": [
        "@img/sharp-libvips-darwin-x64"
      ],
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-darwin-arm64@1.1.0": {
      "integrity": "sha512-HZ/JUmPwrJSoM4DIQPv/BfNh9yrOA8tlBbqbLz4JZ5uew2+o22Ik+tHQJcih7QJuSa0zo5coHTfD5J8inqj9DA==",
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-darwin-x64@1.1.0": {
      "integrity": "sha512-Xzc2ToEmHN+hfvsl9wja0RlnXEgpKNmftriQp6XzY/RaSfwD9th+MSh0WQKzUreLKKINb3afirxW7A0fz2YWuQ==",
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-linux-arm64@1.1.0": {
      "integrity": "sha512-IVfGJa7gjChDET1dK9SekxFFdflarnUB8PwW8aGwEoF3oAsSDuNUTYS+SKDOyOJxQyDC1aPFMuRYLoDInyV9Ew==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-linux-arm@1.1.0": {
      "integrity": "sha512-s8BAd0lwUIvYCJyRdFqvsj+BJIpDBSxs6ivrOPm/R7piTs5UIwY5OjXrP2bqXC9/moGsyRa37eYWYCOGVXxVrA==",
      "os": ["linux"],
      "cpu": ["arm"]
    },
    "@img/sharp-libvips-linux-ppc64@1.1.0": {
      "integrity": "sha512-tiXxFZFbhnkWE2LA8oQj7KYR+bWBkiV2nilRldT7bqoEZ4HiDOcePr9wVDAZPi/Id5fT1oY9iGnDq20cwUz8lQ==",
      "os": ["linux"],
      "cpu": ["ppc64"]
    },
    "@img/sharp-libvips-linux-s390x@1.1.0": {
      "integrity": "sha512-xukSwvhguw7COyzvmjydRb3x/09+21HykyapcZchiCUkTThEQEOMtBj9UhkaBRLuBrgLFzQ2wbxdeCCJW/jgJA==",
      "os": ["linux"],
      "cpu": ["s390x"]
    },
    "@img/sharp-libvips-linux-x64@1.1.0": {
      "integrity": "sha512-yRj2+reB8iMg9W5sULM3S74jVS7zqSzHG3Ol/twnAAkAhnGQnpjj6e4ayUz7V+FpKypwgs82xbRdYtchTTUB+Q==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-linuxmusl-arm64@1.1.0": {
      "integrity": "sha512-jYZdG+whg0MDK+q2COKbYidaqW/WTz0cc1E+tMAusiDygrM4ypmSCjOJPmFTvHHJ8j/6cAGyeDWZOsK06tP33w==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-linuxmusl-x64@1.1.0": {
      "integrity": "sha512-wK7SBdwrAiycjXdkPnGCPLjYb9lD4l6Ze2gSdAGVZrEL05AOUJESWU2lhlC+Ffn5/G+VKuSm6zzbQSzFX/P65A==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-linux-arm64@0.34.1": {
      "integrity": "sha512-kX2c+vbvaXC6vly1RDf/IWNXxrlxLNpBVWkdpRq5Ka7OOKj6nr66etKy2IENf6FtOgklkg9ZdGpEu9kwdlcwOQ==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-arm64"
      ],
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-linux-arm@0.34.1": {
      "integrity": "sha512-anKiszvACti2sGy9CirTlNyk7BjjZPiML1jt2ZkTdcvpLU1YH6CXwRAZCA2UmRXnhiIftXQ7+Oh62Ji25W72jA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-arm"
      ],
      "os": ["linux"],
      "cpu": ["arm"]
    },
    "@img/sharp-linux-s390x@0.34.1": {
      "integrity": "sha512-7s0KX2tI9mZI2buRipKIw2X1ufdTeaRgwmRabt5bi9chYfhur+/C1OXg3TKg/eag1W+6CCWLVmSauV1owmRPxA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-s390x"
      ],
      "os": ["linux"],
      "cpu": ["s390x"]
    },
    "@img/sharp-linux-x64@0.34.1": {
      "integrity": "sha512-wExv7SH9nmoBW3Wr2gvQopX1k8q2g5V5Iag8Zk6AVENsjwd+3adjwxtp3Dcu2QhOXr8W9NusBU6XcQUohBZ5MA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-x64"
      ],
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-linuxmusl-arm64@0.34.1": {
      "integrity": "sha512-DfvyxzHxw4WGdPiTF0SOHnm11Xv4aQexvqhRDAoD00MzHekAj9a/jADXeXYCDFH/DzYruwHbXU7uz+H+nWmSOQ==",
      "optionalDependencies": [
        "@img/sharp-libvips-linuxmusl-arm64"
      ],
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-linuxmusl-x64@0.34.1": {
      "integrity": "sha512-pax/kTR407vNb9qaSIiWVnQplPcGU8LRIJpDT5o8PdAx5aAA7AS3X9PS8Isw1/WfqgQorPotjrZL3Pqh6C5EBg==",
      "optionalDependencies": [
        "@img/sharp-libvips-linuxmusl-x64"
      ],
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-wasm32@0.34.1": {
      "integrity": "sha512-YDybQnYrLQfEpzGOQe7OKcyLUCML4YOXl428gOOzBgN6Gw0rv8dpsJ7PqTHxBnXnwXr8S1mYFSLSa727tpz0xg==",
      "dependencies": [
        "@emnapi/runtime"
      ],
      "cpu": ["wasm32"]
    },
    "@img/sharp-win32-ia32@0.34.1": {
      "integrity": "sha512-WKf/NAZITnonBf3U1LfdjoMgNO5JYRSlhovhRhMxXVdvWYveM4kM3L8m35onYIdh75cOMCo1BexgVQcCDzyoWw==",
      "os": ["win32"],
      "cpu": ["ia32"]
    },
    "@img/sharp-win32-x64@0.34.1": {
      "integrity": "sha512-hw1iIAHpNE8q3uMIRCgGOeDoz9KtFNarFLQclLxr/LK1VBkj8nby18RjFvr6aP7USRYAjTZW6yisnBWMX571Tw==",
      "os": ["win32"],
      "cpu": ["x64"]
    },
    "@isaacs/fs-minipass@4.0.1": {
      "integrity": "sha512-wgm9Ehl2jpeqP3zw/7mo3kRHFp5MEDhqAdwy1fTGkHAwnkGOVsgpvQhL8B5n1qlb01jV3n/bI0ZfZp5lWA1k4w==",
      "dependencies": [
        "minipass"
      ]
    },
    "@next/env@15.3.2": {
      "integrity": "sha512-xURk++7P7qR9JG1jJtLzPzf0qEvqCN0A/T3DXf8IPMKo9/6FfjxtEffRJIIew/bIL4T3C2jLLqBor8B/zVlx6g=="
    },
    "@next/swc-darwin-arm64@15.3.2": {
      "integrity": "sha512-2DR6kY/OGcokbnCsjHpNeQblqCZ85/1j6njYSkzRdpLn5At7OkSdmk7WyAmB9G0k25+VgqVZ/u356OSoQZ3z0g==",
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@next/swc-darwin-x64@15.3.2": {
      "integrity": "sha512-ro/fdqaZWL6k1S/5CLv1I0DaZfDVJkWNaUU3un8Lg6m0YENWlDulmIWzV96Iou2wEYyEsZq51mwV8+XQXqMp3w==",
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@next/swc-linux-arm64-gnu@15.3.2": {
      "integrity": "sha512-covwwtZYhlbRWK2HlYX9835qXum4xYZ3E2Mra1mdQ+0ICGoMiw1+nVAn4d9Bo7R3JqSmK1grMq/va+0cdh7bJA==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@next/swc-linux-arm64-musl@15.3.2": {
      "integrity": "sha512-KQkMEillvlW5Qk5mtGA/3Yz0/tzpNlSw6/3/ttsV1lNtMuOHcGii3zVeXZyi4EJmmLDKYcTcByV2wVsOhDt/zg==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@next/swc-linux-x64-gnu@15.3.2": {
      "integrity": "sha512-uRBo6THWei0chz+Y5j37qzx+BtoDRFIkDzZjlpCItBRXyMPIg079eIkOCl3aqr2tkxL4HFyJ4GHDes7W8HuAUg==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@next/swc-linux-x64-musl@15.3.2": {
      "integrity": "sha512-+uxFlPuCNx/T9PdMClOqeE8USKzj8tVz37KflT3Kdbx/LOlZBRI2yxuIcmx1mPNK8DwSOMNCr4ureSet7eyC0w==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@next/swc-win32-arm64-msvc@15.3.2": {
      "integrity": "sha512-LLTKmaI5cfD8dVzh5Vt7+OMo+AIOClEdIU/TSKbXXT2iScUTSxOGoBhfuv+FU8R9MLmrkIL1e2fBMkEEjYAtPQ==",
      "os": ["win32"],
      "cpu": ["arm64"]
    },
    "@next/swc-win32-x64-msvc@15.3.2": {
      "integrity": "sha512-aW5B8wOPioJ4mBdMDXkt5f3j8pUr9W8AnlX0Df35uRWNT1Y6RIybxjnSUe+PhM+M1bwgyY8PHLmXZC6zT1o5tA==",
      "os": ["win32"],
      "cpu": ["x64"]
    },
    "@notionhq/client@3.0.1": {
      "integrity": "sha512-vHtFKrRKQg2PZSky1A9fTe+L9/WxNYRJWHmD6ZiBNgeN5jnFmv27ootRl9ROzEm/N+mOxfTo37EnuCHsaPgETg=="
    },
    "@slack/logger@4.0.0": {
      "integrity": "sha512-Wz7QYfPAlG/DR+DfABddUZeNgoeY7d1J39OCR2jR+v7VBsB8ezulDK5szTnDDPDwLH5IWhLvXIHlCFZV7MSKgA==",
      "dependencies": [
        "@types/node@22.15.18"
      ]
    },
    "@slack/types@2.14.0": {
      "integrity": "sha512-n0EGm7ENQRxlXbgKSrQZL69grzg1gHLAVd+GlRVQJ1NSORo0FrApR7wql/gaKdu2n4TO83Sq/AmeUOqD60aXUA=="
    },
    "@slack/web-api@7.9.1": {
      "integrity": "sha512-qMcb1oWw3Y/KlUIVJhkI8+NcQXq1lNymwf+ewk93ggZsGd6iuz9ObQsOEbvlqlx1J+wd8DmIm3DORGKs0fcKdg==",
      "dependencies": [
        "@slack/logger",
        "@slack/types",
        "@types/node@22.15.18",
        "@types/retry",
        "axios",
        "eventemitter3@5.0.1",
        "form-data",
        "is-electron",
        "is-stream",
        "p-queue",
        "p-retry",
        "retry"
      ]
    },
    "@supabase/auth-js@2.64.2": {
      "integrity": "sha512-s+lkHEdGiczDrzXJ1YWt2y3bxRi+qIUnXcgkpLSrId7yjBeaXBFygNjTaoZLG02KNcYwbuZ9qkEIqmj2hF7svw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/auth-js@2.69.1": {
      "integrity": "sha512-FILtt5WjCNzmReeRLq5wRs3iShwmnWgBvxHfqapC/VoljJl+W8hDAyFmf1NVw3zH+ZjZ05AKxiKxVeb0HNWRMQ==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/functions-js@2.3.1": {
      "integrity": "sha512-QyzNle/rVzlOi4BbVqxLSH828VdGY1RElqGFAj+XeVypj6+PVtMlD21G8SDnsPQDtlqqTtoGRgdMlQZih5hTuw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/functions-js@2.4.4": {
      "integrity": "sha512-WL2p6r4AXNGwop7iwvul2BvOtuJ1YQy8EbOd0dhG1oN1q8el/BIRSFCFnWAMM/vJJlHWLi4ad22sKbKr9mvjoA==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/node-fetch@2.6.15": {
      "integrity": "sha512-1ibVeYUacxWYi9i0cf5efil6adJ9WRyZBLivgjs+AUpewx1F3xPi7gLgaASI2SmIQxPoCEjAsLAzKPgMJVgOUQ==",
      "dependencies": [
        "whatwg-url"
      ]
    },
    "@supabase/postgrest-js@1.15.2": {
      "integrity": "sha512-9/7pUmXExvGuEK1yZhVYXPZnLEkDTwxgMQHXLrN5BwPZZm4iUCL1YEyep/Z2lIZah8d8M433mVAUEGsihUj5KQ==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/postgrest-js@1.19.4": {
      "integrity": "sha512-O4soKqKtZIW3olqmbXXbKugUtByD2jPa8kL2m2c1oozAO11uCcGrRhkZL0kVxjBLrXHE0mdSkFsMj7jDSfyNpw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/realtime-js@2.11.2": {
      "integrity": "sha512-u/XeuL2Y0QEhXSoIPZZwR6wMXgB+RQbJzG9VErA3VghVt7uRfSVsjeqd7m5GhX3JR6dM/WRmLbVR8URpDWG4+w==",
      "dependencies": [
        "@supabase/node-fetch",
        "@types/phoenix",
        "@types/ws",
        "ws"
      ]
    },
    "@supabase/realtime-js@2.9.5": {
      "integrity": "sha512-TEHlGwNGGmKPdeMtca1lFTYCedrhTAv3nZVoSjrKQ+wkMmaERuCe57zkC5KSWFzLYkb5FVHW8Hrr+PX1DDwplQ==",
      "dependencies": [
        "@supabase/node-fetch",
        "@types/phoenix",
        "@types/ws",
        "ws"
      ]
    },
    "@supabase/storage-js@2.5.5": {
      "integrity": "sha512-OpLoDRjFwClwc2cjTJZG8XviTiQH4Ik8sCiMK5v7et0MDu2QlXjCAW3ljxJB5+z/KazdMOTnySi+hysxWUPu3w==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/storage-js@2.7.1": {
      "integrity": "sha512-asYHcyDR1fKqrMpytAS1zjyEfvxuOIp1CIXX7ji4lHHcJKqyk+sLl/Vxgm4sN6u8zvuUtae9e4kDxQP2qrwWBA==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/supabase-js@2.43.4": {
      "integrity": "sha512-/pLPaxiIsn5Vaz3s32HC6O/VNwfeddnzS0bZRpOW0AKcPuXroD8pT9G8mpiBlZfpKsMmq6k7tlhW7Sr1PAQ1lw==",
      "dependencies": [
        "@supabase/auth-js@2.64.2",
        "@supabase/functions-js@2.3.1",
        "@supabase/node-fetch",
        "@supabase/postgrest-js@1.15.2",
        "@supabase/realtime-js@2.9.5",
        "@supabase/storage-js@2.5.5"
      ]
    },
    "@supabase/supabase-js@2.49.4": {
      "integrity": "sha512-jUF0uRUmS8BKt37t01qaZ88H9yV1mbGYnqLeuFWLcdV+x1P4fl0yP9DGtaEhFPZcwSom7u16GkLEH9QJZOqOkw==",
      "dependencies": [
        "@supabase/auth-js@2.69.1",
        "@supabase/functions-js@2.4.4",
        "@supabase/node-fetch",
        "@supabase/postgrest-js@1.19.4",
        "@supabase/realtime-js@2.11.2",
        "@supabase/storage-js@2.7.1"
      ]
    },
    "@swc/counter@0.1.3": {
      "integrity": "sha512-e2BR4lsJkkRlKZ/qCHPw9ZaSxc0MVUd7gtbtaB7aMvHeJVYe8sOB8DBZkP2DtISHGSku9sCK6T6cnY0CtXrOCQ=="
    },
    "@swc/helpers@0.5.15": {
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "dependencies": [
        "tslib"
      ]
    },
    "@types/node-fetch@2.6.12": {
      "integrity": "sha512-8nneRWKCg3rMtF69nLQJnOYUcbafYeFSjqkw3jCRLsqkWFlHaoQrr5mXmofFGOx3DKn7UfmBMyov8ySvLRVldA==",
      "dependencies": [
        "@types/node@22.15.15",
        "form-data"
      ]
    },
    "@types/node@18.19.100": {
      "integrity": "sha512-ojmMP8SZBKprc3qGrGk8Ujpo80AXkrP7G2tOT4VWr5jlr5DHjsJF+emXJz+Wm0glmy4Js62oKMdZZ6B9Y+tEcA==",
      "dependencies": [
        "undici-types@5.26.5"
      ]
    },
    "@types/node@22.15.15": {
      "integrity": "sha512-R5muMcZob3/Jjchn5LcO8jdKwSCbzqmPB6ruBxMcf9kbxtniZHP327s6C37iOfuw8mbKK3cAQa7sEl7afLrQ8A==",
      "dependencies": [
        "undici-types@6.21.0"
      ]
    },
    "@types/node@22.15.18": {
      "integrity": "sha512-v1DKRfUdyW+jJhZNEI1PYy29S2YRxMV5AOO/x/SjKmW0acCIOqmbj6Haf9eHAhsPmrhlHSxEhv/1WszcLWV4cg==",
      "dependencies": [
        "undici-types@6.21.0"
      ]
    },
    "@types/phoenix@1.6.6": {
      "integrity": "sha512-PIzZZlEppgrpoT2QgbnDU+MMzuR6BbCjllj0bM70lWoejMeNJAxCchxnv7J3XFkI8MpygtRpzXrIlmWUBclP5A=="
    },
    "@types/react@19.1.4": {
      "integrity": "sha512-EB1yiiYdvySuIITtD5lhW4yPyJ31RkJkkDw794LaQYrxCSaQV/47y5o1FMC4zF9ZyjUjzJMZwbovEnT5yHTW6g==",
      "dependencies": [
        "csstype"
      ]
    },
    "@types/retry@0.12.0": {
      "integrity": "sha512-wWKOClTTiizcZhXnPY4wikVAwmdYHp8q6DmC+EJUzAMsycb7HB32Kh9RN4+0gExjmPmZSAQjgURXIGATPegAvA=="
    },
    "@types/uuid@10.0.0": {
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ=="
    },
    "@types/ws@8.18.1": {
      "integrity": "sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==",
      "dependencies": [
        "@types/node@22.15.15"
      ]
    },
    "abort-controller@3.0.0": {
      "integrity": "sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==",
      "dependencies": [
        "event-target-shim"
      ]
    },
    "agent-base@7.1.3": {
      "integrity": "sha512-jRR5wdylq8CkOe6hei19GGZnxM6rBGwFl3Bg0YItGDimvjGtAvdZk4Pu6Cl4u4Igsws4a1fd1Vq3ezrhn4KmFw=="
    },
    "agentkeepalive@4.6.0": {
      "integrity": "sha512-kja8j7PjmncONqaTsB8fQ+wE2mSU2DJ9D4XKoJ5PFWIdRMa6SLSN1ff4mOr4jCbfRSsxR4keIiySJU0N9T5hIQ==",
      "dependencies": [
        "humanize-ms"
      ]
    },
    "asynckit@0.4.0": {
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "axios@1.9.0": {
      "integrity": "sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==",
      "dependencies": [
        "follow-redirects",
        "form-data",
        "proxy-from-env"
      ]
    },
    "bin-links@5.0.0": {
      "integrity": "sha512-sdleLVfCjBtgO5cNjA2HVRvWBJAHs4zwenaCPMNJAJU0yNxpzj80IpjOIimkpkr+mhlA+how5poQtt53PygbHA==",
      "dependencies": [
        "cmd-shim",
        "npm-normalize-package-bin",
        "proc-log",
        "read-cmd-shim",
        "write-file-atomic"
      ]
    },
    "busboy@1.6.0": {
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": [
        "streamsearch"
      ]
    },
    "call-bind-apply-helpers@1.0.2": {
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dependencies": [
        "es-errors",
        "function-bind"
      ]
    },
    "caniuse-lite@1.0.30001718": {
      "integrity": "sha512-AflseV1ahcSunK53NfEs9gFWgOEmzr0f+kaMFA4xiLZlr9Hzt7HxcSpIFcnNCUkz6R6dWKa54rUz3HUmI3nVcw=="
    },
    "chownr@3.0.0": {
      "integrity": "sha512-+IxzY9BZOQd/XuYPRmrvEVjF/nqj5kgT4kEq7VofrDoM1MxoRjEWkrCC3EtLi59TVawxTAn+orJwFQcrqEN1+g=="
    },
    "client-only@0.0.1": {
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA=="
    },
    "cmd-shim@7.0.0": {
      "integrity": "sha512-rtpaCbr164TPPh+zFdkWpCyZuKkjpAzODfaZCf/SVJZzJN+4bHQb/LP3Jzq5/+84um3XXY8r548XiWKSborwVw=="
    },
    "color-convert@2.0.1": {
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dependencies": [
        "color-name"
      ]
    },
    "color-name@1.1.4": {
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="
    },
    "color-string@1.9.1": {
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "dependencies": [
        "color-name",
        "simple-swizzle"
      ]
    },
    "color@4.2.3": {
      "integrity": "sha512-1rXeuUUiGGrykh+CeBdu5Ie7OJwinCgQY0bc7GCRxy5xVHy+moaqkpL/jqQq0MtQOeYcrqEz4abc5f0KtU7W4A==",
      "dependencies": [
        "color-convert",
        "color-string"
      ]
    },
    "combined-stream@1.0.8": {
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": [
        "delayed-stream"
      ]
    },
    "csstype@3.1.3": {
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw=="
    },
    "data-uri-to-buffer@4.0.1": {
      "integrity": "sha512-0R9ikRb668HB7QDxT1vkpuUBtqc53YyAwMwGeUFKRojY/NWKvdZ+9UYtRfGmhqNbRkTSVpMbmyhXipFFv2cb/A=="
    },
    "debug@4.4.1": {
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dependencies": [
        "ms"
      ]
    },
    "delayed-stream@1.0.0": {
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ=="
    },
    "detect-libc@2.0.4": {
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA=="
    },
    "dunder-proto@1.0.1": {
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dependencies": [
        "call-bind-apply-helpers",
        "es-errors",
        "gopd"
      ]
    },
    "es-define-property@1.0.1": {
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g=="
    },
    "es-errors@1.3.0": {
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw=="
    },
    "es-object-atoms@1.1.1": {
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dependencies": [
        "es-errors"
      ]
    },
    "es-set-tostringtag@2.1.0": {
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dependencies": [
        "es-errors",
        "get-intrinsic",
        "has-tostringtag",
        "hasown"
      ]
    },
    "event-target-shim@5.0.1": {
      "integrity": "sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ=="
    },
    "eventemitter3@4.0.7": {
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw=="
    },
    "eventemitter3@5.0.1": {
      "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA=="
    },
    "fetch-blob@3.2.0": {
      "integrity": "sha512-7yAQpD2UMJzLi1Dqv7qFYnPbaPx7ZfFK6PiIxQ4PfkGPyNyl2Ugx+a/umUonmKqjhM4DnfbMvdX6otXq83soQQ==",
      "dependencies": [
        "node-domexception",
        "web-streams-polyfill@3.3.3"
      ]
    },
    "follow-redirects@1.15.9": {
      "integrity": "sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ=="
    },
    "form-data-encoder@1.7.2": {
      "integrity": "sha512-qfqtYan3rxrnCk1VYaA4H+Ms9xdpPqvLZa6xmMgFvhO32x7/3J/ExcTd6qpxM0vH2GdMI+poehyBZvqfMTto8A=="
    },
    "form-data@4.0.2": {
      "integrity": "sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==",
      "dependencies": [
        "asynckit",
        "combined-stream",
        "es-set-tostringtag",
        "mime-types"
      ]
    },
    "formdata-node@4.4.1": {
      "integrity": "sha512-0iirZp3uVDjVGt9p49aTaqjk84TrglENEDuqfdlZQ1roC9CWlPk6Avf8EEnZNcAqPonwkG35x4n3ww/1THYAeQ==",
      "dependencies": [
        "node-domexception",
        "web-streams-polyfill@4.0.0-beta.3"
      ]
    },
    "formdata-node@6.0.3": {
      "integrity": "sha512-8e1++BCiTzUno9v5IZ2J6bv4RU+3UKDmqWUQD0MIMVCd9AdhWkO1gw57oo1mNEX1dMq2EGI+FbWz4B92pscSQg=="
    },
    "formdata-polyfill@4.0.10": {
      "integrity": "sha512-buewHzMvYL29jdeQTVILecSaZKnt/RJWjoZCF5OW60Z67/GmSLBkOFM7qh1PI3zFNtJbaZL5eQu1vLfazOwj4g==",
      "dependencies": [
        "fetch-blob"
      ]
    },
    "function-bind@1.1.2": {
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA=="
    },
    "get-intrinsic@1.3.0": {
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dependencies": [
        "call-bind-apply-helpers",
        "es-define-property",
        "es-errors",
        "es-object-atoms",
        "function-bind",
        "get-proto",
        "gopd",
        "has-symbols",
        "hasown",
        "math-intrinsics"
      ]
    },
    "get-proto@1.0.1": {
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dependencies": [
        "dunder-proto",
        "es-object-atoms"
      ]
    },
    "gopd@1.2.0": {
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg=="
    },
    "has-symbols@1.1.0": {
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ=="
    },
    "has-tostringtag@1.0.2": {
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dependencies": [
        "has-symbols"
      ]
    },
    "hasown@2.0.2": {
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": [
        "function-bind"
      ]
    },
    "https-proxy-agent@7.0.6": {
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dependencies": [
        "agent-base",
        "debug"
      ]
    },
    "humanize-ms@1.2.1": {
      "integrity": "sha512-Fl70vYtsAFb/C06PTS9dZBo7ihau+Tu/DNCk/OyHhea07S+aeMWpFFkUaXRa8fI+ScZbEI8dfSxwY7gxZ9SAVQ==",
      "dependencies": [
        "ms"
      ]
    },
    "imurmurhash@0.1.4": {
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA=="
    },
    "is-arrayish@0.3.2": {
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ=="
    },
    "is-electron@2.2.2": {
      "integrity": "sha512-FO/Rhvz5tuw4MCWkpMzHFKWD2LsfHzIb7i6MdPYZ/KW7AlxawyLkqdy+jPZP1WubqEADE3O4FUENlJHDfQASRg=="
    },
    "is-stream@2.0.1": {
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg=="
    },
    "math-intrinsics@1.1.0": {
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g=="
    },
    "mime-db@1.52.0": {
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="
    },
    "mime-types@2.1.35": {
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": [
        "mime-db"
      ]
    },
    "minipass@7.1.2": {
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw=="
    },
    "minizlib@3.0.2": {
      "integrity": "sha512-oG62iEk+CYt5Xj2YqI5Xi9xWUeZhDI8jjQmC5oThVH5JGCTgIjr7ciJDzC7MBzYd//WvR1OTmP5Q38Q8ShQtVA==",
      "dependencies": [
        "minipass"
      ]
    },
    "mkdirp@3.0.1": {
      "integrity": "sha512-+NsyUUAZDmo6YVHzL/stxSu3t9YS1iljliy3BSDrXJ/dkn1KYdmtZODGGjLcc9XLgVVpH4KshHB8XmZgMhaBXg==",
      "bin": true
    },
    "ms@2.1.3": {
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "nanoid@3.3.11": {
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "bin": true
    },
    "next@15.3.2_react@19.1.0_react-dom@19.1.0__react@19.1.0": {
      "integrity": "sha512-CA3BatMyHkxZ48sgOCLdVHjFU36N7TF1HhqAHLFOkV6buwZnvMI84Cug8xD56B9mCuKrqXnLn94417GrZ/jjCQ==",
      "dependencies": [
        "@next/env",
        "@swc/counter",
        "@swc/helpers",
        "busboy",
        "caniuse-lite",
        "postcss",
        "react",
        "react-dom",
        "styled-jsx"
      ],
      "optionalDependencies": [
        "@next/swc-darwin-arm64",
        "@next/swc-darwin-x64",
        "@next/swc-linux-arm64-gnu",
        "@next/swc-linux-arm64-musl",
        "@next/swc-linux-x64-gnu",
        "@next/swc-linux-x64-musl",
        "@next/swc-win32-arm64-msvc",
        "@next/swc-win32-x64-msvc",
        "sharp"
      ],
      "bin": true
    },
    "node-domexception@1.0.0": {
      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
      "deprecated": true
    },
    "node-fetch@2.7.0": {
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "dependencies": [
        "whatwg-url"
      ]
    },
    "node-fetch@3.3.2": {
      "integrity": "sha512-dRB78srN/l6gqWulah9SrxeYnxeddIG30+GOqK/9OlLVyLg3HPnr6SqOWTWOXKRwC2eGYCkZ59NNuSgvSrpgOA==",
      "dependencies": [
        "data-uri-to-buffer",
        "fetch-blob",
        "formdata-polyfill"
      ]
    },
    "npm-normalize-package-bin@4.0.0": {
      "integrity": "sha512-TZKxPvItzai9kN9H/TkmCtx/ZN/hvr3vUycjlfmH0ootY9yFBzNOpiXAdIn1Iteqsvk4lQn6B5PTrt+n6h8k/w=="
    },
    "openai@4.100.0": {
      "integrity": "sha512-9soq/wukv3utxcuD7TWFqKdKp0INWdeyhUCvxwrne5KwnxaCp4eHL4GdT/tMFhYolxgNhxFzg5GFwM331Z5CZg==",
      "dependencies": [
        "@types/node@18.19.100",
        "@types/node-fetch",
        "abort-controller",
        "agentkeepalive",
        "form-data-encoder",
        "formdata-node@4.4.1",
        "node-fetch@2.7.0"
      ],
      "bin": true
    },
    "p-finally@1.0.0": {
      "integrity": "sha512-LICb2p9CB7FS+0eR1oqWnHhp0FljGLZCWBE9aix0Uye9W8LTQPwMTYVGWQWIw9RdQiDg4+epXQODwIYJtSJaow=="
    },
    "p-queue@6.6.2": {
      "integrity": "sha512-RwFpb72c/BhQLEXIZ5K2e+AhgNVmIejGlTgiB9MzZ0e93GRvqZ7uSi0dvRF7/XIXDeNkra2fNHBxTyPDGySpjQ==",
      "dependencies": [
        "eventemitter3@4.0.7",
        "p-timeout"
      ]
    },
    "p-retry@4.6.2": {
      "integrity": "sha512-312Id396EbJdvRONlngUx0NydfrIQ5lsYu0znKVUzVvArzEIt08V1qhtyESbGVd1FGX7UKtiFp5uwKZdM8wIuQ==",
      "dependencies": [
        "@types/retry",
        "retry"
      ]
    },
    "p-timeout@3.2.0": {
      "integrity": "sha512-rhIwUycgwwKcP9yTOOFK/AKsAopjjCakVqLHePO3CC6Mir1Z99xT+R63jZxAT5lFZLa2inS5h+ZS2GvR99/FBg==",
      "dependencies": [
        "p-finally"
      ]
    },
    "picocolors@1.1.1": {
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="
    },
    "postcss@8.4.31": {
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "dependencies": [
        "nanoid",
        "picocolors",
        "source-map-js"
      ]
    },
    "proc-log@5.0.0": {
      "integrity": "sha512-Azwzvl90HaF0aCz1JrDdXQykFakSSNPaPoiZ9fm5qJIMHioDZEi7OAdRwSm6rSoPtY3Qutnm3L7ogmg3dc+wbQ=="
    },
    "proxy-from-env@1.1.0": {
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="
    },
    "react-dom@19.1.0_react@19.1.0": {
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "dependencies": [
        "react",
        "scheduler"
      ]
    },
    "react@19.1.0": {
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg=="
    },
    "read-cmd-shim@5.0.0": {
      "integrity": "sha512-SEbJV7tohp3DAAILbEMPXavBjAnMN0tVnh4+9G8ihV4Pq3HYF9h8QNez9zkJ1ILkv9G2BjdzwctznGZXgu/HGw=="
    },
    "retry@0.13.1": {
      "integrity": "sha512-XQBQ3I8W1Cge0Seh+6gjj03LbmRFWuoszgK9ooCpwYIrhhoO80pfq4cUkU5DkknwfOfFteRwlZ56PYOGYyFWdg=="
    },
    "scheduler@0.26.0": {
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA=="
    },
    "semver@7.7.2": {
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "bin": true
    },
    "sharp@0.34.1": {
      "integrity": "sha512-1j0w61+eVxu7DawFJtnfYcvSv6qPFvfTaqzTQ2BLknVhHTwGS8sc63ZBF4rzkWMBVKybo4S5OBtDdZahh2A1xg==",
      "dependencies": [
        "color",
        "detect-libc",
        "semver"
      ],
      "optionalDependencies": [
        "@img/sharp-darwin-arm64",
        "@img/sharp-darwin-x64",
        "@img/sharp-libvips-darwin-arm64",
        "@img/sharp-libvips-darwin-x64",
        "@img/sharp-libvips-linux-arm",
        "@img/sharp-libvips-linux-arm64",
        "@img/sharp-libvips-linux-ppc64",
        "@img/sharp-libvips-linux-s390x",
        "@img/sharp-libvips-linux-x64",
        "@img/sharp-libvips-linuxmusl-arm64",
        "@img/sharp-libvips-linuxmusl-x64",
        "@img/sharp-linux-arm",
        "@img/sharp-linux-arm64",
        "@img/sharp-linux-s390x",
        "@img/sharp-linux-x64",
        "@img/sharp-linuxmusl-arm64",
        "@img/sharp-linuxmusl-x64",
        "@img/sharp-wasm32",
        "@img/sharp-win32-ia32",
        "@img/sharp-win32-x64"
      ],
      "scripts": true
    },
    "signal-exit@4.1.0": {
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw=="
    },
    "simple-swizzle@0.2.2": {
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "dependencies": [
        "is-arrayish"
      ]
    },
    "source-map-js@1.2.1": {
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA=="
    },
    "streamsearch@1.1.0": {
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg=="
    },
    "styled-jsx@5.1.6_react@19.1.0": {
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "dependencies": [
        "client-only",
        "react"
      ]
    },
    "supabase@2.22.12": {
      "integrity": "sha512-PWQT+uzwAXcamM/FK60CaWRjVwsX2SGW5vF7edbiTQC6vsNvTBnSIvd1yiXsIpq32uzQFu+iOrayxaTQytNiTw==",
      "dependencies": [
        "bin-links",
        "https-proxy-agent",
        "node-fetch@3.3.2",
        "tar"
      ],
      "scripts": true,
      "bin": true
    },
    "tar@7.4.3": {
      "integrity": "sha512-5S7Va8hKfV7W5U6g3aYxXmlPoZVAwUMy9AOKyF2fVuZa2UD3qZjg578OrLRt8PcNN1PleVaL/5/yYATNL0ICUw==",
      "dependencies": [
        "@isaacs/fs-minipass",
        "chownr",
        "minipass",
        "minizlib",
        "mkdirp",
        "yallist"
      ]
    },
    "tr46@0.0.3": {
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "tslib@2.8.1": {
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w=="
    },
    "typescript@5.8.3": {
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "bin": true
    },
    "undici-types@5.26.5": {
      "integrity": "sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA=="
    },
    "undici-types@6.21.0": {
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ=="
    },
    "uuid@11.1.0": {
      "integrity": "sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==",
      "bin": true
    },
    "web-streams-polyfill@3.3.3": {
      "integrity": "sha512-d2JWLCivmZYTSIoge9MsgFCZrt571BikcWGYkjC1khllbTeDlGqZ2D8vD8E/lJa8WGWbb7Plm8/XJYV7IJHZZw=="
    },
    "web-streams-polyfill@4.0.0-beta.3": {
      "integrity": "sha512-QW95TCTaHmsYfHDybGMwO5IJIM93I/6vTRk+daHTWFPhwh+C8Cg7j7XyKrwrj8Ib6vYXe0ocYNrmzY4xAAN6ug=="
    },
    "webidl-conversions@3.0.1": {
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url@5.0.0": {
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": [
        "tr46",
        "webidl-conversions"
      ]
    },
    "write-file-atomic@6.0.0": {
      "integrity": "sha512-GmqrO8WJ1NuzJ2DrziEI2o57jKAVIQNf8a18W3nCYU3H7PNWqCCVTeH6/NQE93CIllIgQS98rrmVkYgTX9fFJQ==",
      "dependencies": [
        "imurmurhash",
        "signal-exit"
      ]
    },
    "ws@8.18.2": {
      "integrity": "sha512-DMricUmwGZUVr++AEAe2uiVM7UoO9MAVZMDu05UQOaUII0lp+zOzLLU4Xqh/JvTqklB1T4uELaaPBKyjE1r4fQ=="
    },
    "yallist@5.0.0": {
      "integrity": "sha512-YgvUTfwqyc7UXVMrB+SImsVYSmTS8X/tSrtdNZMImM+n7+QTriRXyXim0mBrTXNeqzVF0KWGgHPeiyViFFrNDw=="
    }
  },
  "redirects": {
    "https://esm.sh/@supabase/node-fetch@^2.6.14?target=denonext": "https://esm.sh/@supabase/node-fetch@2.6.15?target=denonext",
    "https://esm.sh/@supabase/supabase-js@2": "https://esm.sh/@supabase/supabase-js@2.49.4",
    "https://esm.sh/@types/ws@~8.18.1/index.d.mts": "https://esm.sh/@types/ws@8.18.1/index.d.mts",
    "https://esm.sh/bufferutil@^4.0.1?target=denonext": "https://esm.sh/bufferutil@4.0.9?target=denonext",
    "https://esm.sh/node-gyp-build@^4.3.0?target=denonext": "https://esm.sh/node-gyp-build@4.8.4?target=denonext",
    "https://esm.sh/tr46@~0.0.3?target=denonext": "https://esm.sh/tr46@0.0.3?target=denonext",
    "https://esm.sh/utf-8-validate@%3E=5.0.2?target=denonext": "https://esm.sh/utf-8-validate@6.0.5?target=denonext",
    "https://esm.sh/webidl-conversions@^3.0.0?target=denonext": "https://esm.sh/webidl-conversions@3.0.1?target=denonext",
    "https://esm.sh/whatwg-url@^5.0.0?target=denonext": "https://esm.sh/whatwg-url@5.0.0?target=denonext",
    "https://esm.sh/ws@^8.18.0?target=denonext": "https://esm.sh/ws@8.18.2?target=denonext"
  },
  "remote": {
    "https://deno.land/std@0.177.0/async/abortable.ts": "73acfb3ed7261ce0d930dbe89e43db8d34e017b063cf0eaa7d215477bf53442e",
    "https://deno.land/std@0.177.0/async/deadline.ts": "c5facb0b404eede83e38bd2717ea8ab34faa2ffb20ef87fd261fcba32ba307aa",
    "https://deno.land/std@0.177.0/async/debounce.ts": "adab11d04ca38d699444ac8a9d9856b4155e8dda2afd07ce78276c01ea5a4332",
    "https://deno.land/std@0.177.0/async/deferred.ts": "42790112f36a75a57db4a96d33974a936deb7b04d25c6084a9fa8a49f135def8",
    "https://deno.land/std@0.177.0/async/delay.ts": "73aa04cec034c84fc748c7be49bb15cac3dd43a57174bfdb7a4aec22c248f0dd",
    "https://deno.land/std@0.177.0/async/mod.ts": "f04344fa21738e5ad6bea37a6bfffd57c617c2d372bb9f9dcfd118a1b622e576",
    "https://deno.land/std@0.177.0/async/mux_async_iterator.ts": "70c7f2ee4e9466161350473ad61cac0b9f115cff4c552eaa7ef9d50c4cbb4cc9",
    "https://deno.land/std@0.177.0/async/pool.ts": "fd082bd4aaf26445909889435a5c74334c017847842ec035739b4ae637ae8260",
    "https://deno.land/std@0.177.0/async/retry.ts": "5efa3ba450ac0c07a40a82e2df296287b5013755d232049efd7ea2244f15b20f",
    "https://deno.land/std@0.177.0/async/tee.ts": "47e42d35f622650b02234d43803d0383a89eb4387e1b83b5a40106d18ae36757",
    "https://deno.land/std@0.177.0/http/server.ts": "cbb17b594651215ba95c01a395700684e569c165a567e4e04bba327f41197433",
    "https://deno.land/std@0.224.0/async/delay.ts": "f90dd685b97c2f142b8069082993e437b1602b8e2561134827eeb7c12b95c499",
    "https://deno.land/std@0.224.0/dotenv/load.ts": "587b342f0f6a3df071331fe6ba1c823729ab68f7d53805809475e486dd4161d7",
    "https://deno.land/std@0.224.0/dotenv/mod.ts": "0180eaeedaaf88647318811cdaa418cc64dc51fb08354f91f5f480d0a1309f7d",
    "https://deno.land/std@0.224.0/dotenv/parse.ts": "09977ff88dfd1f24f9973a338f0f91bbdb9307eb5ff6085446e7c423e4c7ba0c",
    "https://deno.land/std@0.224.0/dotenv/stringify.ts": "275da322c409170160440836342eaa7cf012a1d11a7e700d8ca4e7f2f8aa4615",
    "https://deno.land/std@0.224.0/http/server.ts": "f9313804bf6467a1704f45f76cb6cd0a3396a3b31c316035e6a4c2035d1ea514",
    "https://esm.sh/@supabase/auth-js@2.69.1/denonext/auth-js.mjs": "fb31c3925437753f5a8a90fc57ea24dc5b68b2b295e696123b1b6a635b7b3ada",
    "https://esm.sh/@supabase/functions-js@2.4.4/denonext/functions-js.mjs": "7adeb257410ef3c4a8a1eb9b4ff416c0075d1c32860ca04913c8a9dace1de6a6",
    "https://esm.sh/@supabase/node-fetch@2.6.15/denonext/node-fetch.mjs": "0bae9052231f4f6dbccc7234d05ea96923dbf967be12f402764580b6bf9f713d",
    "https://esm.sh/@supabase/node-fetch@2.6.15?target=denonext": "4d28c4ad97328403184353f68434f2b6973971507919e9150297413664919cf3",
    "https://esm.sh/@supabase/postgrest-js@1.19.4/denonext/postgrest-js.mjs": "2073b5552ba10c7a8302bffffae771e3aede1daf833382355dae239fb0ab2576",
    "https://esm.sh/@supabase/realtime-js@2.11.2/denonext/realtime-js.mjs": "c33ac375b6be89c893f9df844d2525a4ace015a35aa6ba236270d00c6605c7ba",
    "https://esm.sh/@supabase/storage-js@2.7.1/denonext/storage-js.mjs": "73ac8cdc95cfcd794fe603dbd7ce06d539ab51538ae6467eabe0f9cc26c993aa",
    "https://esm.sh/@supabase/supabase-js@2.49.4": "d52c4d06946766d328fdd0ac2e007f52bb6d2ef7ce6103ad9f0f57d92b73e978",
    "https://esm.sh/@supabase/supabase-js@2.49.4/denonext/supabase-js.mjs": "8c664dda021a5abc7c0b1f49d89d5886a7f9c63c9d365eb3764e1e27440bd781",
    "https://esm.sh/bufferutil@4.0.9/denonext/bufferutil.mjs": "13dca4d5bb2c68cbe119f880fa3bd785b9a81a8e02e0834dae604b4b85295cd8",
    "https://esm.sh/bufferutil@4.0.9?target=denonext": "e32574569ab438facfcc3f412c659b0719bbf05477136ca176938c9a3ac45125",
    "https://esm.sh/node-gyp-build@4.8.4/denonext/node-gyp-build.mjs": "9a86f2d044fc77bd60aaa3d697c2ba1b818da5fb1b9aaeedec59a40b8e908803",
    "https://esm.sh/node-gyp-build@4.8.4?target=denonext": "261a6cedf1fdbf159798141ba1e2311ac1510682c5c8b55dacc8cf5fdee4aa06",
    "https://esm.sh/tr46@0.0.3/denonext/tr46.mjs": "5753ec0a99414f4055f0c1f97691100f13d88e48a8443b00aebb90a512785fa2",
    "https://esm.sh/tr46@0.0.3?target=denonext": "19cb9be0f0d418a0c3abb81f2df31f080e9540a04e43b0f699bce1149cba0cbb",
    "https://esm.sh/utf-8-validate@6.0.5/denonext/utf-8-validate.mjs": "66b8ea532a0c745068f5b96ddb1bae332c3036703243541d2e89e66331974d98",
    "https://esm.sh/utf-8-validate@6.0.5?target=denonext": "071bc33ba1a58297e23a34d69dd589fd06df04b0f373b382ff5da544a623f271",
    "https://esm.sh/webidl-conversions@3.0.1/denonext/webidl-conversions.mjs": "54b5c2d50a294853c4ccebf9d5ed8988c94f4e24e463d84ec859a866ea5fafec",
    "https://esm.sh/webidl-conversions@3.0.1?target=denonext": "4e20318d50528084616c79d7b3f6e7f0fe7b6d09013bd01b3974d7448d767e29",
    "https://esm.sh/whatwg-url@5.0.0/denonext/whatwg-url.mjs": "29b16d74ee72624c915745bbd25b617cfd2248c6af0f5120d131e232a9a9af79",
    "https://esm.sh/whatwg-url@5.0.0?target=denonext": "f001a2cadf81312d214ca330033f474e74d81a003e21e8c5d70a1f46dc97b02d",
    "https://esm.sh/ws@8.18.2/denonext/ws.mjs": "b9211ecb1511b09f418c1330920c66800b66710b2cd2997b64b7e0525bd895d2",
    "https://esm.sh/ws@8.18.2?target=denonext": "2ee7b1bb11543dda3e7e1c685ad8599b6f18aea785302374c3def5da468a1e51"
  },
  "workspace": {
    "packageJson": {
      "dependencies": [
        "npm:@google/generative-ai@~0.24.1",
        "npm:@notionhq/client@^3.0.1",
        "npm:@slack/web-api@^7.9.1",
        "npm:@supabase/supabase-js@^2.49.4",
        "npm:@types/uuid@10",
        "npm:formdata-node@^6.0.3",
        "npm:openai@^4.100.0",
        "npm:uuid@^11.1.0"
      ]
    },
    "members": {
      "apps/aimtg": {
        "packageJson": {
          "dependencies": [
            "npm:@google/generative-ai@~0.24.1",
            "npm:@notionhq/client@^3.0.1",
            "npm:@slack/web-api@^7.9.1",
            "npm:@supabase/supabase-js@^2.49.4",
            "npm:@types/node@^22.15.18",
            "npm:@types/react@^19.1.4",
            "npm:@types/uuid@10",
            "npm:formdata-node@^6.0.3",
            "npm:next@^15.3.2",
            "npm:openai@^4.100.0",
            "npm:typescript@^5.8.3",
            "npm:uuid@^11.1.0"
          ]
        }
      }
    }
  }
}

================
File: supabase/config.toml
================
[functions.process-video-task]
enabled = true
verify_jwt = false
entrypoint = "./functions/process-video-task/index.ts"

[functions.transcribe_with_whisper]
enabled = true
verify_jwt = false
entrypoint = "./functions/transcribe_with_whisper/index.ts"

[functions.upload_file_to_storage]
enabled = true
verify_jwt = false
entrypoint = "./functions/upload_file_to_storage/index.ts"

[functions.summarize_dispatch]
enabled = true
verify_jwt = false
entrypoint = "./functions/summarize_dispatch/index.ts"

================
File: supabase/migrations/20231105_create_upload_logs.sql
================
-- supabase/migrations/20231105_create_upload_logs.sql

-- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®é€²æ—ã¨çŠ¶æ…‹ã‚’è¿½è·¡ã™ã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS public.upload_logs (
  id TEXT PRIMARY KEY, -- ä¸€æ„ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ID
  task_id UUID REFERENCES public.transcription_tasks(id), -- é–¢é€£ã™ã‚‹ã‚¿ã‚¹ã‚¯IDï¼ˆå¾Œã‹ã‚‰è¨­å®šã•ã‚Œã‚‹å¯èƒ½æ€§ã‚ã‚Šï¼‰
  file_name TEXT NOT NULL, -- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å
  storage_path TEXT, -- Supabase Storageå†…ã®ãƒ‘ã‚¹
  status TEXT NOT NULL, -- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ (preparing/uploading/uploaded/processing/completed/failed)
  content_type TEXT NOT NULL, -- ãƒ•ã‚¡ã‚¤ãƒ«ã®Content-Type
  file_size BIGINT, -- ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰
  progress INTEGER, -- ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é€²æ—ï¼ˆãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆï¼‰
  error_message TEXT, -- ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  metadata JSONB, -- è¿½åŠ æƒ…å ±ï¼ˆä»»æ„ï¼‰
  slack_file_id TEXT, -- Slack File ID
  slack_download_url TEXT, -- Slack ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰URL
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(), -- ä½œæˆæ—¥æ™‚
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now() -- æ›´æ–°æ—¥æ™‚
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX IF NOT EXISTS idx_upload_logs_status ON public.upload_logs(status);
CREATE INDEX IF NOT EXISTS idx_upload_logs_created_at ON public.upload_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_upload_logs_task_id ON public.upload_logs(task_id);

-- Row Level Security
ALTER TABLE public.upload_logs ENABLE ROW LEVEL SECURITY;

-- èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿èª­ã¿å–ã‚Šå¯èƒ½
CREATE POLICY "Authenticated users can read upload logs" 
  ON public.upload_logs FOR SELECT 
  USING (auth.role() = 'authenticated');

-- èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ¿å…¥å¯èƒ½
CREATE POLICY "Authenticated users can insert upload logs" 
  ON public.upload_logs FOR INSERT 
  WITH CHECK (auth.role() = 'authenticated');

-- èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè‡ªåˆ†ã®ä½œæˆã—ãŸãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°å¯èƒ½
CREATE POLICY "Authenticated users can update own upload logs" 
  ON public.upload_logs FOR UPDATE
  USING (auth.role() = 'authenticated');

-- æ›´æ–°æ—¥æ™‚è‡ªå‹•æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_upload_logs_updated_at
BEFORE UPDATE ON public.upload_logs
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ãƒ¼ãƒ«ã¯ã™ã¹ã¦ã®æ“ä½œãŒå¯èƒ½
CREATE POLICY "Service role can perform all operations" 
  ON public.upload_logs FOR ALL 
  USING (auth.role() = 'service_role')
  WITH CHECK (auth.role() = 'service_role');

COMMENT ON TABLE public.upload_logs IS 'å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é€²æ—ã¨çŠ¶æ…‹ã‚’è¿½è·¡ã™ã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«';

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "noEmit": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "supabase/functions/**/*"
  ]
}

================
File: app/api/notion-sync/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { Client as NotionClient } from '@notionhq/client';
import type { CreatePageParameters, BlockObjectRequest } from '@notionhq/client/build/src/api-endpoints';
import { createClient, SupabaseClient } from '@supabase/supabase-js';

// ç’°å¢ƒå¤‰æ•°
const NOTION_API_KEY = process.env.NOTION_API_KEY;
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

// åˆæœŸåŒ–
const notion = NOTION_API_KEY ? new NotionClient({ auth: NOTION_API_KEY }) : null;
const supabase: SupabaseClient | null = (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY)
  ? createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, { auth: { persistSession: false } })
  : null;

interface NotionSyncPayload { taskId: string; }

interface TranscriptionTask {
  id: string;
  consultant_name?: string;
  company_name?: string;
  company_type?: string;
  company_problem?: string;
  meeting_date?: string;
  meeting_count?: number;
  meeting_type?: string; // lintã§æœªä½¿ç”¨æŒ‡æ‘˜ãŒã‚ã£ãŸãŒã€ã‚‚ã—ä½¿ã†ãªã‚‰ã“ã®å‹å®šç¾©ã¯æ®‹ã™
  support_area?: string;
  company_phase?: string;
  internal_sharing_items?: string;
  final_summary: string;
  status: string;
  error_message?: string;
  notion_page_id?: string;
  created_at?: string;
  updated_at?: string;
}

interface NotionDbMap {
  id: string;
  kind: 'all' | 'consultant' | 'company';
  name: string;
  page_id: string;
  db_id: string;
  updated_at: string;
}

export async function POST(req: NextRequest) {
  // èªå¯
  if (!WEBHOOK_SECRET) return NextResponse.json({ error: 'Server misconfig' }, { status: 500 });
  const auth = req.headers.get('Authorization');
  if (!auth || !auth.startsWith('Bearer ') || auth.substring(7) !== WEBHOOK_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  if (!supabase || !notion) {
    return NextResponse.json({ error: 'Server not configured (supabase or notion)' }, { status: 500 });
  }

  let payload: NotionSyncPayload;
  try { payload = await req.json(); }
  catch { return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 }); }
  const { taskId } = payload;
  if (!taskId) return NextResponse.json({ error: 'taskId required' }, { status: 400 });

  // 1. transcription_tasks å–å¾—
  const { data: taskData, error: tErr } = await supabase
    .from('transcription_tasks')
    .select('*')
    .eq('id', taskId)
    .single();

  const task = taskData as TranscriptionTask | null;

  if (tErr || !task) {
    return NextResponse.json({ error: 'Task not found' }, { status: 404 });
  }

  const {
    consultant_name = 'ãªã—',
    company_name = 'ãªã—',
    company_type = 'ã‚¨ãƒ©ãƒ¼',
    company_problem = 'ãªã—',
    meeting_date = 'ãªã—',
    meeting_count,
    meeting_type: _meeting_type = 'ã‚¨ãƒ©ãƒ¼',
    support_area = 'ã‚¨ãƒ©ãƒ¼',
    company_phase = 'ãªã—',
    internal_sharing_items = 'ãªã—',
    final_summary,
  } = task;

  if (!final_summary) {
    return NextResponse.json({ error: 'final_summary missing' }, { status: 400 });
  }

  // 2. map å–å¾—
  const { data: mapsRaw, error: mErr } = await supabase
    .from('notion_db_map')
    .select('*')
    .in('kind', ['all', 'consultant', 'company'])
    .in('name', [consultant_name, company_name, 'all']);

  if (mErr) {
    return NextResponse.json({ error: mErr.message }, { status: 500 });
  }

  const maps = (mapsRaw ?? []) as NotionDbMap[];

  const getDb = (
    mapsArr: NotionDbMap[],
    kind: 'all' | 'consultant' | 'company',
    nameVal: string,
  ): NotionDbMap | undefined => mapsArr.find((m) => m.kind === kind && m.name === nameVal);

  const allMap = getDb(maps, 'all', 'all');
  const consMap = getDb(maps, 'consultant', consultant_name);
  const compMap = getDb(maps, 'company', company_name);

  if (!allMap || !consMap || !compMap) {
    await supabase.from('transcription_tasks').update({ status: 'notion_failed', error_message: 'Mapping not found' }).eq('id', taskId);
    return NextResponse.json({ error: 'Mapping not found for some target DB' }, { status: 400 });
  }

  // ã“ã®æ™‚ç‚¹ã§ allMap, consMap, compMap ã¯ NotionDbMap å‹ã§ã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã‚‹
  const targets: NotionDbMap[] = [allMap, consMap, compMap];

  const buildProperties = () => ({
    'é¢è«‡æ—¥': { title: [{ text: { content: `${meeting_date}` } }] },
    'ä¼æ¥­å': { rich_text: [{ text: { content: company_name || 'ãªã—' } }] },
    'ã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆå': { rich_text: [{ text: { content: consultant_name || 'ãªã—' } }] },
    'ä¼æ¥­ã‚¿ã‚¤ãƒ—': { status: { name: company_type || 'ã‚¨ãƒ©ãƒ¼' } },
    'ä¼æ¥­ã®èª²é¡Œ': { rich_text: [{ text: { content: company_problem || 'ãªã—' } }] },
    'é¢è«‡å›æ•°': { number: meeting_count ?? null },
    'æ”¯æ´é ˜åŸŸ': { status: { name: support_area || 'ã‚¨ãƒ©ãƒ¼' } },
    'ä¼æ¥­ã®ãƒ•ã‚§ãƒ¼ã‚º': { rich_text: [{ text: { content: company_phase || 'ãªã—' } }] },
    'ç¤¾å†…å…±æœ‰ãŒå¿…è¦ãªäº‹é …': { rich_text: [{ text: { content: internal_sharing_items || 'ãªã—' } }] },
  });

  const children: BlockObjectRequest[] = [
    {
      type: 'paragraph',
      paragraph: {
        rich_text: [{ type: 'text', text: { content: final_summary } }],
      },
    },
  ];

  const createPage = async (dbId: string) => {
    const properties = buildProperties() as CreatePageParameters['properties'];
    return await notion.pages.create({ parent: { database_id: dbId }, properties, children });
  };

  try {
    const results = await Promise.all(targets.map(t => createPage(t.db_id)));
    await supabase.from('transcription_tasks').update({ notion_page_id: JSON.stringify({ all: results[0].id, consultant: results[1].id, company: results[2].id }) }).eq('id', taskId);
    return NextResponse.json({ message: 'Notion pages created', ids: results.map(r => r.id) });
  } catch (e) {
    await supabase.from('transcription_tasks').update({ status: 'notion_failed', error_message: (e as Error).message }).eq('id', taskId);
    return NextResponse.json({ error: 'Failed to create notion pages', details: (e as Error).message }, { status: 500 });
  }
}

================
File: app/api/upload-url/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// å†…éƒ¨APIå‘¼ã³å‡ºã—èªè¨¼ç”¨ã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚­ãƒ¼ (ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—)
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

const STORAGE_BUCKET_NAME = 'videos'; // Supabase Storageã®ãƒã‚±ãƒƒãƒˆå
const SIGNED_URL_TTL = 60 * 30; // ç½²åä»˜ãURLã®æœ‰åŠ¹æœŸé–“ï¼ˆç§’ï¼‰ï¼š30åˆ†

export async function POST(request: NextRequest) {
  console.log(`[${new Date().toISOString()}] /api/upload-url: POST request received.`);

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    console.error(`[${new Date().toISOString()}] /api/upload-url: Missing Supabase URL or anon key environment variables.`);
    return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
  }

  const supabase = createClient(supabaseUrl, supabaseAnonKey);

  // 1. èªå¯ãƒã‚§ãƒƒã‚¯
  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.substring(7) !== WEBHOOK_SECRET) {
    console.warn(`[${new Date().toISOString()}] /api/upload-url: Unauthorized access attempt.`);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  console.log(`[${new Date().toISOString()}] /api/upload-url: Authorization successful.`);

  // 2. ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒ‘ãƒ¼ã‚¹
  let fileName: string;
  let contentType: string;
  try {
    const body = await request.json();
    fileName = body.fileName;
    contentType = body.contentType;
    if (!fileName || typeof fileName !== 'string' || !contentType || typeof contentType !== 'string') {
      throw new Error('Invalid request body: fileName and contentType are required and must be strings.');
    }

    // è¿½åŠ ï¼šfileNameãŒ.mp4ã§çµ‚ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (!fileName.endsWith('.mp4')) {
      console.warn(`[${new Date().toISOString()}] /api/upload-url: Invalid fileName: ${fileName}. Only .mp4 files are accepted.`);
      return NextResponse.json({ error: 'Only .mp4 files are accepted (filename must end with .mp4)' }, { status: 400 });
    }

    // è¿½åŠ ï¼šcontentTypeãŒvideo/mp4ã‹ãƒã‚§ãƒƒã‚¯
    if (contentType !== 'video/mp4') {
      console.warn(`[${new Date().toISOString()}] /api/upload-url: Invalid contentType: ${contentType}. Only video/mp4 is accepted.`);
      return NextResponse.json({ error: 'Only video/mp4 content type is accepted' }, { status: 400 });
    }

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error parsing request body.';
    console.error(`[${new Date().toISOString()}] /api/upload-url: Error parsing request body: ${errorMessage}`);
    return NextResponse.json({ error: 'Invalid request body', details: errorMessage }, { status: 400 });
  }
  console.log(`[${new Date().toISOString()}] /api/upload-url: Parsed request body:`, { fileName, contentType });

  // 3. ç½²åä»˜ãã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰URLã®ç”Ÿæˆ
  // storagePathã®ä¾‹: public/mtg-assets/videos/{task_id}/{fileName}
  // ã“ã“ã§ã¯ {task_id} ã®éƒ¨åˆ†ã¯ã¾ã ãªã„ã®ã§ã€ä¸€æ—¦ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã¾ãŸã¯fileNameã®ã¿ã§ãƒ‘ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã€‚
  // task_idã¯intakeå´ã§ç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€upload-urlå´ã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«åã®ä¸€æ„æ€§ã‚’ä¿ã¤ãƒ‘ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ã€‚
  // ä¾‹: videos/YYYY/MM/DD/uuid_or_timestamp_fileName
  const timestamp = Date.now();
  const uniqueFileName = `${timestamp}_${fileName.replace(/[^a-zA-Z0-9._-]/g, '_')}`;
  const storagePath = `videos/${uniqueFileName}`; // ãƒã‚±ãƒƒãƒˆç›´ä¸‹ã®videosãƒ•ã‚©ãƒ«ãƒ€ã«ä¿å­˜ã™ã‚‹ä¾‹
                                              // è¨­è¨ˆæ›¸ã® storagePath: "public/mtg-assets/videos/{task_id}/{fileName}" ã¨ã¯ç•°ãªã‚‹ã®ã§æ³¨æ„
                                              // ã“ã“ã¯intakeå´ã§æœ€çµ‚çš„ãªãƒ‘ã‚¹ã‚’æ±ºå®šã—ã€DBã«ä¿å­˜ã™ã‚‹ã€‚
                                              // upload-urlã¯ã‚ãã¾ã§ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å…ˆã‚’ä¸€æ™‚çš„ã«æä¾›ã™ã‚‹ã€‚

  try {
    console.log(`[${new Date().toISOString()}] /api/upload-url: Attempting to create signed upload URL for: ${storagePath}`);
    const { data, error } = await supabase.storage
      .from(STORAGE_BUCKET_NAME)
      .createSignedUploadUrl(storagePath);

    if (error) {
      console.error(`[${new Date().toISOString()}] /api/upload-url: Supabase storage error (createSignedUploadUrl):`, error);
      return NextResponse.json({ error: 'Failed to create upload URL', details: error.message }, { status: 500 });
    }

    if (!data || !data.signedUrl) {
        console.error(`[${new Date().toISOString()}] /api/upload-url: Supabase storage did not return a signedUrl.`);
        return NextResponse.json({ error: 'Failed to obtain upload URL from storage provider'}, { status: 500 });
    }

    console.log(`[${new Date().toISOString()}] /api/upload-url: Signed upload URL created successfully for path: ${storagePath}`);
    return NextResponse.json({
      uploadUrl: data.signedUrl,
      storagePath: data.path, // SupabaseãŒè¿”ã—ãŸå®Ÿéš›ã®ãƒ‘ã‚¹ (createSignedUploadUrlã®ç¬¬ä¸€å¼•æ•°ã¨åŒã˜ã¯ãš)
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown server error.';
    console.error(`[${new Date().toISOString()}] /api/upload-url: Unexpected server error: ${errorMessage}`);
    return NextResponse.json({ error: 'Unexpected server error', details: errorMessage }, { status: 500 });
  }
}

================
File: package.json
================
{
  "name": "dagitoru-mtglog",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.2.0",
    "@notionhq/client": "^2.2.14",
    "@supabase/auth-helpers-nextjs": "^0.9.0",
    "@supabase/supabase-js": "^2.39.0",
    "dotenv": "^16.4.5",
    "next": "14.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "14.0.4",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.3.3"
  }
}

================
File: supabase/functions/upload_file_to_storage/index.ts
================
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient, SupabaseClient } from "npm:@supabase/supabase-js@2.43.4"; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å›ºå®šã¾ãŸã¯é©åˆ‡ã«ç®¡ç†
import "https://deno.land/std@0.224.0/dotenv/load.ts"; // ãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç”¨ã« .env ã‚’èª­ã¿è¾¼ã‚€å ´åˆ

// Supabaseãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®Secretsåã«åˆã‚ã›ã‚‹
const SUPABASE_URL_FROM_ENV = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY_FROM_ENV = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
const SLACK_BOT_TOKEN_FROM_ENV = Deno.env.get("SLACK_BOT_TOKEN");

interface TaskPayload {
  taskId: string;
  slack_file_id?: string; // APIã‹ã‚‰å‘¼ã°ã‚Œã‚‹å ´åˆã¯å¿…é ˆã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œãªã„ã®ã§ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«
  slack_download_url: string;
  original_file_name: string;
  mimetype: string;
  filetype: string;
}

async function updateTaskStatus(
  supabase: SupabaseClient,
  taskId: string,
  status: string,
  updatePayload: Record<string, unknown> = {}
): Promise<void> {
  const { error } = await supabase
    .from("transcription_tasks")
    .update({ status, ...updatePayload, updated_at: new Date().toISOString() })
    .eq("id", taskId);
  if (error) {
    console.error(`Error updating task ${taskId} to ${status}:`, error.message);
    // ã“ã“ã§ã•ã‚‰ã«å …ç‰¢ãªã‚¨ãƒ©ãƒ¼é€šçŸ¥å‡¦ç†ã‚’å…¥ã‚Œã‚‹ã“ã¨ã‚‚æ¤œè¨ (ä¾‹: Slacké€šçŸ¥)
  }
}

serve(async (req: Request) => {
  if (!SUPABASE_URL_FROM_ENV || !SUPABASE_SERVICE_ROLE_KEY_FROM_ENV || !SLACK_BOT_TOKEN_FROM_ENV) {
    console.error("Missing one or more required environment variables. Check SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, SLACK_BOT_TOKEN.");
    return new Response(JSON.stringify({ error: "Internal server configuration error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  const supabaseAdmin = createClient(SUPABASE_URL_FROM_ENV, SUPABASE_SERVICE_ROLE_KEY_FROM_ENV);
  let payload: TaskPayload;

  try {
    payload = await req.json();
    console.log("Received payload:", payload);
  } catch (e) {
    console.error("Failed to parse request body:", e);
    return new Response(JSON.stringify({ error: "Invalid request body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  const {
    taskId,
    slack_download_url,
    original_file_name,
    mimetype,
    filetype,
  } = payload;

  if (!taskId || !slack_download_url || !original_file_name || !mimetype || !filetype) {
    console.error("Missing required fields in payload:", payload);
    return new Response(JSON.stringify({ error: "Missing required fields in payload" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    console.log(`[${taskId}] Starting file download from Slack: ${slack_download_url}`);
    const slackFileResponse = await fetch(slack_download_url, {
      headers: {
        Authorization: `Bearer ${SLACK_BOT_TOKEN_FROM_ENV}`,
      },
    });

    if (!slackFileResponse.ok || !slackFileResponse.body) {
      const errorBody = await slackFileResponse.text();
      console.error(
        `[${taskId}] Failed to download file from Slack: ${slackFileResponse.status}`,
        errorBody
      );
      await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
        error_message: `Slack download failed: ${slackFileResponse.status} - ${errorBody.substring(0, 200)}`,
      });
      return new Response(
        JSON.stringify({ error: "Failed to download file from Slack" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }
    console.log(`[${taskId}] File downloaded from Slack. Preparing to stream to Supabase Storage...`);

    let fileExtension = filetype || "dat";
    // MIMEã‚¿ã‚¤ãƒ—ã‹ã‚‰ã®æ‹¡å¼µå­æ¨æ¸¬ãƒ­ã‚¸ãƒƒã‚¯ (Vercel APIã‹ã‚‰ã‚³ãƒ”ãƒ¼ï¼†æ”¹å–„ã‚‚æ¤œè¨)
    if (mimetype.startsWith("video/")) {
      fileExtension = mimetype.split("/")[1];
    } else if (mimetype.startsWith("audio/")) {
      fileExtension = mimetype.split("/")[1] === "mpeg" ? "mp3" : mimetype.split("/")[1];
    }
    if (fileExtension === "quicktime") fileExtension = "mov";
    // ä¸æ˜ãªæ‹¡å¼µå­ã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚„ã€ã‚ˆã‚Šå …ç‰¢ãªãƒãƒƒãƒ”ãƒ³ã‚°ãŒå¿…è¦ãªå ´åˆã‚‚

    const storagePath = `uploads/${taskId}.${fileExtension}`;
    console.log(`[${taskId}] Uploading to Supabase Storage: ${storagePath} with type ${mimetype} using stream`);

    const { data: uploadResult, error: uploadError } =
      await supabaseAdmin.storage
        .from("videos")
        .upload(storagePath, slackFileResponse.body, {
          contentType: mimetype,
          upsert: false, // true ã«ã—ã¦å†è©¦è¡Œã‚’è¨±å®¹ã™ã‚‹ã‹æ¤œè¨
          duplex: "half", // Denoã®ReadableStreamã‚’æ‰±ã†ãŸã‚ã«è¿½åŠ 
        });

    if (uploadError) {
      console.error(`[${taskId}] Failed to upload to Supabase Storage:`, uploadError);
      await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
        error_message: `Supabase Storage upload failed: ${uploadError.message}`,
      });
      return new Response(
        JSON.stringify({ error: "Failed to upload to Supabase Storage" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }

    console.log(`[${taskId}] File uploaded to Supabase Storage:`, uploadResult);
    await updateTaskStatus(supabaseAdmin, taskId, "uploaded", { // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ 'uploaded' ã«å¤‰æ›´
      storage_path: storagePath,
      error_message: null, // ã‚¨ãƒ©ãƒ¼ãŒè§£æ¶ˆã•ã‚ŒãŸå ´åˆã¯ã‚¯ãƒªã‚¢
    });

    return new Response(JSON.stringify({ message: "File uploaded and task updated successfully", taskId, storagePath }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });

  } catch (error) {
    console.error(`[${taskId}] Unexpected error in upload_file_to_storage:`, error);
    await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
      error_message: error instanceof Error ? error.message : String(error),
    });
    return new Response(JSON.stringify({ error: "Unexpected server error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
});

================
File: .gitignore
================
# Local environment variables
.env.local

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json

# IDE files
.vscode/
.idea/

# OS generated files
.DS_Store
Thumbs.db
node_modules

# Deno
.deno_cache/

# Next.js build output
.next/

# Compiled JS dist
/dist/

================
File: cloudrun-transcriber/index.js
================
require('dotenv').config({ path: '../.env.local' }); // .env.local ã¯Cloud Runã§ã¯ä½¿ã‚ã‚Œã¾ã›ã‚“
const express = require('express');
const { Storage } = require('@google-cloud/storage');
const speech = require('@google-cloud/speech');
const fetch = require('node-fetch'); // package.json ã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä¸€è‡´
const ffmpeg = require('fluent-ffmpeg');
const ffmpegPath = require('ffmpeg-static'); // â† å­˜åœ¨ã—ã¾ã™
const fs = require('fs');
const path = require('path');
const os = require('os');

if (process.env.GOOGLE_CREDENTIALS_BASE64) {
  try {
    const decodedCredentials = Buffer.from(process.env.GOOGLE_CREDENTIALS_BASE64, 'base64').toString('utf-8');
    const credsPath = '/tmp/gcp-creds.json'; // Cloud Runã§ã¯ /tmp ãŒæ›¸ãè¾¼ã¿å¯èƒ½ãªãƒ¡ãƒ¢ãƒªãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã§ã™
    fs.writeFileSync(credsPath, decodedCredentials);
    process.env.GOOGLE_APPLICATION_CREDENTIALS = credsPath;
    console.log(`GOOGLE_APPLICATION_CREDENTIALS set to ${credsPath}`); // èµ·å‹•ãƒ­ã‚°ã§ç¢ºèªç”¨
  } catch (error) {
    console.error('CRITICAL: Failed to process GOOGLE_CREDENTIALS_BASE64. Application may not authenticate with Google Cloud services.', error);
    // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®æŒ™å‹•ã‚’è€ƒæ…®ï¼ˆä¾‹: ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ã‚‚æ¤œè¨ï¼‰
    // process.exit(1);
  }
}

const app = express();
app.use(express.json());

const storage = new Storage();
const speechClient = new speech.SpeechClient();

ffmpeg.setFfmpegPath(ffmpegPath);

app.post('/transcribe', async (req, res) => {
  // è¿½åŠ : å—ä¿¡ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å…¨ã¦ãƒ­ã‚°å‡ºåŠ›
  console.log("Headers received:", req.headers);

  // èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼ã®é˜²å¾¡çš„æ¤œè¨¼
  const authHeader = req.headers["x-vercel-secret"];
  if (!authHeader) {
    console.warn("/transcribe: Missing x-vercel-secret header", authHeader);
    return res.status(401).send("Missing x-vercel-secret header");
  }
  if (authHeader !== process.env.WEBHOOK_SECRET) {
    console.warn("/transcribe: Unauthorized - token mismatch");
    return res.status(401).send("Unauthorized");
  }

  console.log(`/transcribe: Received request. Body:`, JSON.stringify(req.body, null, 2));
  const { signedUrl, gcsBucket, gcsDestPath, taskId } = req.body;
  if (!signedUrl || !gcsBucket || !gcsDestPath || !taskId) {
    console.error('/transcribe: Missing required parameters', req.body);
    return res.status(400).json({ error: 'Missing required parameters' });
  }

  const tmpVideoPath = path.join(os.tmpdir(), `input_${Date.now()}.mp4`);
  const tmpAudioPath = path.join(os.tmpdir(), `audio_${Date.now()}.mp3`);

  try {
    // 1. Supabaseç½²åä»˜ãURLã‹ã‚‰å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    console.log(`/transcribe: Downloading video from signed URL for task ${taskId}`);
    const videoRes = await fetch(signedUrl);
    if (!videoRes.ok) throw new Error(`Failed to download video from Supabase: ${videoRes.status} ${videoRes.statusText}`);
    const fileStream = fs.createWriteStream(tmpVideoPath);
    await new Promise((resolve, reject) => {
      videoRes.body.pipe(fileStream);
      videoRes.body.on('error', reject);
      fileStream.on('finish', resolve);
    });
    console.log(`/transcribe: Video downloaded successfully to ${tmpVideoPath}`);

    // 2. FFmpegã§éŸ³å£°æŠ½å‡º
    console.log(`/transcribe: Extracting audio from video for task ${taskId}`);
    await new Promise((resolve, reject) => {
      ffmpeg(tmpVideoPath)
        .noVideo()
        .audioCodec('libmp3lame')
        .audioFrequency(16000)
        .audioChannels(1)
        .audioBitrate('64k')
        .save(tmpAudioPath)
        .on('end', resolve)
        .on('error', reject);
    });
    console.log(`/transcribe: Audio extracted successfully to ${tmpAudioPath}`);

    // 3. GCSã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    console.log(`/transcribe: Uploading audio to GCS bucket ${gcsBucket}/${gcsDestPath}`);
    await storage.bucket(gcsBucket).upload(tmpAudioPath, {
      destination: gcsDestPath,
    });
    const gcsUri = `gs://${gcsBucket}/${gcsDestPath}`;
    console.log(`/transcribe: Audio uploaded successfully to ${gcsUri}`);

    // 4. Speech-to-Text
    console.log(`/transcribe: Starting speech recognition for task ${taskId}`);
    const request = {
      audio: { uri: gcsUri },
      config: {
        encoding: 'MP3',
        sampleRateHertz: 16000,
        languageCode: 'ja-JP',
      },
    };
    const [operation] = await speechClient.longRunningRecognize(request);
    console.log(`/transcribe: Waiting for speech recognition to complete for task ${taskId}`);
    const [response] = await operation.promise();
    const finalTranscript = response.results.map(r => r.alternatives[0].transcript).join('\n');
    console.log(`/transcribe: Speech recognition completed for task ${taskId}, transcript length: ${finalTranscript.length} chars`);

    // 5. /api/summarize-task ã¸POST
    if (finalTranscript && process.env.SUMMARIZE_TASK_ENDPOINT && process.env.WEBHOOK_SECRET) {
      console.log(`/transcribe: Posting transcript to summarize-task endpoint for task ${taskId}`);
      const summarizeRes = await fetch(process.env.SUMMARIZE_TASK_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.WEBHOOK_SECRET}`
        },
        body: JSON.stringify({
          taskId,
          transcript: finalTranscript
        })
      });
      if (!summarizeRes.ok) {
        const errText = await summarizeRes.text();
        console.error(`/transcribe: /api/summarize-task failed: ${summarizeRes.status} ${errText}`);
        throw new Error(`/api/summarize-task failed: ${summarizeRes.status} ${errText}`);
      }
      console.log(`/transcribe: Transcript successfully sent to summarize-task endpoint for task ${taskId}`);
    } else {
      console.warn(`/transcribe: Not sending to summarize-task - Missing endpoint URL or webhook secret, or empty transcript`);
    }

    // 6. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    console.log(`/transcribe: Cleaning up temporary files for task ${taskId}`);
    fs.unlinkSync(tmpVideoPath);
    fs.unlinkSync(tmpAudioPath);
    // await storage.bucket(gcsBucket).file(gcsDestPath).delete(); // å¿…è¦ãªã‚‰

    console.log(`/transcribe: Process completed successfully for task ${taskId}`);
    res.status(200).json({ message: 'Transcription and summarize-task POST successful', taskId });

  } catch (err) {
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    console.error(`/transcribe: Error processing task ${taskId}:`, err);
    if (fs.existsSync(tmpVideoPath)) fs.unlinkSync(tmpVideoPath);
    if (fs.existsSync(tmpAudioPath)) fs.unlinkSync(tmpAudioPath);
    res.status(500).json({ error: err.message });
  }
});

// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get('/', (req, res) => {
  res.status(200).json({ status: 'ok', message: 'Cloud Run transcriber service is running' });
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Cloud Run transcription service listening on port ${PORT}`);
});

================
File: README.md
================
# Slack å‹•ç”»è¦ç´„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€Slackã«æŠ•ç¨¿ã•ã‚ŒãŸå‹•ç”»ã‚’è‡ªå‹•ã§æ–‡å­—èµ·ã“ã—ã—ã€è¦ç´„ã‚’ä½œæˆã—ã¦é€šçŸ¥ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚

## æ§‹æˆ

- `apps/webhook-vercel`: Slackã‚¤ãƒ™ãƒ³ãƒˆã‚’å—ä¿¡ã—ã€Supabaseã«å‡¦ç†è¦æ±‚ã‚’ç™»éŒ²ã™ã‚‹Next.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ (Vercelãƒ‡ãƒ—ãƒ­ã‚¤æƒ³å®š)
- `services/transcriber`: å‹•ç”»ã®æ–‡å­—èµ·ã“ã—ã¨è¦ç´„ã‚’è¡Œã†Pythonãƒãƒƒãƒå‡¦ç†
- `scripts`: è£œåŠ©ã‚¹ã‚¯ãƒªãƒ—ãƒˆ (ä¾‹: ç‰¹å®šå‹•ç”»ã®å†å‡¦ç†)
- `docs`: ä»•æ§˜æ›¸ãªã©
ã‚ã‚ã‚ã‚ã‚ã‚
## ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨å®Ÿè¡Œ

(å„ã‚µãƒ¼ãƒ“ã‚¹ã”ã¨ã®è©³ç´°ã‚’è¨˜è¿°)

### `webhook-vercel`

...

### `transcriber`

... 
(Ensuring commit for package-lock.json move.) 

# Edge / Node ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«ã¤ã„ã¦

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€Edgeï¼ˆDenoï¼‰ç’°å¢ƒã¨Node.jsç’°å¢ƒã‚’é©åˆ‡ã«ä½¿ã„åˆ†ã‘ã¦ã„ã¾ã™ã€‚

## ç’°å¢ƒåˆ†é›¢ã¨è²¬å‹™

| å‡¦ç†å†…å®¹ | ç’°å¢ƒ | å®Ÿè£…ãƒ‘ã‚¹ | ç†ç”± |
|--------|------|---------|------|
| Slack â†’ Supabase ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ | **Node.js** | `app/utils/slack-to-supabase-uploader.ts` | ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ã‚„å¤§å®¹é‡ãƒ•ã‚¡ã‚¤ãƒ«è»¢é€ã¯NodeãŒé©ã—ã¦ã„ã‚‹ |
| æ–‡å­—èµ·ã“ã—å‡¦ç† | **Edge (Deno)** | `supabase/functions/transcribe_with_whisper/index.ts` | è»½é‡ãªAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã«æœ€é©åŒ– |
| è¦ç´„å‡¦ç† | **Edge (Node API)** | `app/api/summarize-task/route.ts` | è¤‡é›‘ãªAIå‡¦ç†ã¨è¤‡æ•°ã®éåŒæœŸå‡¦ç† |
| Notioné€£æº | **Edge (Node API)** | `app/api/notion-sync/route.ts` | å¤–éƒ¨APIã¨ã®ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ |

## é–‹ç™ºç’°å¢ƒè¨­å®š

### Deno (Edge Functions)

```bash
# Supabase Edge Functions ã®ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯
cd supabase
deno cache --reload functions/**/*.ts

# Edge Functions ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§å®Ÿè¡Œ
supabase functions serve --env-file ../.env.local
```

### Node.js (API Routes)

```bash
# é–‹ç™ºã‚µãƒ¼ãƒãƒ¼èµ·å‹•
npm run dev:webhook

# Slack ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
npm run upload-slack -- <slack-file-url>
```

================
File: supabase/functions/process-video-task/index.ts
================
/// <reference lib="deno.ns" />
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient, SupabaseClient } from "npm:@supabase/supabase-js@2.43.4";
import "https://deno.land/std@0.224.0/dotenv/load.ts";

function getEnvVar(key: string): string {
  const value = Deno.env.get(key);
  if (!value) throw new Error(`Environment variable ${key} not set`);
  return value;
}

async function _updateTaskStatus(
  supabase: SupabaseClient,
  taskId: string,
  status: string,
  errorMessage?: string | null
): Promise<void> {
  const updates: { status: string; error_message?: string; notified_at?: string } = {
    status,
    // notified_at: new Date().toISOString(), // ã‚«ãƒ©ãƒ ãŒå­˜åœ¨ã—ã€æ›´æ–°ã—ãŸã„å ´åˆã®ã¿æœ‰åŠ¹åŒ–
  };
  if (errorMessage) {
    updates.error_message = errorMessage;
  }
  const { error } = await supabase
    .from("transcription_tasks")
    .update(updates)
    .eq("id", taskId);
  if (error) console.error(`Error updating task to ${status}:`, error.message);
  else console.log(`Task ${taskId} status updated to ${status}.`);
}

serve(async (req: Request) => {
  const cors = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
  };

  if (req.method === "OPTIONS") return new Response("ok", { headers: cors });

  let supabase: SupabaseClient | null = null;
  let taskId: string | null = null; 

  try {
    const { taskId: receivedTaskId, storagePath } = await req.json();
    
    if (!receivedTaskId || !storagePath) {
      console.error("taskId or storagePath missing in payload:", { receivedTaskId, storagePath });
      throw new Error("taskId or storagePath missing in payload");
    }
    taskId = receivedTaskId; 

    const supabaseUrl = getEnvVar("SUPABASE_URL");
    const serviceRoleKey = getEnvVar("SUPABASE_SERVICE_ROLE_KEY");
    supabase = createClient(supabaseUrl, serviceRoleKey);

    // VERCEL_WEBHOOK_URL ã‚’ä½¿ç”¨ã—ãŸé€šçŸ¥å‡¦ç†ã‚’å‰Šé™¤
    console.log(`Task ${taskId} (storagePath: ${storagePath}) received by process-video-task. Vercel notification via VERCEL_WEBHOOK_URL is now disabled.`);

    // ã“ã®FunctionãŒä»–ã«æ‹…ã£ã¦ã„ãŸå‡¦ç†ãŒã‚ã‚Œã°ã“ã“ã«æ®‹ã‚Šã¾ã™ã€‚
    // ç¾çŠ¶ã€Vercelã¸ã®é€šçŸ¥ãŒä¸»ç›®çš„ã ã£ãŸå ´åˆã€ã“ã®Functionã¯ã»ã¨ã‚“ã©ä½•ã‚‚ã—ãªã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
    // å¿…è¦ã«å¿œã˜ã¦ã€å®Œäº†ã‚’ç¤ºã™ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãªã©ã‚’ã“ã“ã§è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚
    // ä¾‹: await updateTaskStatus(supabase, taskId!, "processed_by_task_function_no_webhook");


    return new Response(JSON.stringify({ message: "process-video-task executed. Notification via VERCEL_WEBHOOK_URL has been removed." }), {
      headers: { ...cors, "Content-Type": "application/json" },
      status: 200,
    });

  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    console.error("Error in process-video-task (Vercel notification part removed):", msg);
    if (taskId && supabase) { 
      // å¿…è¦ã«å¿œã˜ã¦ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
      // await updateTaskStatus(supabase, taskId, "function_error_no_webhook", msg);
    }
    return new Response(JSON.stringify({ error: `Error in process-video-task: ${msg}` }), {
      headers: { ...cors, "Content-Type": "application/json" },
      status: 500,
    });
  }
});

================
File: vercel.json
================
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "https://tqeprgfaybkvknmzeraj.supabase.co"
  },
  "regions": ["hnd1"],
  "github": {
    "silent": true
  }
}

================
File: app/api/start-task/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// ç’°å¢ƒå¤‰æ•°
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const CLOUD_RUN_TRANSCRIBE_URL = process.env.CLOUD_RUN_TRANSCRIBE_URL;
const GCS_BUCKET = process.env.GCS_BUCKET || 'transcription-audio';

// Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–
let supabase: ReturnType<typeof createClient> | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
} else {
  console.error('[start-task/route.ts] Missing Supabase URL or Service Role Key env vars.');
}

interface StartTaskPayload {
  taskId: string;
  slackFileUrl?: string;
}

export async function POST(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] >>> /api/start-task called`);
  
  // 1. Authorizationãƒ˜ãƒƒãƒ€ãƒ¼æ¤œè¨¼
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET) {
    console.error(`[${timestamp}] /api/start-task: WEBHOOK_SECRET is not configured on the server.`);
    return NextResponse.json({ error: 'Internal Server Configuration Error: Webhook secret not set.' }, { status: 500 });
  }
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.split(' ')[1] !== WEBHOOK_SECRET) {
    console.warn(`[${timestamp}] /api/start-task: Unauthorized access attempt. Auth Header: '${authHeader}'`);
    return NextResponse.json({ error: 'Unauthorized: Invalid or missing token.' }, { status: 401 });
  }
  console.log(`[${timestamp}] /api/start-task: Authorization successful.`);

  // 2. Cloud Run URLã®ç¢ºèª
  if (!CLOUD_RUN_TRANSCRIBE_URL) {
    console.error(`[${timestamp}] /api/start-task: CLOUD_RUN_TRANSCRIBE_URL is not configured.`);
    return NextResponse.json({ error: 'Server Configuration Error: Cloud Run URL not set.' }, { status: 500 });
  }

  // 3. ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒ‘ãƒ¼ã‚¹
  let payload: StartTaskPayload;
  try {
    payload = await request.json();
    console.log(`[${timestamp}] /api/start-task: Received payload:`, JSON.stringify(payload, null, 2));
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown parsing error';
    console.error(`[${timestamp}] /api/start-task: JSON parse failed:`, errorMessage, err);
    return NextResponse.json({ error: 'Invalid JSON body', details: errorMessage }, { status: 400 });
  }

  // 4. å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ¤œè¨¼
  const { taskId } = payload;
  if (!taskId) {
    console.error(`[${timestamp}] /api/start-task: Missing required fields in parsed payload.`);
    return NextResponse.json({ error: 'Missing required fields in payload' }, { status: 400 });
  }

  try {
    // 5. Supabaseã‹ã‚‰ã‚¿ã‚¹ã‚¯æƒ…å ±ã®å–å¾—
    if (!supabase) {
      console.error(`[${timestamp}] /api/start-task: Supabase client not initialized.`);
      return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
    }

    console.log(`[${timestamp}] /api/start-task: Fetching task info for taskId: ${taskId}`);
    const { data: taskData, error: taskError } = await supabase
      .from('transcription_tasks')
      .select('*')
      .eq('id', taskId)
      .single();

    if (taskError) {
      console.error(`[${timestamp}] /api/start-task: Failed to fetch task data:`, taskError);
      return NextResponse.json({ error: 'Failed to fetch task data', details: taskError.message }, { status: 404 });
    }

    if (!taskData || !taskData.storage_path) {
      console.error(`[${timestamp}] /api/start-task: Task data missing or storage_path not found.`);
      return NextResponse.json({ error: 'Task data missing or invalid' }, { status: 400 });
    }

    // === å†ªç­‰æ€§ãƒã‚§ãƒƒã‚¯: æ—¢ã«å‡¦ç†ä¸­ãƒ»å®Œäº†æ¸ˆã¿ãªã‚‰ã‚¹ã‚­ãƒƒãƒ— ===
    if (["processing", "transcribed", "completed", "failed"].includes(taskData.status as string)) {
      console.warn(`[${timestamp}] /api/start-task: Task ${taskId} is already in status '${taskData.status}'. Skipping duplicate execution.`);
      return NextResponse.json({
        message: `Task already processed or in progress (status: ${taskData.status})`,
        taskId,
        status: taskData.status
      }, { status: 200 });
    }

    // 6. ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ 'processing' ã«æ›´æ–°
    const { error: updateError } = await supabase
      .from('transcription_tasks')
      .update({ status: 'processing', updated_at: new Date().toISOString() })
      .eq('id', taskId);

    if (updateError) {
      console.error(`[${timestamp}] /api/start-task: Failed to update task status:`, updateError);
      return NextResponse.json({ error: 'Failed to update task status', details: updateError.message }, { status: 500 });
    }

    // 7. å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ç½²åä»˜ãURLã‚’å–å¾—
    console.log(`[${timestamp}] /api/start-task: Getting signed URL for ${taskData.storage_path}`);
    const { data: signedUrlData, error: signedUrlError } = await supabase
      .storage
      .from('videos')
      .createSignedUrl(taskData.storage_path as string, 60 * 30); // 30åˆ†æœ‰åŠ¹

    if (signedUrlError || !signedUrlData?.signedUrl) {
      console.error(`[${timestamp}] /api/start-task: Failed to get signed URL:`, signedUrlError);
      return NextResponse.json({ error: 'Failed to get signed URL', details: signedUrlError?.message || 'No signed URL returned' }, { status: 500 });
    }

    // 8. Cloud Runã¸ã®è»¢é€å…ˆãƒ‘ã‚¹ã‚’ç”Ÿæˆ
    const gcsDestPath = `audio/${taskId}/${Date.now()}.mp3`;
    
    // 9. Cloud Runã¸æ–‡å­—èµ·ã“ã—ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
    console.log(`[${timestamp}] /api/start-task: Sending transcription request to Cloud Run`);
    const cloudRunPayload = {
      signedUrl: signedUrlData.signedUrl,
      gcsBucket: GCS_BUCKET,
      gcsDestPath,
      taskId
    };
    
    const response = await fetch(CLOUD_RUN_TRANSCRIBE_URL, {
      method: 'POST',
      headers: {
        'x-vercel-secret': WEBHOOK_SECRET,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(cloudRunPayload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[${timestamp}] /api/start-task: Cloud Run request failed:`, response.status, errorText);
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ 'error' ã«æ›´æ–°
      await supabase
        .from('transcription_tasks')
        .update({ 
          status: 'failed', 
          error_message: `Cloud Run request failed: ${response.status} - ${errorText}`,
          updated_at: new Date().toISOString() 
        })
        .eq('id', taskId);
        
      return NextResponse.json({ 
        error: 'Cloud Run request failed', 
        details: errorText,
        status: response.status 
      }, { status: 502 });
    }

    const cloudRunResult = await response.json();
    console.log(`[${timestamp}] /api/start-task: Cloud Run request successful:`, JSON.stringify(cloudRunResult, null, 2));

    return NextResponse.json({
      message: 'Transcription task started successfully',
      taskId,
      status: 'processing'
    });

  } catch (error) {
    // äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ã®å‡¦ç†
    const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : 'Unknown internal server error';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(`[${timestamp}] /api/start-task: Unhandled internal error:`, errorMessage, errorStack, error);
    
    // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã¯ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
    if (supabase && taskId) {
      await supabase
        .from('transcription_tasks')
        .update({ 
          status: 'failed', 
          error_message: errorMessage,
          updated_at: new Date().toISOString() 
        })
        .eq('id', taskId);
    }
    
    return NextResponse.json({ error: 'Internal server error', details: errorMessage }, { status: 500 });
  }
}

================
File: app/api/slack/events/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import process from 'node:process';

// WEBHOOK_SECRETã¯Vercelã®ç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ã™ã‚‹ã“ã¨ã‚’æƒ³å®š
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const NEXT_PUBLIC_BASE_URL = process.env.NEXT_PUBLIC_APP_URL; // NEXT_PUBLIC_BASE_URLã®ä»£ã‚ã‚Šã«NEXT_PUBLIC_APP_URLã‚’ä½¿ç”¨

export async function POST(req: NextRequest) { // NextRequestã‚’ä½¿ç”¨
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}][slack/events] >>> /slack/events called`);
  console.log(`[${timestamp}][slack/events] Headers:`, Object.fromEntries(req.headers.entries()));

  let body;
  try {
    body = await req.json();
    console.log(`[${timestamp}][slack/events] Parsed body:`, JSON.stringify(body, null, 2));
  } catch (e) {
    const error = e instanceof Error ? e : new Error('Unknown parsing error');
    console.error(`[${timestamp}][slack/events] Failed to parse body:`, error.message, error.stack);
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }

  // Slackã®URLæ¤œè¨¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¯¾å¿œ
  if (body.type === "url_verification") {
    console.log(`[${timestamp}][slack/events] URL verification challenge received`);
    return NextResponse.json({ challenge: body.challenge });
  }

  // Slackã‚¤ãƒ™ãƒ³ãƒˆã®ç½²åæ¤œè¨¼ (ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ã ãŒæ¨å¥¨)
  // ã“ã“ã§ã¯WEBHOOK_SECRETã«ã‚ˆã‚‹èªè¨¼ã‚’intakeå´ã§è¡Œã†ãŸã‚ã€eventå´ã§ã¯çœç•¥ã‚‚å¯èƒ½
  // ã‚‚ã—Slackã®ç½²åæ¤œè¨¼ã‚‚è¡Œã„ãŸã„å ´åˆã¯ã€å…ƒã®verifySlackSignatureé–¢æ•°ã‚’å¾©æ´»ã•ã›ã‚‹

  const event = body.event;

  if (event?.type === "message" && event.subtype === "file_share") {
    const files = event.files || [];
    console.log(`[${timestamp}][slack/events] Processing ${files.length} file(s) in message event.`);

    const videoPayloads = files
      .filter((file: any) => {
        const isVideo = file.mimetype?.startsWith("video/");
        if (!isVideo) {
          console.log(`[${timestamp}][slack/events] Skipping non-video file: ${file.name} (type: ${file.mimetype})`);
        }
        return isVideo;
      })
      .map((file: any) => ({
        file_id: file.id,
        original_file_name: file.name,
        mimetype: file.mimetype,
        filetype: file.filetype,
        slack_download_url: file.url_private_download,
        slack_user_id: event.user,
        slack_channel_id: event.channel,
        slack_team_id: body.team_id, // body.team_id ã‹ã‚‰å–å¾—
        slack_event_ts: event.event_ts,
        metadata: extractMetadata(event.text)
      }));

    if (videoPayloads.length === 0) {
      console.log(`[${timestamp}][slack/events] No video files found in the message.`);
    } else {
      console.log(`[${timestamp}][slack/events] Found ${videoPayloads.length} video file(s) to process.`);
    }

    const promises = videoPayloads.map(async (payload: any) => {
      const fileIdForLog = payload.file_id || 'unknown_file';
      if (!NEXT_PUBLIC_BASE_URL) {
        console.error(`[${timestamp}][slack/events] CRITICAL: NEXT_PUBLIC_APP_URL (as NEXT_PUBLIC_BASE_URL) is not defined. Cannot call /api/slack/intake for file ${fileIdForLog}.`);
        return; // ã“ã®Promiseã¯ã“ã“ã§çµ‚äº†
      }
      if (!WEBHOOK_SECRET) {
        console.error(`[${timestamp}][slack/events] CRITICAL: WEBHOOK_SECRET is not defined. Cannot authorize call to /api/slack/intake for file ${fileIdForLog}.`);
        return; // ã“ã®Promiseã¯ã“ã“ã§çµ‚äº†
      }
      const url = `${NEXT_PUBLIC_BASE_URL}/api/slack/intake`;

      try {
        console.log(`[${timestamp}][slack/events] Fetching: ${url} for file ${fileIdForLog}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${WEBHOOK_SECRET}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const resBody = await res.text(); // Always get text first, as .json() might fail if not json
        if (!res.ok) {
          console.error(`[${timestamp}][slack/events] Intake failed for file ${fileIdForLog}. Status: ${res.status} ${res.statusText}. Response Body:`, resBody);
        } else {
          console.log(`[${timestamp}][slack/events] Intake succeeded for file ${fileIdForLog}. Status: ${res.status}. Response Body:`, resBody);
        }
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown fetch error');
        console.error(`[${timestamp}][slack/events] Intake error for file ${fileIdForLog}: ${error.message}`, error.stack, err);
      }
    });
    
    // Slackã¸ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ãŸã‚ã«ã€Promise.all ã®çµæœã‚’å¾…ãŸãšã«è¿”ã™ã“ã¨ã‚‚æ¤œè¨ã§ãã‚‹ãŒã€
    // Vercelã®ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹é–¢æ•°ã®å®Ÿè¡Œæ™‚é–“åˆ¶é™ï¼ˆé€šå¸¸10ç§’ï½ï¼‰ã‚’è€ƒæ…®ã—ã€ã“ã“ã§ã¯å®Œäº†ã‚’å¾…ã¤ã€‚
    // ã‚‚ã—å¤šæ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åŒæ™‚ã«å‡¦ç†ã—ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒæ‡¸å¿µã•ã‚Œã‚‹å ´åˆã¯ã€intakeå´ã‚’ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ç¹‹ããªã©ã®æ›´ãªã‚‹å¯¾ç­–ãŒå¿…è¦ã€‚
    try {
      await Promise.all(promises);
      console.log(`[${timestamp}][slack/events] All intake promises processed for message event.`);
    } catch (error) {
      // ã“ã®catchã¯ map å†…ã® individual catch ã§æ•æ‰ã•ã‚Œãªã‹ã£ãŸå ´åˆã«å‚™ãˆã‚‹ (é€šå¸¸ã¯åˆ°é”ã—ãªã„ã¯ãš)
      console.error(`[${timestamp}][slack/events] Error processing Promise.all for intake calls:`, error);
    }
  }

  // Slackã«ã¯å¸¸ã«200 OKã‚’é€Ÿã‚„ã‹ã«è¿”ã™
  return NextResponse.json({ message: "Event received and processing initiated" }, { status: 200 });
}

function extractMetadata(text: string | undefined) {
  if (!text) return {};
  return {
    consultant_name: extractByPattern(text, /ã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆå\s*([^\n]+)/),
    client_name: extractByPattern(text, /ä¼æ¥­å(?:æ ªå¼)?\s*([^\n]+)/),
    meeting_date: extractByPattern(text, /é¢è«‡æ—¥\s*(\d{4}\/\d{2}\/\d{2})/),
    meeting_type: extractByPattern(text, /é¢è«‡ã‚¿ã‚¤ãƒ—\s*([^\n]+)/),
    company_problem: extractByPattern(text, /ä¼æ¥­ã®èª²é¡Œ\s*([^\n]+)/), 
    company_phase: extractByPattern(text, /ä¼æ¥­ã®ãƒ•ã‚§ãƒ¼ã‚º\s*([^\n]+)/), 
    company_type: extractByPattern(text, /ä¼æ¥­ã‚¿ã‚¤ãƒ—\s*([^\n]+)/), 
    meeting_count: extractByPattern(text, /é¢è«‡å›æ•°\s*(\d+)/), 
    support_area: extractByPattern(text, /æ”¯æ´é ˜åŸŸ\s*([^\n]+)/), 
    internal_sharing_items: extractByPattern(text, /ç¤¾å†…å…±æœ‰ãŒå¿…è¦ãªäº‹é …\s*([^\n]+)/)
  };
}

function extractByPattern(text: string, regex: RegExp) {
  const match = text.match(regex);
  return match?.[1]?.trim() || null;
}

================
File: app/api/slack/intake/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// ç’°å¢ƒå¤‰æ•°
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const SLACK_BOT_TOKEN = process.env.SLACK_BOT_TOKEN;
const NEXT_PUBLIC_APP_URL = process.env.NEXT_PUBLIC_APP_URL;

let supabase: ReturnType<typeof createClient> | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
} else {
  console.error('[intake/route.ts] Missing Supabase URL or Service Role Key env vars.');
  // ã“ã“ã§supabaseãŒnullã®å ´åˆã€å¾Œç¶šã®å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ãŸã‚ã€æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã‚„ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã‚’æ¤œè¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
  // ãŸã ã—ã€ç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰ã§ã¯DBæ“ä½œå‰ã«nullãƒã‚§ãƒƒã‚¯ãŒã‚ã‚‹ã®ã§ã€è‡´å‘½çš„ã§ã¯ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
}

interface IntakePayload {
  file_id: string;
  original_file_name: string;
  mimetype: string;
  filetype: string;
  slack_download_url: string;
  slack_user_id: string;
  slack_channel_id?: string;
  slack_team_id?: string;
  slack_event_ts?: string;
  metadata: {
    consultant_name?: string;
    client_name?: string;
    meeting_date?: string;
    meeting_type?: string;
    company_problem?: string;
    company_phase?: string;
    company_type?: string;
    meeting_count?: string; 
    support_area?: string;
    internal_sharing_items?: string;
  };
}

export async function POST(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] >>> /api/slack/intake called`);
  
  // 1. Authorizationãƒ˜ãƒƒãƒ€ãƒ¼æ¤œè¨¼
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET) {
    console.error(`[${timestamp}] /api/slack/intake: WEBHOOK_SECRET is not configured on the server.`);
    // WEBHOOK_SECRET ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã®ã¯è‡´å‘½çš„ãªã‚µãƒ¼ãƒãƒ¼è¨­å®šã‚¨ãƒ©ãƒ¼
    return NextResponse.json({ error: 'Internal Server Configuration Error: Webhook secret not set.' }, { status: 500 });
  }
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.split(' ')[1] !== WEBHOOK_SECRET) {
    console.warn(`[${timestamp}] /api/slack/intake: Unauthorized access attempt. Auth Header: '${authHeader}'`);
    return NextResponse.json({ error: 'Unauthorized: Invalid or missing token.' }, { status: 401 });
  }
  console.log(`[${timestamp}] /api/slack/intake: Authorization successful.`);

  // 2. ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã®ãƒ‘ãƒ¼ã‚¹
  let payload: IntakePayload;
  try {
    payload = await request.json();
    console.log(`[${timestamp}] /api/slack/intake: Received payload:`, JSON.stringify(payload, null, 2));
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown parsing error';
    console.error(`[${timestamp}] /api/slack/intake: JSON parse failed:`, errorMessage, err);
    return NextResponse.json({ error: 'Invalid JSON body', details: errorMessage }, { status: 400 });
  }

  // 3. å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ¤œè¨¼ (ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ãƒ‘ãƒ¼ã‚¹å¾Œ)
  const {
    file_id: slackFileId,
    original_file_name,
    mimetype,
    filetype,
    slack_download_url,
    slack_user_id,
    slack_channel_id,
    slack_team_id,
    slack_event_ts,
    metadata,
  } = payload;

  if (!slackFileId || !original_file_name || !mimetype || !filetype || !slack_download_url || !slack_user_id) {
    console.error(`[${timestamp}] /api/slack/intake: Missing required fields in parsed payload. Payload:`, payload);
    return NextResponse.json({ error: 'Missing required fields in payload' }, { status: 400 });
  }
  
  // 4. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯ (ãƒ“ãƒ‡ã‚ªãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å‡¦ç†)
  if (!mimetype.startsWith('video/')) {
      console.warn(`[${timestamp}] /api/slack/intake: Received non-video file type: ${mimetype} for file ${original_file_name}. Skipping.`);
      return NextResponse.json({ message: 'Non-video file type, processing skipped.' }, { status: 200 }); 
  }

  // --- ã“ã“ã‹ã‚‰ãƒ¡ã‚¤ãƒ³å‡¦ç† (try-catchã§å…¨ä½“ã‚’å›²ã‚€ã“ã¨ã‚‚æ¤œè¨) ---
  try {
    // 5. Supabase Storageã¸ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ç½²åä»˜ãURLã®å–å¾—
    if (!NEXT_PUBLIC_APP_URL) {
      console.error(`[${timestamp}] /api/slack/intake: Missing NEXT_PUBLIC_APP_URL for internal API call to /api/upload-url.`);
      // ã“ã‚Œã¯ã‚µãƒ¼ãƒãƒ¼è¨­å®šã‚¨ãƒ©ãƒ¼ãªã®ã§500ã‚’è¿”ã™
      return NextResponse.json({ error: 'Server configuration error: App URL not set.' }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Requesting upload URL from ${NEXT_PUBLIC_APP_URL}/api/upload-url.`);
    const uploadUrlResponse = await fetch(`${NEXT_PUBLIC_APP_URL}/api/upload-url`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${WEBHOOK_SECRET}`, // /api/upload-url ã‚‚åŒã˜ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã§ä¿è­·
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ fileName: original_file_name, contentType: mimetype }),
    });

    if (!uploadUrlResponse.ok) {
      const errorBody = await uploadUrlResponse.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to get upload URL from /api/upload-url. Status: ${uploadUrlResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({ error: 'Failed to get upload URL', details: errorBody }, { status: uploadUrlResponse.status });
    }

    const { uploadUrl, storagePath } = await uploadUrlResponse.json();
    if (!uploadUrl || !storagePath) {
        console.error(`[${timestamp}] /api/slack/intake: Invalid response from /api/upload-url. Missing uploadUrl or storagePath. Response:`, {uploadUrl, storagePath});
        return NextResponse.json({ error: 'Invalid response from upload URL service' }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Received uploadUrl: ${uploadUrl}, storagePath: ${storagePath}`);

    // 6. Slackã‹ã‚‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    console.log(`[${timestamp}] /api/slack/intake: Fetching file from Slack: ${slack_download_url}`);
    if (!SLACK_BOT_TOKEN) {
      console.error(`[${timestamp}] /api/slack/intake: SLACK_BOT_TOKEN is not set. Cannot download from Slack.`);
      return NextResponse.json({ error: 'Server configuration error: SLACK_BOT_TOKEN missing' }, { status: 500 });
    }
    const slackRes = await fetch(slack_download_url, {
      headers: { Authorization: `Bearer ${SLACK_BOT_TOKEN}` },
    });

    if (!slackRes.ok || !slackRes.body) {
      const errorBody = await slackRes.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to download Slack file. Status: ${slackRes.status}, Body: ${errorBody}`);
      // TODO: ã“ã®æ™‚ç‚¹ã§ transcription_tasks ã«ã‚¨ãƒ©ãƒ¼ã‚’è¨˜éŒ²ã™ã‚‹ã“ã¨ã‚‚æ¤œè¨ (status: 'download_failed')
      return NextResponse.json({ error: 'Failed to download Slack file', details: errorBody }, { status: slackRes.status });
    }
    console.log(`[${timestamp}] /api/slack/intake: Successfully fetched file stream from Slack.`);

    // 7. Supabase Storageã¸ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    console.log(`[${timestamp}] /api/slack/intake: Streaming upload to Supabase: ${uploadUrl}`);
    const supabaseUploadRes = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'Content-Type': mimetype,
      },
      body: slackRes.body,
      duplex: 'half',
    } as any);

    if (!supabaseUploadRes.ok) {
      const errorBody = await supabaseUploadRes.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to upload to Supabase. Status: ${supabaseUploadRes.status}, Body: ${errorBody}`);
      // TODO: ã“ã®æ™‚ç‚¹ã§ transcription_tasks ã«ã‚¨ãƒ©ãƒ¼ã‚’è¨˜éŒ²ã™ã‚‹ã“ã¨ã‚‚æ¤œè¨ (status: 'upload_failed')
      return NextResponse.json({ error: 'Failed to upload to Supabase', details: errorBody }, { status: supabaseUploadRes.status });
    }
    console.log(`[${timestamp}] /api/slack/intake: Successfully uploaded to Supabase. Path: ${storagePath}`);

    // 8. Supabaseãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®ã‚¿ã‚¹ã‚¯è¨˜éŒ²
    if (!supabase) {
      console.error(`[${timestamp}] /api/slack/intake: Supabase client not initialized. Cannot insert task to DB.`);
      return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
    }
    
    const taskData = {
      original_file_name: original_file_name,
      mimetype: mimetype,
      filetype: filetype,
      slack_file_id: slackFileId,
      slack_download_url: slack_download_url,
      slack_user_id: slack_user_id,
      slack_channel_id: slack_channel_id, // è¿½åŠ 
      slack_team_id: slack_team_id, // è¿½åŠ 
      slack_event_ts: slack_event_ts, // è¿½åŠ 
      storage_path: storagePath,
      status: 'uploaded', // ãƒˆãƒªã‚¬ãƒ¼ãŒæœŸå¾…ã™ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
      consultant_name: metadata.consultant_name ?? null,
      client_name: metadata.client_name ?? null, 
      company_type: metadata.company_type ?? null,
      company_problem: metadata.company_problem ?? null, 
      meeting_date: metadata.meeting_date ? new Date(metadata.meeting_date).toISOString().split('T')[0] : null, // YYYY-MM-DDå½¢å¼
      meeting_count: metadata.meeting_count ? parseInt(metadata.meeting_count, 10) : null,
      meeting_type: metadata.meeting_type ?? null,
      support_area: metadata.support_area ?? null,
      company_phase: metadata.company_phase ?? null,
      internal_sharing_items: metadata.internal_sharing_items ?? null,
    };
    console.log(`[${timestamp}] /api/slack/intake: Inserting task into DB 'transcription_tasks':`, JSON.stringify(taskData, null, 2));
    const { data: insertedTask, error: dbInsertError } = await supabase
      .from('transcription_tasks')
      .insert(taskData)
      .select()
      .single();

    if (dbInsertError) {
      console.error(`[${timestamp}] /api/slack/intake: Failed to insert task to DB 'transcription_tasks':`, dbInsertError);
      return NextResponse.json({ error: 'DB insert failed for transcription_tasks', details: dbInsertError.message }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Task inserted to DB 'transcription_tasks' successfully. Task ID: ${insertedTask?.id}`);

    // 9. æ–‡å­—èµ·ã“ã—ã‚¿ã‚¹ã‚¯ã®é–‹å§‹ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆæ–°ã—ã„éƒ¨åˆ†ï¼‰
    if (insertedTask?.id) {
      try {
        console.log(`[${timestamp}] /api/slack/intake: Starting transcription task for ID: ${insertedTask.id}`);
        
        const startTaskResponse = await fetch(`${NEXT_PUBLIC_APP_URL}/api/start-task`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${WEBHOOK_SECRET}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ taskId: insertedTask.id }),
        });
        
        if (!startTaskResponse.ok) {
          const errorBody = await startTaskResponse.text();
          console.error(`[${timestamp}] /api/slack/intake: Failed to start transcription task. Status: ${startTaskResponse.status}, Body: ${errorBody}`);
          // ã‚¿ã‚¹ã‚¯é–‹å§‹ã«å¤±æ•—ã—ã¦ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¯æˆåŠŸã—ã¦ã„ã‚‹ã®ã§ã€è­¦å‘Šã¨ã—ã¦ç¶šè¡Œ
        } else {
          const startTaskResult = await startTaskResponse.json();
          console.log(`[${timestamp}] /api/slack/intake: Transcription task started. Result:`, startTaskResult);
        }
      } catch (startTaskError) {
        const errorMessage = startTaskError instanceof Error ? startTaskError.message : 'Unknown error starting task';
        console.error(`[${timestamp}] /api/slack/intake: Error starting transcription task:`, errorMessage);
        // ã‚¿ã‚¹ã‚¯é–‹å§‹ã«å¤±æ•—ã—ã¦ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¯æˆåŠŸã—ã¦ã„ã‚‹ã®ã§ã€è­¦å‘Šã¨ã—ã¦ç¶šè¡Œ
      }
    }

    return NextResponse.json({ message: 'Upload successful and task created', taskId: insertedTask?.id, storagePath });

  } catch (error) {
    // ã“ã®catchã¯ä¸»ã«äºˆæœŸã›ã¬å†…éƒ¨ã‚¨ãƒ©ãƒ¼ (ä¸Šè¨˜ã§å€‹åˆ¥ã«å‡¦ç†ã•ã‚Œãªã‹ã£ãŸã‚‚ã®) ã‚’æ•æ‰
    const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : 'Unknown internal server error';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(`[${timestamp}] /api/slack/intake: Unhandled internal error:`, errorMessage, errorStack, error);
    return NextResponse.json({ error: 'Internal server error', details: errorMessage }, { status: 500 });
  }
}




================================================================
End of Codebase
================================================================

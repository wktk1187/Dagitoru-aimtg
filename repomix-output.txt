This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
app/api/notion-sync/route.ts
app/api/slack/events/route.ts
app/api/slack/intake/route.ts
app/api/start-task/route.ts
app/api/summarize-task/route.ts
app/api/upload-url/route.ts
app/globals.css
app/lib/supabase-client.ts
app/scripts/upload-slack-file.ts
app/utils/slack-to-supabase-uploader.ts
cloudrun-transcriber/.dockerignore
cloudrun-transcriber/.gcloudignore
cloudrun-transcriber/Dockerfile
cloudrun-transcriber/index.js
cloudrun-transcriber/package.json
deno.lock
docs/slack_video_summary_spec_detailed.md
docs/testing-steps.md
next-env.d.ts
package.json
postcss.config.js
README.md
supabase/.branches/_current_branch
supabase/.temp/cli-latest
supabase/.temp/gotrue-version
supabase/.temp/pooler-url
supabase/.temp/postgres-version
supabase/.temp/project-ref
supabase/.temp/rest-version
supabase/.temp/storage-version
supabase/config.toml
supabase/deno.json
supabase/deno.lock
supabase/functions/process-video-task/.npmrc
supabase/functions/process-video-task/index.ts
supabase/functions/summarize_dispatch/index.ts
supabase/functions/transcribe_with_whisper/index.ts
supabase/functions/upload_file_to_storage/index.ts
supabase/migrations/20231105_create_upload_logs.sql
supabase/migrations/20250517181202_remote_schema.sql
supabase/migrations/20250517181203_create_transcription_task_trigger.sql
tailwind.config.js
tsconfig.json
vercel.json

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-rgb: 255, 255, 255;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
}

================
File: app/lib/supabase-client.ts
================
import { createClient } from '@supabase/supabase-js';

// Supabaseのクライアント初期化 (環境変数からURLとanonキーを取得)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error('Missing Supabase URL or anon key environment variables.');
}

// クライアント初期化
export const supabase = supabaseUrl && supabaseAnonKey 
  ? createClient(supabaseUrl, supabaseAnonKey) 
  : null;

// サービスロールクライアント (サーバーサイドのみで使用)
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

export const supabaseAdmin = supabaseUrl && supabaseServiceKey 
  ? createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false
      }
    }) 
  : null;

================
File: app/utils/slack-to-supabase-uploader.ts
================
import fetch from 'node-fetch';
import { Readable, Transform } from 'stream';
import { pipeline } from 'stream/promises';
import { supabaseAdmin as supabase } from '../lib/supabase-client';

// アップロードステータスのインターフェース
export interface UploadStatus {
  id: string;
  task_id?: string;
  file_name: string;
  storage_path: string;
  status: 'preparing' | 'uploading' | 'uploaded' | 'processing' | 'completed' | 'failed';
  content_type: string;
  file_size?: number;
  progress?: number;
  error_message?: string;
  metadata?: Record<string, any>;
  slack_file_id?: string;
  slack_download_url?: string;
  created_at?: Date;
  updated_at?: Date;
}

// アップロードオプションのインターフェース
export interface UploadOptions {
  slackFileUrl: string;
  slackToken: string;
  uploadEndpoint: string;
  webhookSecret: string;
  maxRetries?: number;
  logProgress?: boolean;
  metadata?: Record<string, any>;
}

/**
 * 進捗モニタリング用のTransformストリーム
 */
class ProgressTransform extends Transform {
  private transferred = 0;
  private lastProgressPercent = 0;
  private lastLogged = 0;

  constructor(
    private readonly total: number,
    private readonly onProgress: (transferred: number, total: number, percent: number) => void,
    private readonly logInterval = 262144 // 256KBごとにログ
  ) {
    super();
  }

  _transform(chunk: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {
    this.transferred += chunk.length;
    const percent = Math.floor((this.transferred / this.total) * 100);
    
    // ログ間隔またはプログレス変化で通知
    if (this.transferred - this.lastLogged >= this.logInterval || percent > this.lastProgressPercent) {
      this.onProgress(this.transferred, this.total, percent);
      this.lastLogged = this.transferred;
      this.lastProgressPercent = percent;
    }
    
    callback(null, chunk);
  }
}

/**
 * 指数バックオフによる自動リトライ関数
 */
async function retryWithBackoff<T>(
  fn: () => Promise<T>, 
  maxRetries: number = 3, 
  initialDelay: number = 1000,
  onRetry?: (attempt: number, delay: number, error: Error) => void
): Promise<T> {
  let lastError: Error | null = null;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      // 最後の試行ならエラーをスロー
      if (attempt === maxRetries - 1) {
        throw lastError;
      }
      
      // リトライ間隔を計算（指数バックオフ）
      const delay = initialDelay * Math.pow(2, attempt);
      
      if (onRetry) {
        onRetry(attempt + 1, delay, lastError);
      }
      
      // 待機
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // ここに到達することはないはずだが、TypeScriptの型安全性のため
  throw lastError || new Error('Unknown error during retry');
}

/**
 * Slackファイルを取得してSupabaseにアップロードするユーティリティ
 * プロダクションレベル実装 - 進捗監視、自動リトライ、ログ記録機能付き
 */
export async function uploadSlackFileToSupabase({
  slackFileUrl,
  slackToken,
  uploadEndpoint,
  webhookSecret,
  maxRetries = 3,
  logProgress = true,
  metadata = {}
}: UploadOptions): Promise<UploadStatus> {
  
  // 拡張子チェック - mp4のみ許可
  if (!slackFileUrl.endsWith('.mp4')) {
    throw new Error('Only .mp4 files are supported at this time');
  }
  
  // SlackのURLからファイル名部分を抽出
  const slackFileName = slackFileUrl.split('/').pop() || `slack_file_${Date.now()}.mp4`;
  
  // 一意のIDを生成（タスク追跡用）
  const uploadId = `upload_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  const fileName = `slack_${uploadId}.mp4`;
  
  // DBにステータスエントリ作成
  let uploadStatus: UploadStatus = {
    id: uploadId,
    file_name: fileName,
    storage_path: '',
    status: 'preparing',
    content_type: 'video/mp4',
    slack_file_id: slackFileUrl.includes('/') ? slackFileUrl.split('/').slice(-2)[0] : undefined,
    slack_download_url: slackFileUrl,
    metadata: {
      original_file_name: slackFileName,
      source: 'slack',
      ...metadata
    },
    created_at: new Date(),
    updated_at: new Date(),
  };
  
  // Supabaseテーブルに初期状態を記録
  await logToDatabase(uploadStatus);
  
  try {
    // 1. Slackファイルのヘッダー情報を取得（リトライ機能付き）
    const fileInfo = await retryWithBackoff(async () => {
      updateStatus('preparing', 'Checking file headers from Slack');
      
      const slackRes = await fetch(slackFileUrl, {
        method: 'HEAD',
        headers: {
          Authorization: `Bearer ${slackToken}`,
          'Accept': 'video/mp4',
        },
      });
      
      if (!slackRes.ok) {
        throw new Error(`Slack HEAD request failed (${slackRes.status}): ${slackRes.statusText}`);
      }
      
      // Content-Typeを確認（mp4であることを確認）
      const contentType = slackRes.headers.get('content-type');
      if (contentType && !contentType.includes('video/mp4')) {
        throw new Error(`Unsupported content type: ${contentType}. Only video/mp4 is supported.`);
      }
      
      return {
        contentType: contentType || 'video/mp4',
        contentLength: parseInt(slackRes.headers.get('content-length') || '0', 10)
      };
    }, maxRetries, 1000, (attempt, delay, error) => {
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for file header check: ${error.message}`);
    });
    
    // ファイルサイズを記録
    uploadStatus.file_size = fileInfo.contentLength;
    uploadStatus.content_type = fileInfo.contentType;
    await logToDatabase(uploadStatus);
    
    // 2. バックエンドから署名付きURL取得（リトライ機能付き）
    const { uploadUrl, storagePath } = await retryWithBackoff(async () => {
      updateStatus('preparing', 'Requesting upload URL');
      
      const uploadRes = await fetch(uploadEndpoint, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${webhookSecret}`
        },
        body: JSON.stringify({ 
          fileName, 
          contentType: 'video/mp4',
          metadata: {
            uploadId,
            source: 'slack',
            originalFileName: slackFileName
          }
        }),
      });
      
      if (!uploadRes.ok) {
        const errorData = await uploadRes.json().catch(() => ({ error: uploadRes.statusText }));
        throw new Error(`Upload URL error: ${errorData.error || 'Unknown error'}`);
      }
      
      const data = await uploadRes.json();
      if (!data.uploadUrl) {
        throw new Error('No upload URL returned from server');
      }
      
      return {
        uploadUrl: data.uploadUrl,
        storagePath: data.storagePath
      };
    }, maxRetries, 1000, (attempt, delay, error) => {
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for upload URL: ${error.message}`);
    });
    
    uploadStatus.storage_path = storagePath;
    await logToDatabase(uploadStatus);
    
    // 3. Slackからファイルをストリームダウンロードし、直接Supabaseへアップロード
    await retryWithBackoff(async () => {
      updateStatus('uploading', 'Downloading from Slack and uploading to storage');
      
      // Slackからのレスポンスストリーム取得
      const slackRes = await fetch(slackFileUrl, {
        headers: {
          Authorization: `Bearer ${slackToken}`,
          'Accept': 'video/mp4',
        },
      });
      
      if (!slackRes.ok) {
        throw new Error(`Slack fetch failed (${slackRes.status}): ${slackRes.statusText}`);
      }
      
      // ※理想的にはここでストリームを使うが、node-fetchの制約により簡略化
      const fileBuffer = await slackRes.buffer();
      
      // 進捗更新コールバック
      const updateProgressCallback = (transferred: number, total: number, percent: number) => {
        if (logProgress) {
          console.log(`[${new Date().toISOString()}] Progress: ${percent}% (${transferred}/${total} bytes)`);
        }
        
        // 10%ごとにDBアップデート
        if (percent % 10 === 0 || percent === 100) {
          uploadStatus.progress = percent;
          logToDatabase(uploadStatus).catch(console.error);
        }
      };
      
      // ストリーム作成と進捗処理（実際のストリーム実装の場合）
      /*
      const downloadStream = Readable.from(slackRes.body);
      const progressStream = new ProgressTransform(
        uploadStatus.file_size || 0,
        updateProgressCallback
      );
      */
      
      // サイズをトラッキング（ストリームの場合はProgressTransformを使う）
      let transferred = 0;
      const total = uploadStatus.file_size || fileBuffer.length;
            
      // PUTリクエストでアップロード
      const putRes = await fetch(uploadUrl, {
        method: 'PUT',
        headers: { 'Content-Type': 'video/mp4' },
        body: fileBuffer,
      });
      
      // 進捗を100%として更新
      updateProgressCallback(total, total, 100);
      
      if (!putRes.ok) {
        const errorText = await putRes.text().catch(() => putRes.statusText);
        throw new Error(`Upload failed (${putRes.status}): ${errorText}`);
      }
      
      updateStatus('uploaded', 'File successfully uploaded');
      
      return true;
    }, maxRetries, 1000, (attempt, delay, error) => {
      updateStatus('uploading', `Retry ${attempt}/${maxRetries} after ${delay}ms: ${error.message}`);
      console.warn(`[${new Date().toISOString()}] Retry ${attempt}/${maxRetries} after ${delay}ms for upload: ${error.message}`);
    });
    
    // 最終ステータス更新 - 処理待ち状態に
    updateStatus('processing', 'Awaiting transcription processing');
    
    return uploadStatus;
    
  } catch (err) {
    // エラー発生時
    const errorMessage = err instanceof Error ? err.message : String(err);
    console.error(`[${new Date().toISOString()}] ❌ Upload failed:`, errorMessage);
    
    uploadStatus.status = 'failed';
    uploadStatus.error_message = errorMessage;
    uploadStatus.updated_at = new Date();
    await logToDatabase(uploadStatus);
    
    throw err;
  }
  
  // 内部関数: ステータス更新
  async function updateStatus(status: UploadStatus['status'], message?: string) {
    uploadStatus.status = status;
    uploadStatus.updated_at = new Date();
    if (message) {
      uploadStatus.metadata = { ...uploadStatus.metadata, lastMessage: message, lastUpdated: new Date().toISOString() };
    }
    await logToDatabase(uploadStatus);
    console.log(`[${new Date().toISOString()}] Status updated to '${status}'${message ? `: ${message}` : ''}`);
  }
  
  // 内部関数: データベースにログ記録
  async function logToDatabase(status: UploadStatus) {
    try {
      if (!supabase) {
        console.warn('[Upload Logger] Supabase client not available, skipping log.');
        return;
      }
      
      const { error } = await supabase
        .from('upload_logs')
        .upsert({
          id: status.id,
          task_id: status.task_id,
          file_name: status.file_name,
          storage_path: status.storage_path,
          status: status.status,
          content_type: status.content_type,
          file_size: status.file_size,
          progress: status.progress,
          error_message: status.error_message,
          metadata: status.metadata,
          slack_file_id: status.slack_file_id,
          slack_download_url: status.slack_download_url,
          // created_at と updated_at はDBのデフォルト値と更新トリガーに任せる
        }, { onConflict: 'id' });
      
      if (error) {
        console.warn(`[${new Date().toISOString()}] Failed to log upload status:`, error);
      }
    } catch (e) {
      console.warn(`[${new Date().toISOString()}] Error logging to database:`, e);
      // ログ記録失敗はクリティカルエラーとして扱わない（メイン処理は継続）
    }
  }
}

================
File: cloudrun-transcriber/.dockerignore
================
# Node.js dependencies from parent dir
../node_modules/
# Dependencies will be installed inside the container
node_modules/

# .git directory
.git/

# Logs
npm-debug.log
yarn-debug.log
yarn-error.log

# dotenv files
../.env
../.env.local
.env
.env.local
.env.example

# Env and config files
gcp_creds.json
.deno_cache/

# Test files
*.test.*
repomix-output.txt

# Video files
*.mp4
*.webm
*.mov
*.mp3

# Remove node_modules from the list
node_modules

================
File: cloudrun-transcriber/.gcloudignore
================
# Default gcloudignore from https://sdk.cloud.google.com/gcloud/reference/topic/gcloudignore
# Lines starting with '#' are comments.
# Affects 'gcloud run deploy --source .' and other gcloud commands.

.gcloudignore
# If you would like to upload your .git directory, .gitignore file or
# files from your .gitignore file, remove the corresponding line
# below:
.git
.gitignore

# Node.js dependencies:
node_modules/

# Specific to this project:
.deno_cache/
*.log
*.test.*
repomix-output.txt

# Sensitive files (if deployment context is not carefully managed)
# These are usually handled by placing .gcloudignore at the repo root
# but added here for explicitness if running deploy from within cloudrun-transcriber
# .env
# .env.local
# .env.example
# service-account.json

================
File: cloudrun-transcriber/Dockerfile
================
FROM node:18-slim

WORKDIR /app
COPY . .

RUN npm install

ENV PATH="/app/node_modules/ffmpeg-static:${PATH}"

CMD ["node", "index.js"]

================
File: cloudrun-transcriber/package.json
================
{
  "name": "cloudrun-transcriber",
  "version": "1.0.0",
  "main": "index.js",
  "type": "commonjs",
  "dependencies": {
    "@google-cloud/storage": "^6.9.0",
    "@google-cloud/speech": "^5.4.0",
    "node-fetch": "^2.6.7",
    "fluent-ffmpeg": "^2.1.2",
    "ffmpeg-static": "^4.4.0",
    "express": "^4.18.2",
    "dotenv": "^16.3.1"
  }
}

================
File: docs/slack_video_summary_spec_detailed.md
================
# 詳細仕様書：Slack動画要約ボット

## 🛠 使用技術・サービス詳細

| 項目       | 技術/サービス                         | 備考 |
|------------|----------------------------------------|------|
| 動画送信元   | Slack Bot                            | Events API, `file_shared` イベント使用 |
| Webhook受信 | Vercel (Next.js API Routes)          | 認証不要で簡便、Slack署名検証あり |
| ストレージ   | Supabase Storage                     | `uploadFromUrl`を利用 |
| 音声認識     | Whisper（Python）                    | `base` or `medium` モデル推奨 |
| 要約        | Gemini API (Generative Language API) | Gemini 1.5 Pro または Gemini 1.0 |
| 通知/登録先 | Slack API / Notion API               | 要約結果を通知 or 永続化保存 |

---

## 📂 ストレージ設計（Supabase）

| パス                            | 内容                     |
|---------------------------------|--------------------------|
| `/uploads/{uuid}.mp4`           | Slackから取得した元動画 |
| `/transcripts/{uuid}.txt`       | Whisperによる文字起こし |
| `/summaries/{uuid}.md`          | Gemini要約文             |

---

## 🔄 各処理詳細

### 1. Slack Webhook受信
- `@slack/events-api` で `file_shared` を受信
- Slackファイルメタ情報 (`url_private`, `id`, `name`) を取得
- Slack Bot Token による認証DL（Bearer Token）

### 2. Supabase Storageアップロード
- Vercel内で `fetch()` によりSlackから動画DL
- `supabase.storage.from().upload()` で `/uploads/{uuid}` に保存
- 成功時、UUIDでファイルIDを返却・ログ出力

### 3. Whisper（Python）による文字起こし
- Supabaseの `/uploads/*.mp4` をDL
- Whisperで `.mp4` を `.txt` に変換
- ファイル出力 `/transcripts/{uuid}.txt`
- Whisperエラー時はログ + Slack通知

### 4. Gemini APIによる要約
- Whisper出力（最大8000字）をプロンプトに挿入
- Gemini呼び出し用JSON構造を組み立て
- `/summaries/{uuid}.md` に出力

### 5. Slack通知 or Notion登録
- Slack: `chat.postMessage` で通知（ファイル名 + 要約 + GCSリンク）
- Notion: `pages.create()` で要約結果をDBに追加

---

## ✅ 完了要件（精緻化）

| 項目 | 完了条件 |
|------|----------|
| Slack Webhook連携 | `file_shared` イベントを正しく受信し、ファイルメタデータを取得できる |
| 動画保存           | Slackの `url_private` から動画を取得し、Supabaseに保存できる（UUID命名） |
| Whisper処理        | 保存動画を正確に文字起こしし、最大誤差5%以内で出力可能 |
| Gemini要約         | Geminiでの要約結果が最低70%以上の精度で概要を捉えている |
| Slack通知           | 要約文をSlackに送信、リンクが有効であること |
| Notion登録          | タイトル/本文形式でDBに登録。文字起こし全文リンク付き |
| エラーハンドリング  | DL・変換・APIエラー発生時にSlackでアラートが飛ぶ |
| CLI再処理           | UUID指定で再度Whisper + 要約処理が可能なCLIスクリプト存在 |
| ログ記録           | 各工程のログが Supabase Functions または Vercel Log に残ること |

---

## 🧪 テスト項目（抜粋）

- [ ] Slack でファイル共有 → webhook 発火を確認
- [ ] Supabase に動画保存確認（サイズ1.5GBまで対応）
- [ ] Whisper により正確に文字起こしされる
- [ ] Gemini で要約が返る（3文以上で意味が通る）
- [ ] Slack/Notion に通知・登録できる

## 機能要件

## 非機能要件

## システム構成図

## API仕様

### Slack Events API 受信エンドポイント

## データモデル

================
File: docs/testing-steps.md
================
# 文字起こしパイプライン検証手順書

この文書では、Slack→Vercel→Supabase→Cloud Run→Vercelの文字起こしパイプラインが正しく機能しているか確認するための手順を説明します。

## 前提条件

- 必要な環境変数がすべて設定されていること
  - NEXT_PUBLIC_SUPABASE_URL
  - NEXT_PUBLIC_SUPABASE_ANON_KEY
  - SUPABASE_SERVICE_ROLE_KEY
  - SLACK_BOT_TOKEN
  - WEBHOOK_SECRET
  - NEXT_PUBLIC_APP_URL
  - CLOUD_RUN_TRANSCRIBE_URL
  - GCS_BUCKET
  - SUMMARIZE_TASK_ENDPOINT
  - GEMINI_API_KEY (要約用)

## 検証手順

### 1. 全体フローの確認

#### フェーズ1: Slack → Vercel → Supabase

1. Slackで`/transcribe`コマンドまたは動画ファイルをアップロード
2. Vercelのログを確認:
   - `/api/slack/intake`のログで、リクエストが受信されていることを確認
   - Supabaseへのファイルアップロードが成功していることを確認
   - `transcription_tasks`テーブルへのタスク追加が成功していることを確認
   - `/api/start-task`の呼び出しが成功していることを確認

#### フェーズ2: Vercel → Cloud Run

3. `/api/start-task`のログを確認:
   - タスクの取得が成功していることを確認
   - 署名付きURL取得が成功していることを確認
   - Cloud Runへのリクエスト送信が成功していることを確認

4. Google Cloud Consoleで Cloud Run のログを確認:
   - Cloud Runサービスへのリクエストが到達していることを確認
   - ログに`req.body:`として、送信したペイロードが表示されていることを確認
   - 文字起こしプロセスが開始されていることを確認

#### フェーズ3: Cloud Run → Vercel (要約)

5. 文字起こし完了後、Cloud Runから`/api/summarize-task`へのPOSTリクエストが送信されていることを確認
6. `/api/summarize-task`のログを確認:
   - リクエストが受信されていることを確認
   - transcriptが正しく受け取られていることを確認
   - Geminiでの要約処理が開始されていることを確認

#### フェーズ4: 最終確認

7. Supabaseのデータベースを確認:
   - `transcription_tasks`テーブルで、タスクのステータスが`completed`になっていることを確認
   - `final_summary`フィールドに要約結果が格納されていることを確認

## エラーケースと調査方法

### Slack → Vercel (フェーズ1)でのエラー

- Slackコマンドが応答しない:
  - Slackアプリの設定を確認
  - Vercelのデプロイ状態を確認
  - `/api/slack/intake`のURLが正しく設定されているか確認

- ファイルアップロードに失敗:
  - Vercelのログを確認
  - Supabaseの接続設定を確認
  - Supabaseのストレージバケット設定を確認

### Vercel → Cloud Run (フェーズ2)でのエラー

- Cloud Runへのリクエストが失敗:
  - `CLOUD_RUN_TRANSCRIBE_URL`環境変数が正しく設定されているか確認
  - Cloud Runサービスが起動しているか確認
  - Cloud Runのログでエラーを確認
  - 権限設定に問題がないか確認

### Cloud Run → Vercel (フェーズ3)でのエラー

- 要約リクエストが失敗:
  - Cloud Runの`SUMMARIZE_TASK_ENDPOINT`環境変数が正しく設定されているか確認
  - Cloud Runのログでエラーを確認
  - `/api/summarize-task`エンドポイントが正しく機能しているか確認

## ログ調査のポイント

- Vercelのログ:
  - ダッシュボード > プロジェクト > Deployments > 最新のデプロイメント > Logs
  - タイムスタンプで時系列を確認
  - `/api/slack/intake`、`/api/start-task`、`/api/summarize-task`の各エンドポイントのログを確認

- Cloud Runのログ:
  - Google Cloud Console > Cloud Run > transcriber-service > ログ
  - リクエスト受信、ファイル処理、レスポンス送信の各ステップを確認

- Supabaseのデータ:
  - Supabaseダッシュボード > テーブルエディタ > transcription_tasks
  - タスクのステータス変化を確認
  - エラーメッセージが記録されている場合は確認

## テストコマンド

サンプルビデオを使ってテストする場合:

```bash
# 開発環境のテスト
npm run dev:webhook
npm run upload-slack -- <slack-file-url>
```

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: supabase/.branches/_current_branch
================
main

================
File: supabase/.temp/cli-latest
================
v2.22.12

================
File: supabase/.temp/gotrue-version
================
v2.172.1

================
File: supabase/.temp/pooler-url
================
postgresql://postgres.tqeprgfaybkvknmzeraj:[YOUR-PASSWORD]@aws-0-ap-northeast-1.pooler.supabase.com:6543/postgres

================
File: supabase/.temp/postgres-version
================
15.8.1.085

================
File: supabase/.temp/project-ref
================
tqeprgfaybkvknmzeraj

================
File: supabase/.temp/rest-version
================
v12.2.3

================
File: supabase/.temp/storage-version
================
custom-metadata

================
File: supabase/deno.json
================
{
  "compilerOptions": {
    "lib": ["deno.ns", "dom"],
    "strict": true
  },
  "lock": "deno.lock",
  "tasks": {
    "dev": "supabase functions serve --env-file ../.env.local --config ./config.toml"
  }
}

================
File: supabase/deno.lock
================
{
  "version": "3",
  "remote": {
    "https://deno.land/std@0.177.0/http/server.ts": "cbb17b594651215ba95c01a395700684e569c165a567e4e04bba327f41197433",
    "https://esm.sh/@supabase/supabase-js@2": "5975c1df8b2c6c0e865b79f1a17093fb4389f96dea159aa52fd60fe534b81ed6"
  }
}

================
File: supabase/functions/process-video-task/.npmrc
================
# Configuration for private npm package dependencies
# For more information on using private registries with Edge Functions, see:
# https://supabase.com/docs/guides/functions/import-maps#importing-from-private-registries

================
File: supabase/functions/summarize_dispatch/index.ts
================
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

// これらの環境変数はSupabaseプロジェクトのEdge Function設定で定義する必要があります
const VERCEL_SUMMARIZE_WEBHOOK_URL = Deno.env.get("VERCEL_SUMMARIZE_WEBHOOK_URL")!;
const WEBHOOK_SECRET = Deno.env.get("WEBHOOK_SECRET")!;

console.log("Function summarize_dispatch initialized.");
console.log(`VERCEL_SUMMARIZE_WEBHOOK_URL: ${VERCEL_SUMMARIZE_WEBHOOK_URL ? 'Loaded' : 'NOT LOADED'}`);
console.log(`WEBHOOK_SECRET: ${WEBHOOK_SECRET ? 'Loaded' : 'NOT LOADED'}`);

serve(async (req: Request) => {
  console.log("[summarize_dispatch] Received request");

  if (req.method !== "POST") {
    console.log(`[summarize_dispatch] Method Not Allowed: ${req.method}`);
    return new Response("Method Not Allowed", { status: 405 });
  }

  try {
    const payload = await req.json();
    // DBトリガーからのペイロード構造を想定 (record, old_record, type, table, schema)
    // 特に、payload.recordに必要な情報が含まれているか確認
    const record = payload.record;
    console.log("[summarize_dispatch] Payload received:", JSON.stringify(record, null, 2));

    if (!record || !record.id || record.transcription_result === undefined || record.transcription_result === null) {
      console.error("[summarize_dispatch] Invalid payload: Missing id or transcription_result", record);
      return new Response("Invalid payload: Missing id or transcription_result", { status: 400 });
    }

    const taskId = record.id as string;
    const transcriptionText = record.transcription_result as string;

    console.log(`[summarize_dispatch] Processing task: ${taskId}`);

    if (!VERCEL_SUMMARIZE_WEBHOOK_URL || !WEBHOOK_SECRET) {
      console.error("[summarize_dispatch] Environment variables VERCEL_SUMMARIZE_WEBHOOK_URL or WEBHOOK_SECRET are not set.");
      return new Response("Internal Server Error: Webhook URL or Secret not configured", { status: 500 });
    }

    const response = await fetch(VERCEL_SUMMARIZE_WEBHOOK_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${WEBHOOK_SECRET}`, // Vercel側でこのSecretを検証
      },
      body: JSON.stringify({ taskId, transcriptionText }),
    });

    const responseText = await response.text(); // レスポンスボディを先に取得
    console.log(`[summarize_dispatch] Vercel webhook response for task ${taskId}: ${response.status} ${responseText}`);

    if (!response.ok) {
      // Vercelからのエラーレスポンスをそのまま返すか、あるいは特定の処理を行う
      return new Response(`Vercel API call failed: ${response.status} ${responseText}`, {
        status: response.status, // Vercelのステータスを中継
        headers: { 'Content-Type': 'application/json' } // 必要に応じて
      }); 
    }

    // Vercel APIが成功した場合 (2xxレスポンス)
    // 通常、このFunctionはVercelへのディスパッチが成功すれば200を返す
    return new Response(JSON.stringify({ message: "Successfully dispatched to Vercel for summarization", taskId, vercelResponse: responseText }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });

  } catch (e) {
    const error = e as Error; // Type assertion
    console.error("[summarize_dispatch] Error processing request:", error);
    return new Response(JSON.stringify({ error: error.message || 'An unknown error occurred' }), { status: 500 });
  }
});

================
File: supabase/functions/transcribe_with_whisper/index.ts
================
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";

// 環境変数からSupabaseの情報を取得
const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
// const supabaseAnonKey = Deno.env.get("SUPABASE_ANON_KEY")!;
const supabaseServiceRoleKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const openaiApiKey = Deno.env.get("OPENAI_API_KEY")!;

interface TaskPayloadRecord {
  id: string;
  storage_path: string;
  status?: string; // old_record には status がある想定
  // 他のtaskのプロパティも必要に応じて追加
}
interface TaskPayload {
  type: "UPDATE";
  table: string;
  schema: string;
  record: TaskPayloadRecord;
  old_record: TaskPayloadRecord;
}

async function updateTaskStatus(supabase: SupabaseClient, taskId: string, status: string, transcription_result?: string) {
  const updateData: { status: string; transcription_result?: string; updated_at: string } = {
    status,
    updated_at: new Date().toISOString(),
  };
  if (transcription_result) {
    updateData.transcription_result = transcription_result;
  }

  const { error: updateError } = await supabase
    .from("transcription_tasks")
    .update(updateData)
    .eq("id", taskId);

  if (updateError) {
    console.error(`Error updating task ${taskId} to status ${status}:`, updateError);
  } else {
    console.log(`Task ${taskId} status successfully updated to ${status}.`);
  }
}

serve(async (req: Request) => {
  console.log("Function transcribe_with_whisper called");

  if (req.method !== "POST") {
    return new Response("Method Not Allowed", { status: 405 });
  }

  let taskIdForErrorHandling: string | undefined;

  try {
    const payload: TaskPayload = await req.json();
    console.log("Received payload:", JSON.stringify(payload, null, 2));

    const { id: taskId, storage_path: storagePath } = payload.record;
    taskIdForErrorHandling = taskId; // エラーハンドリング用に保持

    if (!taskId || !storagePath) {
      console.error("Missing taskId or storage_path in payload");
      return new Response("Missing taskId or storage_path", { status: 400 });
    }

    console.log(`Processing task ID: ${taskId}, Storage Path: ${storagePath}`);

    // const supabase = createClient(supabaseUrl, supabaseAnonKey, {
    const supabase = createClient(supabaseUrl, supabaseServiceRoleKey, {
      global: {
        // headers: { Authorization: `Bearer ${supabaseAnonKey}` }, 
        headers: { Authorization: `Bearer ${supabaseServiceRoleKey}` },
      },
    });

    // 1. Supabase Storageからファイルを取得 (ArrayBuffer)
    console.log(`Fetching file from Supabase Storage: ${storagePath}`);
    const { data: fileData, error: downloadError } = await supabase.storage
      .from("videos") // tasksテーブルのstorage_pathに合わせてバケット名を指定
      .download(storagePath);

    if (downloadError || !fileData) {
      console.error("Error downloading file:", downloadError);
      await updateTaskStatus(supabase, taskId, "transcribe_failed", `Error downloading file: ${downloadError?.message}`);
      return new Response(`Failed to download file: ${downloadError?.message}`, { status: 500 });
    }
    console.log("File downloaded successfully.");
    const fileArrayBuffer = await fileData.arrayBuffer();

    // 2. FormDataの構築 (Denoでの対応)
    const { File } = await import("https://deno.land/x/formdata_polyfill@v4.0.12/mod.ts");

    // 1. ファイル名とMIMEタイプ推定
    const fileName = storagePath.split("/").pop() || "audio.unknown"; // デフォルトファイル名を設定
    const getMimeType = (name: string): string => {
      if (name.endsWith(".mp3")) return "audio/mpeg";
      if (name.endsWith(".mp4")) return "video/mp4"; // Whisperはmp4も可
      if (name.endsWith(".mpeg")) return "video/mpeg";
      if (name.endsWith(".mpga")) return "audio/mpeg";
      if (name.endsWith(".m4a")) return "audio/mp4";
      if (name.endsWith(".wav")) return "audio/wav";
      if (name.endsWith(".webm")) return "video/webm";
      // 必要に応じて他のMIMEタイプを追加
      console.warn(`Unknown file type for ${name}, defaulting to application/octet-stream`);
      return "application/octet-stream"; // 不明な場合は汎用的なMIMEタイプ
    };
    const mimeType = getMimeType(fileName);
    console.log(`Determined fileName: ${fileName}, mimeType: ${mimeType}`);

    // 2. Fileオブジェクトの作成
    const file = new File([fileArrayBuffer], fileName, { type: mimeType });

    // 3. FormDataの構築
    const formData = new FormData();
    formData.append("file", file);
    formData.append("model", "whisper-1");
    // formData.append("language", "ja"); // 必要に応じて言語指定
    // formData.append("prompt", "こんにちは。"); // 必要に応じてプロンプト追加
    // formData.append("response_format", "json"); // verbose_jsonやsrtなども指定可能
    // formData.append("temperature", "0"); // 0-1で指定、高いほどランダム

    console.log("FormData constructed successfully.");


    // 3. OpenAI Whisper APIに送信
    console.log(`Sending data to OpenAI Whisper API for task: ${taskId}`);
    const whisperApiUrl = "https://api.openai.com/v1/audio/transcriptions";
    
    let whisperResponse;
    try {
      whisperResponse = await fetch(whisperApiUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${openaiApiKey}`,
          // 'Content-Type': 'multipart/form-data' はfetchが自動で設定する (boundary含む)
        },
        body: formData,
      });
    } catch (e) {
      const fetchError = e as Error; // 型アサーション
      console.error(`[${taskId}] Fetch error calling Whisper API:`, fetchError);
      await updateTaskStatus(supabase, taskId, "transcribe_failed", `Fetch error: ${fetchError.message ? fetchError.message.slice(0,300) : 'Unknown fetch error'}`);
      return new Response(`Whisper API fetch error: ${fetchError.message || 'Unknown fetch error'}`, { status: 500 });
    }
    

    if (!whisperResponse.ok) {
      const errorText = await whisperResponse.text();
      console.error(`[${taskId}] Whisper API Error: ${whisperResponse.status}`, errorText);
      // エラーメッセージが長すぎる場合があるので、DBには一部を保存
      const dbErrorMessage = `Whisper API Error ${whisperResponse.status}: ${errorText.slice(0, 250)}`;
      await updateTaskStatus(supabase, taskId, "transcribe_failed", dbErrorMessage);
      return new Response(`Whisper API failed: ${errorText}`, { status: whisperResponse.status });
    }

    const result = await whisperResponse.json();
    const transcribedText = result.text || ""; // APIレスポンスにtextフィールドが存在しない場合も考慮
    
    if (typeof transcribedText !== 'string' || transcribedText.trim() === "") {
        console.warn(`[${taskId}] Whisper API returned empty or invalid text. Result:`, JSON.stringify(result));
        await updateTaskStatus(supabase, taskId, "transcribe_failed", "Whisper API returned empty or invalid text.");
        return new Response("Whisper API returned empty or invalid text.", { status: 500 });
    }

    console.log(`[${taskId}] Transcription success (first 100 chars):`, transcribedText.slice(0, 100));

    // 4. タスクを更新 (transcription_result と status)
    await updateTaskStatus(supabase, taskId, "transcribed", transcribedText);
    console.log(`Task ${taskId} status updated to transcribed.`);

    return new Response(JSON.stringify({ message: "Transcription successful", taskId, transcribedText: transcribedText.slice(0,100) + "..." }), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });

  } catch (e) {
    const error = e as Error;
    console.error("Error in function:", error);
    if (taskIdForErrorHandling) {
      // const supabase = createClient(supabaseUrl, supabaseAnonKey); // 再初期化
      const supabase = createClient(supabaseUrl, supabaseServiceRoleKey); // 再初期化時もservice_role_keyを使用
      await updateTaskStatus(supabase, taskIdForErrorHandling, "transcribe_failed", `Function error: ${error.message}`);
    }
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
});

================
File: supabase/migrations/20250517181202_remote_schema.sql
================
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."transcription_tasks" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "storage_path" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "original_file_name" "text",
    "transcript_path" "text",
    "summary_path" "text",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transcription_tasks_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);


ALTER TABLE "public"."transcription_tasks" OWNER TO "postgres";


COMMENT ON TABLE "public"."transcription_tasks" IS 'Stores tasks for video transcription and summarization, including status and paths to generated files.';



COMMENT ON COLUMN "public"."transcription_tasks"."id" IS 'Primary key, unique identifier for the task (UUID).';



COMMENT ON COLUMN "public"."transcription_tasks"."storage_path" IS 'Full path to the original video file in Supabase Storage (e.g., uploads/uuid.mp4). Provided by the webhook.';



COMMENT ON COLUMN "public"."transcription_tasks"."status" IS 'Current status of the transcription task (e.g., pending, processing, completed, failed).';



COMMENT ON COLUMN "public"."transcription_tasks"."original_file_name" IS 'Original name of the file as uploaded from Slack.';



COMMENT ON COLUMN "public"."transcription_tasks"."transcript_path" IS 'Path to the generated transcript text file in Supabase Storage.';



COMMENT ON COLUMN "public"."transcription_tasks"."summary_path" IS 'Path to the generated summary markdown file in Supabase Storage.';



COMMENT ON COLUMN "public"."transcription_tasks"."error_message" IS 'Stores any error message if the task processing failed.';



COMMENT ON COLUMN "public"."transcription_tasks"."created_at" IS 'Timestamp indicating when the task record was created.';



COMMENT ON COLUMN "public"."transcription_tasks"."updated_at" IS 'Timestamp indicating when the task record was last updated (automatically managed by a trigger).';



ALTER TABLE ONLY "public"."transcription_tasks"
    ADD CONSTRAINT "transcription_tasks_pkey" PRIMARY KEY ("id");



CREATE INDEX "idx_transcription_tasks_created_at" ON "public"."transcription_tasks" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_transcription_tasks_status" ON "public"."transcription_tasks" USING "btree" ("status");



CREATE OR REPLACE TRIGGER "update_transcription_tasks_updated_at" BEFORE UPDATE ON "public"."transcription_tasks" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE POLICY "Allow full access for service_role" ON "public"."transcription_tasks" USING (true) WITH CHECK (true);



ALTER TABLE "public"."transcription_tasks" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";











































































































































































GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";


















GRANT ALL ON TABLE "public"."transcription_tasks" TO "anon";
GRANT ALL ON TABLE "public"."transcription_tasks" TO "authenticated";
GRANT ALL ON TABLE "public"."transcription_tasks" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;

================
File: supabase/migrations/20250517181203_create_transcription_task_trigger.sql
================
-- pg_net 拡張機能が有効になっていることを確認 (マイグレーションの最初の方で一度だけ実行すればよい)
-- create extension if not exists pg_net with schema extensions;

-- トリガー関数を作成
create or replace function public.handle_new_transcription_task()
returns trigger
language plpgsql
security definer -- FunctionがDB操作等で昇格された権限を必要とする場合
as $$
begin
  perform net.http_post(
    url:='http://127.0.0.1:54321/functions/v1/process-video-task', -- ローカルSupabase Functionのエンドポイント
    body:=jsonb_build_object( -- jsonb型でpayloadを構築
      'type', TG_OP,
      'table', TG_TABLE_NAME,
      'schema', TG_TABLE_SCHEMA,
      'record', row_to_json(new)
      -- 'old_record' はINSERT時には不要なので省略も可
    ),
    headers:=jsonb_build_object( -- jsonb型でヘッダーを構築
      'Content-Type', 'application/json',
      'Authorization', 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0'
    )
  );
  return new;
end;
$$;

-- transcription_tasks テーブルにトリガーを設定
create trigger on_new_transcription_task
  after insert on public.transcription_tasks
  for each row execute procedure public.handle_new_transcription_task();

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: '#0070f3',
      },
    },
  },
  plugins: [],
}

================
File: app/api/summarize-task/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { GoogleGenerativeAI } from '@google/generative-ai';

// --- 環境変数 -----------------------------------------------------------------
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY; // DB更新用にService Role Keyを推奨
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const NEXT_PUBLIC_APP_URL = process.env.NEXT_PUBLIC_APP_URL;

// --- 定数 -------------------------------------------------------------------
const MAX_TRANSCRIPT_TOKENS = 15000; // 仮の値。実際のGeminiのモデルに合わせて調整。

// --- Supabase クライアント初期化 -----------------------------------------------
let supabase: SupabaseClient | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
    auth: {
      persistSession: false, // サーバーサイドの処理なのでセッション永続化は不要
      autoRefreshToken: false, // 自動トークンリフレッシュも不要
    }
  });
} else {
  console.error('[summarize-task/route.ts] Missing Supabase URL or Service Role Key env vars.');
}

// --- Gemini クライアント初期化 -------------------------------------------------
let genAI: GoogleGenerativeAI | null = null;
if (GEMINI_API_KEY) {
  genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
} else {
  console.error('[summarize-task/route.ts] Missing GEMINI_API_KEY env var.');
}

// --- 型定義 -------------------------------------------------------------------
interface SummarizeTaskPayload {
  taskId: string;
  transcript: string;
  // metadataはSupabaseから取得するので、リクエストペイロードには含めない設計とします。
  // もし呼び出し元がmetadataを渡す場合は、ここの型定義と処理を変更する必要があります。
}

interface TaskMetadata {
  consultant_name?: string;
  company_name?: string;
  company_type?: string;
  company_problem?: string;
  meeting_date?: string;
  meeting_count?: string | number; // DBの型に合わせて調整
  meeting_type?: string;
  support_area?: string;
  // company_phase, internal_sharing_items も必要に応じて追加
}

// --- メイン処理 -----------------------------------------------------------------
export async function POST(request: NextRequest) {
  console.log(`[${new Date().toISOString()}] /api/summarize-task: POST request received.`);

  // 1. 認可チェック (WEBHOOK_SECRET)
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET || !authHeader || !authHeader.startsWith('Bearer ') || authHeader.substring(7) !== WEBHOOK_SECRET) {
    console.warn(`[${new Date().toISOString()}] /api/summarize-task: Unauthorized access attempt.`);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  console.log(`[${new Date().toISOString()}] /api/summarize-task: Authorization successful.`);

  // 2. SupabaseクライアントとGeminiクライアントの利用可能性チェック
  if (!supabase) {
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Supabase client is not initialized.`);
    return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
  }
  // Geminiクライアントは後続のフェーズでチェックするが、ここでも存在確認は可能
  if (!genAI) {
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Gemini AI client is not initialized.`);
    return NextResponse.json({ error: 'Server configuration error: Gemini AI client not available.' }, { status: 500 });
  }

  // 3. リクエストボディのパース
  let payload: SummarizeTaskPayload;
  try {
    payload = await request.json();
    if (!payload.taskId || typeof payload.taskId !== 'string' || !payload.transcript || typeof payload.transcript !== 'string') {
      throw new Error('Invalid request body: taskId and transcript are required and must be strings.');
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error parsing request body.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error parsing request body: ${errorMessage}`);
    return NextResponse.json({ error: 'Invalid request body', details: errorMessage }, { status: 400 });
  }
  const { taskId, transcript } = payload;
  console.log(`[${new Date().toISOString()}] /api/summarize-task: Parsed request for taskId: ${taskId}`);

  // 4. Supabaseからタスクのメタ情報を取得
  let taskMeta: TaskMetadata | null = null;
  try {
    const { data: metaData, error: metaError } = await supabase
      .from('transcription_tasks')
      .select('consultant_name, company_name, company_type, company_problem, meeting_date, meeting_count, meeting_type, support_area')
      .eq('id', taskId)
      .single();

    if (metaError) {
      if (metaError.code === 'PGRST116') { // PostgREST error code for "Not found"
        console.warn(`[${new Date().toISOString()}] /api/summarize-task: Task not found in DB for taskId: ${taskId}`);
        return NextResponse.json({ error: 'Task not found' }, { status: 404 });
      }
      throw metaError; // その他のDBエラー
    }
    taskMeta = metaData;
    console.log(`[${new Date().toISOString()}] /api/summarize-task: Successfully fetched metadata for taskId ${taskId}:`, taskMeta);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown DB error.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error fetching metadata from DB for taskId ${taskId}: ${errorMessage}`);
    return NextResponse.json({ error: 'Failed to fetch task metadata', details: errorMessage }, { status: 500 });
  }

  // 5. タスクステータスを 'summarizing' に更新
  try {
    const { error: updateError } = await supabase
      .from('transcription_tasks')
      .update({ status: 'summarizing', updated_at: new Date().toISOString() })
      .eq('id', taskId);

    if (updateError) {
      throw updateError;
    }
    console.log(`[${new Date().toISOString()}] /api/summarize-task: Successfully updated status to 'summarizing' for taskId: ${taskId}`);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown DB error during status update.';
    console.error(`[${new Date().toISOString()}] /api/summarize-task: Error updating status to summarizing for taskId ${taskId}: ${errorMessage}`);
    // ここでリターンしても良いが、後続の処理でエラーが発生した場合の最終的なステータス更新もあるため、一旦処理を続けることも考えられる。
    // ただし、致命的な場合はリターンすべき。
    return NextResponse.json({ error: 'Failed to update task status', details: errorMessage }, { status: 500 });
  }

  // --- ここまでが初弾 --- 
  // この後、トランスクリプトの前処理、Gemini Phase 1-4の実行、結果保存、最終ステータス更新が続く

  console.log(`[${new Date().toISOString()}] /api/summarize-task: Initial processing complete for taskId: ${taskId}. Transcript length: ${transcript.length}`);
  console.log("Task Metadata:", taskMeta);

  // -------- トランスクリプトのトリミング -----------------------------
  // Geminiのトークン上限に合わせて部分文字列を取得（おおよそ1トークン=4文字と仮定）
  const approxCharLimit = MAX_TRANSCRIPT_TOKENS * 4;
  const trimmedTranscript = transcript.length > approxCharLimit
    ? transcript.slice(-approxCharLimit)
    : transcript;

  // -------- Gemini による各フェーズの処理 ----------------------------
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const metaPrompt = (meta: TaskMetadata | null) => {
    if (!meta) return "";
    const entries = Object.entries(meta)
      .filter(([_, v]) => v !== null && v !== undefined && v !== "")
      .map(([k, v]) => `- ${k}: ${v}`)
      .join("\n");
    return entries ? `以下はミーティングのメタ情報です:\n${entries}\n` : "";
  };

  type PhaseResult = {
    json: any;
    rawText: string;
  };

  const runPhase = async (phase: "phase1" | "phase2" | "phase3", meta: TaskMetadata | null, transcriptChunk: string): Promise<PhaseResult> => {
    let instruction = "";
    switch (phase) {
      case "phase1":
        instruction = `あなたは優秀な議事録作成アシスタントです。${metaPrompt(meta)}\n「議事の要点」を日本語で箇条書き（最大10項目）にまとめ、以下のJSON形式で返してください。\n{\n  \"key_points\": string[]\n}`;
        break;
      case "phase2":
        instruction = `あなたは優秀な議事録作成アシスタントです。${metaPrompt(meta)}\n以下の文字起こしを論理的な章立て（アジェンダ）に分割し、各章タイトルを生成してください。JSON形式:\n{\n  \"sections\": { \"title\": string, \"summary\": string }[]\n}`;
        break;
      case "phase3":
        instruction = `あなたは優秀な議事録作成アシスタントです。${metaPrompt(meta)}\n以下の文字起こしを話者ごとにまとめ、各話者ごとに発言要約を作成し、重要ポイントを抽出してください。JSON形式:\n{\n  \"speakers\": { \"name\": string, \"summary\": string }[]\n}`;
        break;
    }

    const prompt = `${instruction}\n--- 文字起こしここから ---\n${transcriptChunk}\n--- 文字起こしここまで ---`;

    try {
      const result = await model.generateContent(prompt);
      const raw = result.response.text();
      const firstJsonMatch = raw.match(/\{[\s\S]*\}/);
      if (!firstJsonMatch) throw new Error("JSON not found in model output");
      const parsed = JSON.parse(firstJsonMatch[0]);
      return { json: parsed, rawText: raw };
    } catch (err) {
      console.error(`[summarize-task] ${phase} failed:`, err);
      throw new Error(`${phase}_failed`);
    }
  };

  let phase1: PhaseResult | null = null;
  let phase2: PhaseResult | null = null;
  let phase3: PhaseResult | null = null;

  try {
    [phase1, phase2, phase3] = await Promise.all([
      runPhase("phase1", taskMeta, trimmedTranscript),
      runPhase("phase2", taskMeta, trimmedTranscript),
      runPhase("phase3", taskMeta, trimmedTranscript),
    ]);
    console.log(`[summarize-task] Phase1-3 completed for taskId ${taskId}`);
  } catch (e) {
    // いずれかのフェーズで失敗
    const errMsg = e instanceof Error ? e.message : String(e);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Summarization failed', details: errMsg }, { status: 500 });
  }

  // -------- Phase4: 統合 -----------------------------------------------
  let finalSummary = "";
  try {
    const consolidationPrompt = `あなたはプロのコンサルタントです。与えられたフェーズ1-3の結果をもとに、ミーティング議事録を日本語で1000字以内のMarkdownにまとめてください。\n\n## メタ情報\n${metaPrompt(taskMeta)}\n\n## フェーズ1 要点\n${JSON.stringify(phase1.json)}\n\n## フェーズ2 章立て\n${JSON.stringify(phase2.json)}\n\n## フェーズ3 話者別まとめ\n${JSON.stringify(phase3.json)}\n\n## 出力フォーマット\n- タイトル行として \"# 議事メモ\" を含める\n- 適切なMarkdown見出しを用いる\n- 1000字以内に収める`;

    const phase4Res = await model.generateContent(consolidationPrompt);
    finalSummary = phase4Res.response.text();
  } catch (err) {
    const errMsg = err instanceof Error ? err.message : String(err);
    console.error(`[summarize-task] Phase4 failed:`, errMsg);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Final summary generation failed', details: errMsg }, { status: 500 });
  }

  // -------- Supabase への保存 ---------------------------------------------
  try {
    const { error: saveError } = await supabase.from('transcription_tasks').update({
      phase1_output: phase1.json,
      phase2_output: phase2.json,
      phase3_output: phase3.json,
      final_summary: finalSummary,
      status: 'completed',
      updated_at: new Date().toISOString(),
    }).eq('id', taskId);

    if (saveError) throw saveError;
  } catch (error) {
    const errMsg = error instanceof Error ? error.message : 'Unknown DB error';
    console.error(`[summarize-task] DB save failed for taskId ${taskId}:`, errMsg);
    await supabase.from('transcription_tasks').update({ status: 'summarize_failed', updated_at: new Date().toISOString() }).eq('id', taskId);
    return NextResponse.json({ error: 'Failed to save summary', details: errMsg }, { status: 500 });
  }

  // -------- 完了 -----------------------------------------------------------
  console.log(`[summarize-task] All phases completed for taskId ${taskId}`);
  return NextResponse.json({
    message: 'Summarization completed',
    taskId,
    phase1: phase1.json,
    phase2: phase2.json,
    phase3: phase3.json,
    finalSummary,
  });

  // -------- Notion 連携を非同期で呼び出し -------------------------------
  try {
    if (NEXT_PUBLIC_APP_URL && WEBHOOK_SECRET) {
      fetch(`${NEXT_PUBLIC_APP_URL}/api/notion-sync`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${WEBHOOK_SECRET}`,
        },
        body: JSON.stringify({ taskId }),
      }).then(res => res.text()).then(txt => console.log(`[summarize-task] notion-sync response:`, txt)).catch(err => console.error(`[summarize-task] notion-sync fetch error:`, err));
    } else {
      console.warn('[summarize-task] NEXT_PUBLIC_APP_URL or WEBHOOK_SECRET not set; skipping notion-sync call.');
    }
  } catch (err) {
    console.error('[summarize-task] Error triggering notion-sync:', err);
  }
}

================
File: app/scripts/upload-slack-file.ts
================
#!/usr/bin/env node
import { config } from 'dotenv';
import { uploadSlackFileToSupabase } from '../utils/slack-to-supabase-uploader';

// .envから環境変数を読み込む
config();

async function main() {
  // コマンドライン引数からSlackファイルURLを取得
  const slackFileUrl = process.argv[2];
  
  if (!slackFileUrl) {
    console.error('エラー: Slackファイル URL が必要です');
    console.error('使用方法: npm run upload-slack <slack-file-url>');
    console.error('例: npm run upload-slack https://files.slack.com/files-pri/T12345-F67890/meeting.mp4');
    process.exit(1);
  }
  
  // 必要な環境変数のチェック
  const requiredEnvVars = [
    'SLACK_BOT_TOKEN',
    'UPLOAD_API_ENDPOINT',
    'WEBHOOK_SECRET',
  ];
  
  const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
  if (missingVars.length > 0) {
    console.error(`エラー: 必要な環境変数が見つかりません: ${missingVars.join(', ')}`);
    console.error('環境変数の設定または.envファイルを確認してください');
    process.exit(1);
  }
  
  try {
    console.log(`🚀 Slackファイルのアップロード開始: ${slackFileUrl}`);
    
    const result = await uploadSlackFileToSupabase({
      slackFileUrl,
      slackToken: process.env.SLACK_BOT_TOKEN!,
      uploadEndpoint: process.env.UPLOAD_API_ENDPOINT!,
      webhookSecret: process.env.WEBHOOK_SECRET!,
      logProgress: true,
      maxRetries: 3,
      metadata: {
        cli_executed_at: new Date().toISOString(),
        cli_version: '1.0.0'
      }
    });
    
    console.log('✅ アップロード正常終了!');
    console.log('📊 アップロード詳細:');
    console.log(`  - ID: ${result.id}`);
    console.log(`  - ステータス: ${result.status}`);
    console.log(`  - ストレージパス: ${result.storage_path}`);
    console.log(`  - ファイルサイズ: ${result.file_size} バイト`);
    
    if (result.status === 'processing') {
      console.log('\n🎬 次のステップ:');
      console.log('  ファイルは正常にアップロードされ、現在は文字起こし処理待ちです。');
      console.log('  処理状況は Supabase の upload_logs テーブルで確認できます。');
    }
    
    // 処理が完了した場合のみ終了コード0
    process.exit(0);
  } catch (error) {
    console.error('❌ アップロード失敗:', error instanceof Error ? error.message : error);
    // エラーの場合は終了コード1
    process.exit(1);
  }
}

// スクリプト実行
main();

================
File: deno.lock
================
{
  "version": "5",
  "specifiers": {
    "jsr:@std/dotenv@0.224": "0.224.2",
    "npm:@google/generative-ai@~0.24.1": "0.24.1",
    "npm:@notionhq/client@^3.0.1": "3.0.1",
    "npm:@slack/web-api@^7.9.1": "7.9.1",
    "npm:@supabase/auth-js@2.69.1": "2.69.1",
    "npm:@supabase/functions-js@2.4.4": "2.4.4",
    "npm:@supabase/node-fetch@2.6.15": "2.6.15",
    "npm:@supabase/postgrest-js@1.19.4": "1.19.4",
    "npm:@supabase/realtime-js@2.11.2": "2.11.2",
    "npm:@supabase/storage-js@2.7.1": "2.7.1",
    "npm:@supabase/supabase-js@2.43.4": "2.43.4",
    "npm:@supabase/supabase-js@^2.49.4": "2.49.4",
    "npm:@types/node@*": "22.15.15",
    "npm:@types/node@^22.15.18": "22.15.18",
    "npm:@types/react@^19.1.4": "19.1.4",
    "npm:@types/uuid@10": "10.0.0",
    "npm:formdata-node@^6.0.3": "6.0.3",
    "npm:next@^15.3.2": "15.3.2_react@19.1.0_react-dom@19.1.0__react@19.1.0",
    "npm:openai@^4.100.0": "4.100.0",
    "npm:supabase@2.22.12": "2.22.12",
    "npm:supabase@^2.22.12": "2.22.12",
    "npm:typescript@^5.8.3": "5.8.3",
    "npm:uuid@^11.1.0": "11.1.0"
  },
  "jsr": {
    "@std/dotenv@0.224.2": {
      "integrity": "29081695357e4534696c9e986b2560be29c141ccf52daa32b6c20ff5b5c64ab9"
    }
  },
  "npm": {
    "@emnapi/runtime@1.4.3": {
      "integrity": "sha512-pBPWdu6MLKROBX05wSNKcNb++m5Er+KQ9QkB+WVM+pW2Kx9hoSrVTnu3BdkI5eBLZoKu/J6mW/B6i6bJB2ytXQ==",
      "dependencies": [
        "tslib"
      ]
    },
    "@google/generative-ai@0.24.1": {
      "integrity": "sha512-MqO+MLfM6kjxcKoy0p1wRzG3b4ZZXtPI+z2IE26UogS2Cm/XHO+7gGRBh6gcJsOiIVoH93UwKvW4HdgiOZCy9Q=="
    },
    "@img/sharp-darwin-arm64@0.34.1": {
      "integrity": "sha512-pn44xgBtgpEbZsu+lWf2KNb6OAf70X68k+yk69Ic2Xz11zHR/w24/U49XT7AeRwJ0Px+mhALhU5LPci1Aymk7A==",
      "optionalDependencies": [
        "@img/sharp-libvips-darwin-arm64"
      ],
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@img/sharp-darwin-x64@0.34.1": {
      "integrity": "sha512-VfuYgG2r8BpYiOUN+BfYeFo69nP/MIwAtSJ7/Zpxc5QF3KS22z8Pvg3FkrSFJBPNQ7mmcUcYQFBmEQp7eu1F8Q==",
      "optionalDependencies": [
        "@img/sharp-libvips-darwin-x64"
      ],
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-darwin-arm64@1.1.0": {
      "integrity": "sha512-HZ/JUmPwrJSoM4DIQPv/BfNh9yrOA8tlBbqbLz4JZ5uew2+o22Ik+tHQJcih7QJuSa0zo5coHTfD5J8inqj9DA==",
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-darwin-x64@1.1.0": {
      "integrity": "sha512-Xzc2ToEmHN+hfvsl9wja0RlnXEgpKNmftriQp6XzY/RaSfwD9th+MSh0WQKzUreLKKINb3afirxW7A0fz2YWuQ==",
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-linux-arm64@1.1.0": {
      "integrity": "sha512-IVfGJa7gjChDET1dK9SekxFFdflarnUB8PwW8aGwEoF3oAsSDuNUTYS+SKDOyOJxQyDC1aPFMuRYLoDInyV9Ew==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-linux-arm@1.1.0": {
      "integrity": "sha512-s8BAd0lwUIvYCJyRdFqvsj+BJIpDBSxs6ivrOPm/R7piTs5UIwY5OjXrP2bqXC9/moGsyRa37eYWYCOGVXxVrA==",
      "os": ["linux"],
      "cpu": ["arm"]
    },
    "@img/sharp-libvips-linux-ppc64@1.1.0": {
      "integrity": "sha512-tiXxFZFbhnkWE2LA8oQj7KYR+bWBkiV2nilRldT7bqoEZ4HiDOcePr9wVDAZPi/Id5fT1oY9iGnDq20cwUz8lQ==",
      "os": ["linux"],
      "cpu": ["ppc64"]
    },
    "@img/sharp-libvips-linux-s390x@1.1.0": {
      "integrity": "sha512-xukSwvhguw7COyzvmjydRb3x/09+21HykyapcZchiCUkTThEQEOMtBj9UhkaBRLuBrgLFzQ2wbxdeCCJW/jgJA==",
      "os": ["linux"],
      "cpu": ["s390x"]
    },
    "@img/sharp-libvips-linux-x64@1.1.0": {
      "integrity": "sha512-yRj2+reB8iMg9W5sULM3S74jVS7zqSzHG3Ol/twnAAkAhnGQnpjj6e4ayUz7V+FpKypwgs82xbRdYtchTTUB+Q==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-libvips-linuxmusl-arm64@1.1.0": {
      "integrity": "sha512-jYZdG+whg0MDK+q2COKbYidaqW/WTz0cc1E+tMAusiDygrM4ypmSCjOJPmFTvHHJ8j/6cAGyeDWZOsK06tP33w==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-libvips-linuxmusl-x64@1.1.0": {
      "integrity": "sha512-wK7SBdwrAiycjXdkPnGCPLjYb9lD4l6Ze2gSdAGVZrEL05AOUJESWU2lhlC+Ffn5/G+VKuSm6zzbQSzFX/P65A==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-linux-arm64@0.34.1": {
      "integrity": "sha512-kX2c+vbvaXC6vly1RDf/IWNXxrlxLNpBVWkdpRq5Ka7OOKj6nr66etKy2IENf6FtOgklkg9ZdGpEu9kwdlcwOQ==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-arm64"
      ],
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-linux-arm@0.34.1": {
      "integrity": "sha512-anKiszvACti2sGy9CirTlNyk7BjjZPiML1jt2ZkTdcvpLU1YH6CXwRAZCA2UmRXnhiIftXQ7+Oh62Ji25W72jA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-arm"
      ],
      "os": ["linux"],
      "cpu": ["arm"]
    },
    "@img/sharp-linux-s390x@0.34.1": {
      "integrity": "sha512-7s0KX2tI9mZI2buRipKIw2X1ufdTeaRgwmRabt5bi9chYfhur+/C1OXg3TKg/eag1W+6CCWLVmSauV1owmRPxA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-s390x"
      ],
      "os": ["linux"],
      "cpu": ["s390x"]
    },
    "@img/sharp-linux-x64@0.34.1": {
      "integrity": "sha512-wExv7SH9nmoBW3Wr2gvQopX1k8q2g5V5Iag8Zk6AVENsjwd+3adjwxtp3Dcu2QhOXr8W9NusBU6XcQUohBZ5MA==",
      "optionalDependencies": [
        "@img/sharp-libvips-linux-x64"
      ],
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-linuxmusl-arm64@0.34.1": {
      "integrity": "sha512-DfvyxzHxw4WGdPiTF0SOHnm11Xv4aQexvqhRDAoD00MzHekAj9a/jADXeXYCDFH/DzYruwHbXU7uz+H+nWmSOQ==",
      "optionalDependencies": [
        "@img/sharp-libvips-linuxmusl-arm64"
      ],
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@img/sharp-linuxmusl-x64@0.34.1": {
      "integrity": "sha512-pax/kTR407vNb9qaSIiWVnQplPcGU8LRIJpDT5o8PdAx5aAA7AS3X9PS8Isw1/WfqgQorPotjrZL3Pqh6C5EBg==",
      "optionalDependencies": [
        "@img/sharp-libvips-linuxmusl-x64"
      ],
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@img/sharp-wasm32@0.34.1": {
      "integrity": "sha512-YDybQnYrLQfEpzGOQe7OKcyLUCML4YOXl428gOOzBgN6Gw0rv8dpsJ7PqTHxBnXnwXr8S1mYFSLSa727tpz0xg==",
      "dependencies": [
        "@emnapi/runtime"
      ],
      "cpu": ["wasm32"]
    },
    "@img/sharp-win32-ia32@0.34.1": {
      "integrity": "sha512-WKf/NAZITnonBf3U1LfdjoMgNO5JYRSlhovhRhMxXVdvWYveM4kM3L8m35onYIdh75cOMCo1BexgVQcCDzyoWw==",
      "os": ["win32"],
      "cpu": ["ia32"]
    },
    "@img/sharp-win32-x64@0.34.1": {
      "integrity": "sha512-hw1iIAHpNE8q3uMIRCgGOeDoz9KtFNarFLQclLxr/LK1VBkj8nby18RjFvr6aP7USRYAjTZW6yisnBWMX571Tw==",
      "os": ["win32"],
      "cpu": ["x64"]
    },
    "@isaacs/fs-minipass@4.0.1": {
      "integrity": "sha512-wgm9Ehl2jpeqP3zw/7mo3kRHFp5MEDhqAdwy1fTGkHAwnkGOVsgpvQhL8B5n1qlb01jV3n/bI0ZfZp5lWA1k4w==",
      "dependencies": [
        "minipass"
      ]
    },
    "@next/env@15.3.2": {
      "integrity": "sha512-xURk++7P7qR9JG1jJtLzPzf0qEvqCN0A/T3DXf8IPMKo9/6FfjxtEffRJIIew/bIL4T3C2jLLqBor8B/zVlx6g=="
    },
    "@next/swc-darwin-arm64@15.3.2": {
      "integrity": "sha512-2DR6kY/OGcokbnCsjHpNeQblqCZ85/1j6njYSkzRdpLn5At7OkSdmk7WyAmB9G0k25+VgqVZ/u356OSoQZ3z0g==",
      "os": ["darwin"],
      "cpu": ["arm64"]
    },
    "@next/swc-darwin-x64@15.3.2": {
      "integrity": "sha512-ro/fdqaZWL6k1S/5CLv1I0DaZfDVJkWNaUU3un8Lg6m0YENWlDulmIWzV96Iou2wEYyEsZq51mwV8+XQXqMp3w==",
      "os": ["darwin"],
      "cpu": ["x64"]
    },
    "@next/swc-linux-arm64-gnu@15.3.2": {
      "integrity": "sha512-covwwtZYhlbRWK2HlYX9835qXum4xYZ3E2Mra1mdQ+0ICGoMiw1+nVAn4d9Bo7R3JqSmK1grMq/va+0cdh7bJA==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@next/swc-linux-arm64-musl@15.3.2": {
      "integrity": "sha512-KQkMEillvlW5Qk5mtGA/3Yz0/tzpNlSw6/3/ttsV1lNtMuOHcGii3zVeXZyi4EJmmLDKYcTcByV2wVsOhDt/zg==",
      "os": ["linux"],
      "cpu": ["arm64"]
    },
    "@next/swc-linux-x64-gnu@15.3.2": {
      "integrity": "sha512-uRBo6THWei0chz+Y5j37qzx+BtoDRFIkDzZjlpCItBRXyMPIg079eIkOCl3aqr2tkxL4HFyJ4GHDes7W8HuAUg==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@next/swc-linux-x64-musl@15.3.2": {
      "integrity": "sha512-+uxFlPuCNx/T9PdMClOqeE8USKzj8tVz37KflT3Kdbx/LOlZBRI2yxuIcmx1mPNK8DwSOMNCr4ureSet7eyC0w==",
      "os": ["linux"],
      "cpu": ["x64"]
    },
    "@next/swc-win32-arm64-msvc@15.3.2": {
      "integrity": "sha512-LLTKmaI5cfD8dVzh5Vt7+OMo+AIOClEdIU/TSKbXXT2iScUTSxOGoBhfuv+FU8R9MLmrkIL1e2fBMkEEjYAtPQ==",
      "os": ["win32"],
      "cpu": ["arm64"]
    },
    "@next/swc-win32-x64-msvc@15.3.2": {
      "integrity": "sha512-aW5B8wOPioJ4mBdMDXkt5f3j8pUr9W8AnlX0Df35uRWNT1Y6RIybxjnSUe+PhM+M1bwgyY8PHLmXZC6zT1o5tA==",
      "os": ["win32"],
      "cpu": ["x64"]
    },
    "@notionhq/client@3.0.1": {
      "integrity": "sha512-vHtFKrRKQg2PZSky1A9fTe+L9/WxNYRJWHmD6ZiBNgeN5jnFmv27ootRl9ROzEm/N+mOxfTo37EnuCHsaPgETg=="
    },
    "@slack/logger@4.0.0": {
      "integrity": "sha512-Wz7QYfPAlG/DR+DfABddUZeNgoeY7d1J39OCR2jR+v7VBsB8ezulDK5szTnDDPDwLH5IWhLvXIHlCFZV7MSKgA==",
      "dependencies": [
        "@types/node@22.15.18"
      ]
    },
    "@slack/types@2.14.0": {
      "integrity": "sha512-n0EGm7ENQRxlXbgKSrQZL69grzg1gHLAVd+GlRVQJ1NSORo0FrApR7wql/gaKdu2n4TO83Sq/AmeUOqD60aXUA=="
    },
    "@slack/web-api@7.9.1": {
      "integrity": "sha512-qMcb1oWw3Y/KlUIVJhkI8+NcQXq1lNymwf+ewk93ggZsGd6iuz9ObQsOEbvlqlx1J+wd8DmIm3DORGKs0fcKdg==",
      "dependencies": [
        "@slack/logger",
        "@slack/types",
        "@types/node@22.15.18",
        "@types/retry",
        "axios",
        "eventemitter3@5.0.1",
        "form-data",
        "is-electron",
        "is-stream",
        "p-queue",
        "p-retry",
        "retry"
      ]
    },
    "@supabase/auth-js@2.64.2": {
      "integrity": "sha512-s+lkHEdGiczDrzXJ1YWt2y3bxRi+qIUnXcgkpLSrId7yjBeaXBFygNjTaoZLG02KNcYwbuZ9qkEIqmj2hF7svw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/auth-js@2.69.1": {
      "integrity": "sha512-FILtt5WjCNzmReeRLq5wRs3iShwmnWgBvxHfqapC/VoljJl+W8hDAyFmf1NVw3zH+ZjZ05AKxiKxVeb0HNWRMQ==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/functions-js@2.3.1": {
      "integrity": "sha512-QyzNle/rVzlOi4BbVqxLSH828VdGY1RElqGFAj+XeVypj6+PVtMlD21G8SDnsPQDtlqqTtoGRgdMlQZih5hTuw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/functions-js@2.4.4": {
      "integrity": "sha512-WL2p6r4AXNGwop7iwvul2BvOtuJ1YQy8EbOd0dhG1oN1q8el/BIRSFCFnWAMM/vJJlHWLi4ad22sKbKr9mvjoA==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/node-fetch@2.6.15": {
      "integrity": "sha512-1ibVeYUacxWYi9i0cf5efil6adJ9WRyZBLivgjs+AUpewx1F3xPi7gLgaASI2SmIQxPoCEjAsLAzKPgMJVgOUQ==",
      "dependencies": [
        "whatwg-url"
      ]
    },
    "@supabase/postgrest-js@1.15.2": {
      "integrity": "sha512-9/7pUmXExvGuEK1yZhVYXPZnLEkDTwxgMQHXLrN5BwPZZm4iUCL1YEyep/Z2lIZah8d8M433mVAUEGsihUj5KQ==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/postgrest-js@1.19.4": {
      "integrity": "sha512-O4soKqKtZIW3olqmbXXbKugUtByD2jPa8kL2m2c1oozAO11uCcGrRhkZL0kVxjBLrXHE0mdSkFsMj7jDSfyNpw==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/realtime-js@2.11.2": {
      "integrity": "sha512-u/XeuL2Y0QEhXSoIPZZwR6wMXgB+RQbJzG9VErA3VghVt7uRfSVsjeqd7m5GhX3JR6dM/WRmLbVR8URpDWG4+w==",
      "dependencies": [
        "@supabase/node-fetch",
        "@types/phoenix",
        "@types/ws",
        "ws"
      ]
    },
    "@supabase/realtime-js@2.9.5": {
      "integrity": "sha512-TEHlGwNGGmKPdeMtca1lFTYCedrhTAv3nZVoSjrKQ+wkMmaERuCe57zkC5KSWFzLYkb5FVHW8Hrr+PX1DDwplQ==",
      "dependencies": [
        "@supabase/node-fetch",
        "@types/phoenix",
        "@types/ws",
        "ws"
      ]
    },
    "@supabase/storage-js@2.5.5": {
      "integrity": "sha512-OpLoDRjFwClwc2cjTJZG8XviTiQH4Ik8sCiMK5v7et0MDu2QlXjCAW3ljxJB5+z/KazdMOTnySi+hysxWUPu3w==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/storage-js@2.7.1": {
      "integrity": "sha512-asYHcyDR1fKqrMpytAS1zjyEfvxuOIp1CIXX7ji4lHHcJKqyk+sLl/Vxgm4sN6u8zvuUtae9e4kDxQP2qrwWBA==",
      "dependencies": [
        "@supabase/node-fetch"
      ]
    },
    "@supabase/supabase-js@2.43.4": {
      "integrity": "sha512-/pLPaxiIsn5Vaz3s32HC6O/VNwfeddnzS0bZRpOW0AKcPuXroD8pT9G8mpiBlZfpKsMmq6k7tlhW7Sr1PAQ1lw==",
      "dependencies": [
        "@supabase/auth-js@2.64.2",
        "@supabase/functions-js@2.3.1",
        "@supabase/node-fetch",
        "@supabase/postgrest-js@1.15.2",
        "@supabase/realtime-js@2.9.5",
        "@supabase/storage-js@2.5.5"
      ]
    },
    "@supabase/supabase-js@2.49.4": {
      "integrity": "sha512-jUF0uRUmS8BKt37t01qaZ88H9yV1mbGYnqLeuFWLcdV+x1P4fl0yP9DGtaEhFPZcwSom7u16GkLEH9QJZOqOkw==",
      "dependencies": [
        "@supabase/auth-js@2.69.1",
        "@supabase/functions-js@2.4.4",
        "@supabase/node-fetch",
        "@supabase/postgrest-js@1.19.4",
        "@supabase/realtime-js@2.11.2",
        "@supabase/storage-js@2.7.1"
      ]
    },
    "@swc/counter@0.1.3": {
      "integrity": "sha512-e2BR4lsJkkRlKZ/qCHPw9ZaSxc0MVUd7gtbtaB7aMvHeJVYe8sOB8DBZkP2DtISHGSku9sCK6T6cnY0CtXrOCQ=="
    },
    "@swc/helpers@0.5.15": {
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "dependencies": [
        "tslib"
      ]
    },
    "@types/node-fetch@2.6.12": {
      "integrity": "sha512-8nneRWKCg3rMtF69nLQJnOYUcbafYeFSjqkw3jCRLsqkWFlHaoQrr5mXmofFGOx3DKn7UfmBMyov8ySvLRVldA==",
      "dependencies": [
        "@types/node@22.15.15",
        "form-data"
      ]
    },
    "@types/node@18.19.100": {
      "integrity": "sha512-ojmMP8SZBKprc3qGrGk8Ujpo80AXkrP7G2tOT4VWr5jlr5DHjsJF+emXJz+Wm0glmy4Js62oKMdZZ6B9Y+tEcA==",
      "dependencies": [
        "undici-types@5.26.5"
      ]
    },
    "@types/node@22.15.15": {
      "integrity": "sha512-R5muMcZob3/Jjchn5LcO8jdKwSCbzqmPB6ruBxMcf9kbxtniZHP327s6C37iOfuw8mbKK3cAQa7sEl7afLrQ8A==",
      "dependencies": [
        "undici-types@6.21.0"
      ]
    },
    "@types/node@22.15.18": {
      "integrity": "sha512-v1DKRfUdyW+jJhZNEI1PYy29S2YRxMV5AOO/x/SjKmW0acCIOqmbj6Haf9eHAhsPmrhlHSxEhv/1WszcLWV4cg==",
      "dependencies": [
        "undici-types@6.21.0"
      ]
    },
    "@types/phoenix@1.6.6": {
      "integrity": "sha512-PIzZZlEppgrpoT2QgbnDU+MMzuR6BbCjllj0bM70lWoejMeNJAxCchxnv7J3XFkI8MpygtRpzXrIlmWUBclP5A=="
    },
    "@types/react@19.1.4": {
      "integrity": "sha512-EB1yiiYdvySuIITtD5lhW4yPyJ31RkJkkDw794LaQYrxCSaQV/47y5o1FMC4zF9ZyjUjzJMZwbovEnT5yHTW6g==",
      "dependencies": [
        "csstype"
      ]
    },
    "@types/retry@0.12.0": {
      "integrity": "sha512-wWKOClTTiizcZhXnPY4wikVAwmdYHp8q6DmC+EJUzAMsycb7HB32Kh9RN4+0gExjmPmZSAQjgURXIGATPegAvA=="
    },
    "@types/uuid@10.0.0": {
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ=="
    },
    "@types/ws@8.18.1": {
      "integrity": "sha512-ThVF6DCVhA8kUGy+aazFQ4kXQ7E1Ty7A3ypFOe0IcJV8O/M511G99AW24irKrW56Wt44yG9+ij8FaqoBGkuBXg==",
      "dependencies": [
        "@types/node@22.15.15"
      ]
    },
    "abort-controller@3.0.0": {
      "integrity": "sha512-h8lQ8tacZYnR3vNQTgibj+tODHI5/+l06Au2Pcriv/Gmet0eaj4TwWH41sO9wnHDiQsEj19q0drzdWdeAHtweg==",
      "dependencies": [
        "event-target-shim"
      ]
    },
    "agent-base@7.1.3": {
      "integrity": "sha512-jRR5wdylq8CkOe6hei19GGZnxM6rBGwFl3Bg0YItGDimvjGtAvdZk4Pu6Cl4u4Igsws4a1fd1Vq3ezrhn4KmFw=="
    },
    "agentkeepalive@4.6.0": {
      "integrity": "sha512-kja8j7PjmncONqaTsB8fQ+wE2mSU2DJ9D4XKoJ5PFWIdRMa6SLSN1ff4mOr4jCbfRSsxR4keIiySJU0N9T5hIQ==",
      "dependencies": [
        "humanize-ms"
      ]
    },
    "asynckit@0.4.0": {
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "axios@1.9.0": {
      "integrity": "sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==",
      "dependencies": [
        "follow-redirects",
        "form-data",
        "proxy-from-env"
      ]
    },
    "bin-links@5.0.0": {
      "integrity": "sha512-sdleLVfCjBtgO5cNjA2HVRvWBJAHs4zwenaCPMNJAJU0yNxpzj80IpjOIimkpkr+mhlA+how5poQtt53PygbHA==",
      "dependencies": [
        "cmd-shim",
        "npm-normalize-package-bin",
        "proc-log",
        "read-cmd-shim",
        "write-file-atomic"
      ]
    },
    "busboy@1.6.0": {
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": [
        "streamsearch"
      ]
    },
    "call-bind-apply-helpers@1.0.2": {
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "dependencies": [
        "es-errors",
        "function-bind"
      ]
    },
    "caniuse-lite@1.0.30001718": {
      "integrity": "sha512-AflseV1ahcSunK53NfEs9gFWgOEmzr0f+kaMFA4xiLZlr9Hzt7HxcSpIFcnNCUkz6R6dWKa54rUz3HUmI3nVcw=="
    },
    "chownr@3.0.0": {
      "integrity": "sha512-+IxzY9BZOQd/XuYPRmrvEVjF/nqj5kgT4kEq7VofrDoM1MxoRjEWkrCC3EtLi59TVawxTAn+orJwFQcrqEN1+g=="
    },
    "client-only@0.0.1": {
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA=="
    },
    "cmd-shim@7.0.0": {
      "integrity": "sha512-rtpaCbr164TPPh+zFdkWpCyZuKkjpAzODfaZCf/SVJZzJN+4bHQb/LP3Jzq5/+84um3XXY8r548XiWKSborwVw=="
    },
    "color-convert@2.0.1": {
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dependencies": [
        "color-name"
      ]
    },
    "color-name@1.1.4": {
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="
    },
    "color-string@1.9.1": {
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "dependencies": [
        "color-name",
        "simple-swizzle"
      ]
    },
    "color@4.2.3": {
      "integrity": "sha512-1rXeuUUiGGrykh+CeBdu5Ie7OJwinCgQY0bc7GCRxy5xVHy+moaqkpL/jqQq0MtQOeYcrqEz4abc5f0KtU7W4A==",
      "dependencies": [
        "color-convert",
        "color-string"
      ]
    },
    "combined-stream@1.0.8": {
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": [
        "delayed-stream"
      ]
    },
    "csstype@3.1.3": {
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw=="
    },
    "data-uri-to-buffer@4.0.1": {
      "integrity": "sha512-0R9ikRb668HB7QDxT1vkpuUBtqc53YyAwMwGeUFKRojY/NWKvdZ+9UYtRfGmhqNbRkTSVpMbmyhXipFFv2cb/A=="
    },
    "debug@4.4.1": {
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "dependencies": [
        "ms"
      ]
    },
    "delayed-stream@1.0.0": {
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ=="
    },
    "detect-libc@2.0.4": {
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA=="
    },
    "dunder-proto@1.0.1": {
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "dependencies": [
        "call-bind-apply-helpers",
        "es-errors",
        "gopd"
      ]
    },
    "es-define-property@1.0.1": {
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g=="
    },
    "es-errors@1.3.0": {
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw=="
    },
    "es-object-atoms@1.1.1": {
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "dependencies": [
        "es-errors"
      ]
    },
    "es-set-tostringtag@2.1.0": {
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dependencies": [
        "es-errors",
        "get-intrinsic",
        "has-tostringtag",
        "hasown"
      ]
    },
    "event-target-shim@5.0.1": {
      "integrity": "sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ=="
    },
    "eventemitter3@4.0.7": {
      "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw=="
    },
    "eventemitter3@5.0.1": {
      "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA=="
    },
    "fetch-blob@3.2.0": {
      "integrity": "sha512-7yAQpD2UMJzLi1Dqv7qFYnPbaPx7ZfFK6PiIxQ4PfkGPyNyl2Ugx+a/umUonmKqjhM4DnfbMvdX6otXq83soQQ==",
      "dependencies": [
        "node-domexception",
        "web-streams-polyfill@3.3.3"
      ]
    },
    "follow-redirects@1.15.9": {
      "integrity": "sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ=="
    },
    "form-data-encoder@1.7.2": {
      "integrity": "sha512-qfqtYan3rxrnCk1VYaA4H+Ms9xdpPqvLZa6xmMgFvhO32x7/3J/ExcTd6qpxM0vH2GdMI+poehyBZvqfMTto8A=="
    },
    "form-data@4.0.2": {
      "integrity": "sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==",
      "dependencies": [
        "asynckit",
        "combined-stream",
        "es-set-tostringtag",
        "mime-types"
      ]
    },
    "formdata-node@4.4.1": {
      "integrity": "sha512-0iirZp3uVDjVGt9p49aTaqjk84TrglENEDuqfdlZQ1roC9CWlPk6Avf8EEnZNcAqPonwkG35x4n3ww/1THYAeQ==",
      "dependencies": [
        "node-domexception",
        "web-streams-polyfill@4.0.0-beta.3"
      ]
    },
    "formdata-node@6.0.3": {
      "integrity": "sha512-8e1++BCiTzUno9v5IZ2J6bv4RU+3UKDmqWUQD0MIMVCd9AdhWkO1gw57oo1mNEX1dMq2EGI+FbWz4B92pscSQg=="
    },
    "formdata-polyfill@4.0.10": {
      "integrity": "sha512-buewHzMvYL29jdeQTVILecSaZKnt/RJWjoZCF5OW60Z67/GmSLBkOFM7qh1PI3zFNtJbaZL5eQu1vLfazOwj4g==",
      "dependencies": [
        "fetch-blob"
      ]
    },
    "function-bind@1.1.2": {
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA=="
    },
    "get-intrinsic@1.3.0": {
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "dependencies": [
        "call-bind-apply-helpers",
        "es-define-property",
        "es-errors",
        "es-object-atoms",
        "function-bind",
        "get-proto",
        "gopd",
        "has-symbols",
        "hasown",
        "math-intrinsics"
      ]
    },
    "get-proto@1.0.1": {
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "dependencies": [
        "dunder-proto",
        "es-object-atoms"
      ]
    },
    "gopd@1.2.0": {
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg=="
    },
    "has-symbols@1.1.0": {
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ=="
    },
    "has-tostringtag@1.0.2": {
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dependencies": [
        "has-symbols"
      ]
    },
    "hasown@2.0.2": {
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "dependencies": [
        "function-bind"
      ]
    },
    "https-proxy-agent@7.0.6": {
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dependencies": [
        "agent-base",
        "debug"
      ]
    },
    "humanize-ms@1.2.1": {
      "integrity": "sha512-Fl70vYtsAFb/C06PTS9dZBo7ihau+Tu/DNCk/OyHhea07S+aeMWpFFkUaXRa8fI+ScZbEI8dfSxwY7gxZ9SAVQ==",
      "dependencies": [
        "ms"
      ]
    },
    "imurmurhash@0.1.4": {
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA=="
    },
    "is-arrayish@0.3.2": {
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ=="
    },
    "is-electron@2.2.2": {
      "integrity": "sha512-FO/Rhvz5tuw4MCWkpMzHFKWD2LsfHzIb7i6MdPYZ/KW7AlxawyLkqdy+jPZP1WubqEADE3O4FUENlJHDfQASRg=="
    },
    "is-stream@2.0.1": {
      "integrity": "sha512-hFoiJiTl63nn+kstHGBtewWSKnQLpyb155KHheA1l39uvtO9nWIop1p3udqPcUd/xbF1VLMO4n7OI6p7RbngDg=="
    },
    "math-intrinsics@1.1.0": {
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g=="
    },
    "mime-db@1.52.0": {
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg=="
    },
    "mime-types@2.1.35": {
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "dependencies": [
        "mime-db"
      ]
    },
    "minipass@7.1.2": {
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw=="
    },
    "minizlib@3.0.2": {
      "integrity": "sha512-oG62iEk+CYt5Xj2YqI5Xi9xWUeZhDI8jjQmC5oThVH5JGCTgIjr7ciJDzC7MBzYd//WvR1OTmP5Q38Q8ShQtVA==",
      "dependencies": [
        "minipass"
      ]
    },
    "mkdirp@3.0.1": {
      "integrity": "sha512-+NsyUUAZDmo6YVHzL/stxSu3t9YS1iljliy3BSDrXJ/dkn1KYdmtZODGGjLcc9XLgVVpH4KshHB8XmZgMhaBXg==",
      "bin": true
    },
    "ms@2.1.3": {
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA=="
    },
    "nanoid@3.3.11": {
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "bin": true
    },
    "next@15.3.2_react@19.1.0_react-dom@19.1.0__react@19.1.0": {
      "integrity": "sha512-CA3BatMyHkxZ48sgOCLdVHjFU36N7TF1HhqAHLFOkV6buwZnvMI84Cug8xD56B9mCuKrqXnLn94417GrZ/jjCQ==",
      "dependencies": [
        "@next/env",
        "@swc/counter",
        "@swc/helpers",
        "busboy",
        "caniuse-lite",
        "postcss",
        "react",
        "react-dom",
        "styled-jsx"
      ],
      "optionalDependencies": [
        "@next/swc-darwin-arm64",
        "@next/swc-darwin-x64",
        "@next/swc-linux-arm64-gnu",
        "@next/swc-linux-arm64-musl",
        "@next/swc-linux-x64-gnu",
        "@next/swc-linux-x64-musl",
        "@next/swc-win32-arm64-msvc",
        "@next/swc-win32-x64-msvc",
        "sharp"
      ],
      "bin": true
    },
    "node-domexception@1.0.0": {
      "integrity": "sha512-/jKZoMpw0F8GRwl4/eLROPA3cfcXtLApP0QzLmUT/HuPCZWyB7IY9ZrMeKw2O/nFIqPQB3PVM9aYm0F312AXDQ==",
      "deprecated": true
    },
    "node-fetch@2.7.0": {
      "integrity": "sha512-c4FRfUm/dbcWZ7U+1Wq0AwCyFL+3nt2bEw05wfxSz+DWpWsitgmSgYmy2dQdWyKC1694ELPqMs/YzUSNozLt8A==",
      "dependencies": [
        "whatwg-url"
      ]
    },
    "node-fetch@3.3.2": {
      "integrity": "sha512-dRB78srN/l6gqWulah9SrxeYnxeddIG30+GOqK/9OlLVyLg3HPnr6SqOWTWOXKRwC2eGYCkZ59NNuSgvSrpgOA==",
      "dependencies": [
        "data-uri-to-buffer",
        "fetch-blob",
        "formdata-polyfill"
      ]
    },
    "npm-normalize-package-bin@4.0.0": {
      "integrity": "sha512-TZKxPvItzai9kN9H/TkmCtx/ZN/hvr3vUycjlfmH0ootY9yFBzNOpiXAdIn1Iteqsvk4lQn6B5PTrt+n6h8k/w=="
    },
    "openai@4.100.0": {
      "integrity": "sha512-9soq/wukv3utxcuD7TWFqKdKp0INWdeyhUCvxwrne5KwnxaCp4eHL4GdT/tMFhYolxgNhxFzg5GFwM331Z5CZg==",
      "dependencies": [
        "@types/node@18.19.100",
        "@types/node-fetch",
        "abort-controller",
        "agentkeepalive",
        "form-data-encoder",
        "formdata-node@4.4.1",
        "node-fetch@2.7.0"
      ],
      "bin": true
    },
    "p-finally@1.0.0": {
      "integrity": "sha512-LICb2p9CB7FS+0eR1oqWnHhp0FljGLZCWBE9aix0Uye9W8LTQPwMTYVGWQWIw9RdQiDg4+epXQODwIYJtSJaow=="
    },
    "p-queue@6.6.2": {
      "integrity": "sha512-RwFpb72c/BhQLEXIZ5K2e+AhgNVmIejGlTgiB9MzZ0e93GRvqZ7uSi0dvRF7/XIXDeNkra2fNHBxTyPDGySpjQ==",
      "dependencies": [
        "eventemitter3@4.0.7",
        "p-timeout"
      ]
    },
    "p-retry@4.6.2": {
      "integrity": "sha512-312Id396EbJdvRONlngUx0NydfrIQ5lsYu0znKVUzVvArzEIt08V1qhtyESbGVd1FGX7UKtiFp5uwKZdM8wIuQ==",
      "dependencies": [
        "@types/retry",
        "retry"
      ]
    },
    "p-timeout@3.2.0": {
      "integrity": "sha512-rhIwUycgwwKcP9yTOOFK/AKsAopjjCakVqLHePO3CC6Mir1Z99xT+R63jZxAT5lFZLa2inS5h+ZS2GvR99/FBg==",
      "dependencies": [
        "p-finally"
      ]
    },
    "picocolors@1.1.1": {
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="
    },
    "postcss@8.4.31": {
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "dependencies": [
        "nanoid",
        "picocolors",
        "source-map-js"
      ]
    },
    "proc-log@5.0.0": {
      "integrity": "sha512-Azwzvl90HaF0aCz1JrDdXQykFakSSNPaPoiZ9fm5qJIMHioDZEi7OAdRwSm6rSoPtY3Qutnm3L7ogmg3dc+wbQ=="
    },
    "proxy-from-env@1.1.0": {
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="
    },
    "react-dom@19.1.0_react@19.1.0": {
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "dependencies": [
        "react",
        "scheduler"
      ]
    },
    "react@19.1.0": {
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg=="
    },
    "read-cmd-shim@5.0.0": {
      "integrity": "sha512-SEbJV7tohp3DAAILbEMPXavBjAnMN0tVnh4+9G8ihV4Pq3HYF9h8QNez9zkJ1ILkv9G2BjdzwctznGZXgu/HGw=="
    },
    "retry@0.13.1": {
      "integrity": "sha512-XQBQ3I8W1Cge0Seh+6gjj03LbmRFWuoszgK9ooCpwYIrhhoO80pfq4cUkU5DkknwfOfFteRwlZ56PYOGYyFWdg=="
    },
    "scheduler@0.26.0": {
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA=="
    },
    "semver@7.7.2": {
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "bin": true
    },
    "sharp@0.34.1": {
      "integrity": "sha512-1j0w61+eVxu7DawFJtnfYcvSv6qPFvfTaqzTQ2BLknVhHTwGS8sc63ZBF4rzkWMBVKybo4S5OBtDdZahh2A1xg==",
      "dependencies": [
        "color",
        "detect-libc",
        "semver"
      ],
      "optionalDependencies": [
        "@img/sharp-darwin-arm64",
        "@img/sharp-darwin-x64",
        "@img/sharp-libvips-darwin-arm64",
        "@img/sharp-libvips-darwin-x64",
        "@img/sharp-libvips-linux-arm",
        "@img/sharp-libvips-linux-arm64",
        "@img/sharp-libvips-linux-ppc64",
        "@img/sharp-libvips-linux-s390x",
        "@img/sharp-libvips-linux-x64",
        "@img/sharp-libvips-linuxmusl-arm64",
        "@img/sharp-libvips-linuxmusl-x64",
        "@img/sharp-linux-arm",
        "@img/sharp-linux-arm64",
        "@img/sharp-linux-s390x",
        "@img/sharp-linux-x64",
        "@img/sharp-linuxmusl-arm64",
        "@img/sharp-linuxmusl-x64",
        "@img/sharp-wasm32",
        "@img/sharp-win32-ia32",
        "@img/sharp-win32-x64"
      ],
      "scripts": true
    },
    "signal-exit@4.1.0": {
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw=="
    },
    "simple-swizzle@0.2.2": {
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "dependencies": [
        "is-arrayish"
      ]
    },
    "source-map-js@1.2.1": {
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA=="
    },
    "streamsearch@1.1.0": {
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg=="
    },
    "styled-jsx@5.1.6_react@19.1.0": {
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "dependencies": [
        "client-only",
        "react"
      ]
    },
    "supabase@2.22.12": {
      "integrity": "sha512-PWQT+uzwAXcamM/FK60CaWRjVwsX2SGW5vF7edbiTQC6vsNvTBnSIvd1yiXsIpq32uzQFu+iOrayxaTQytNiTw==",
      "dependencies": [
        "bin-links",
        "https-proxy-agent",
        "node-fetch@3.3.2",
        "tar"
      ],
      "scripts": true,
      "bin": true
    },
    "tar@7.4.3": {
      "integrity": "sha512-5S7Va8hKfV7W5U6g3aYxXmlPoZVAwUMy9AOKyF2fVuZa2UD3qZjg578OrLRt8PcNN1PleVaL/5/yYATNL0ICUw==",
      "dependencies": [
        "@isaacs/fs-minipass",
        "chownr",
        "minipass",
        "minizlib",
        "mkdirp",
        "yallist"
      ]
    },
    "tr46@0.0.3": {
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "tslib@2.8.1": {
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w=="
    },
    "typescript@5.8.3": {
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "bin": true
    },
    "undici-types@5.26.5": {
      "integrity": "sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA=="
    },
    "undici-types@6.21.0": {
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ=="
    },
    "uuid@11.1.0": {
      "integrity": "sha512-0/A9rDy9P7cJ+8w1c9WD9V//9Wj15Ce2MPz8Ri6032usz+NfePxx5AcN3bN+r6ZL6jEo066/yNYB3tn4pQEx+A==",
      "bin": true
    },
    "web-streams-polyfill@3.3.3": {
      "integrity": "sha512-d2JWLCivmZYTSIoge9MsgFCZrt571BikcWGYkjC1khllbTeDlGqZ2D8vD8E/lJa8WGWbb7Plm8/XJYV7IJHZZw=="
    },
    "web-streams-polyfill@4.0.0-beta.3": {
      "integrity": "sha512-QW95TCTaHmsYfHDybGMwO5IJIM93I/6vTRk+daHTWFPhwh+C8Cg7j7XyKrwrj8Ib6vYXe0ocYNrmzY4xAAN6ug=="
    },
    "webidl-conversions@3.0.1": {
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url@5.0.0": {
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": [
        "tr46",
        "webidl-conversions"
      ]
    },
    "write-file-atomic@6.0.0": {
      "integrity": "sha512-GmqrO8WJ1NuzJ2DrziEI2o57jKAVIQNf8a18W3nCYU3H7PNWqCCVTeH6/NQE93CIllIgQS98rrmVkYgTX9fFJQ==",
      "dependencies": [
        "imurmurhash",
        "signal-exit"
      ]
    },
    "ws@8.18.2": {
      "integrity": "sha512-DMricUmwGZUVr++AEAe2uiVM7UoO9MAVZMDu05UQOaUII0lp+zOzLLU4Xqh/JvTqklB1T4uELaaPBKyjE1r4fQ=="
    },
    "yallist@5.0.0": {
      "integrity": "sha512-YgvUTfwqyc7UXVMrB+SImsVYSmTS8X/tSrtdNZMImM+n7+QTriRXyXim0mBrTXNeqzVF0KWGgHPeiyViFFrNDw=="
    }
  },
  "redirects": {
    "https://esm.sh/@supabase/node-fetch@^2.6.14?target=denonext": "https://esm.sh/@supabase/node-fetch@2.6.15?target=denonext",
    "https://esm.sh/@supabase/supabase-js@2": "https://esm.sh/@supabase/supabase-js@2.49.4",
    "https://esm.sh/@types/ws@~8.18.1/index.d.mts": "https://esm.sh/@types/ws@8.18.1/index.d.mts",
    "https://esm.sh/bufferutil@^4.0.1?target=denonext": "https://esm.sh/bufferutil@4.0.9?target=denonext",
    "https://esm.sh/node-gyp-build@^4.3.0?target=denonext": "https://esm.sh/node-gyp-build@4.8.4?target=denonext",
    "https://esm.sh/tr46@~0.0.3?target=denonext": "https://esm.sh/tr46@0.0.3?target=denonext",
    "https://esm.sh/utf-8-validate@%3E=5.0.2?target=denonext": "https://esm.sh/utf-8-validate@6.0.5?target=denonext",
    "https://esm.sh/webidl-conversions@^3.0.0?target=denonext": "https://esm.sh/webidl-conversions@3.0.1?target=denonext",
    "https://esm.sh/whatwg-url@^5.0.0?target=denonext": "https://esm.sh/whatwg-url@5.0.0?target=denonext",
    "https://esm.sh/ws@^8.18.0?target=denonext": "https://esm.sh/ws@8.18.2?target=denonext"
  },
  "remote": {
    "https://deno.land/std@0.177.0/async/abortable.ts": "73acfb3ed7261ce0d930dbe89e43db8d34e017b063cf0eaa7d215477bf53442e",
    "https://deno.land/std@0.177.0/async/deadline.ts": "c5facb0b404eede83e38bd2717ea8ab34faa2ffb20ef87fd261fcba32ba307aa",
    "https://deno.land/std@0.177.0/async/debounce.ts": "adab11d04ca38d699444ac8a9d9856b4155e8dda2afd07ce78276c01ea5a4332",
    "https://deno.land/std@0.177.0/async/deferred.ts": "42790112f36a75a57db4a96d33974a936deb7b04d25c6084a9fa8a49f135def8",
    "https://deno.land/std@0.177.0/async/delay.ts": "73aa04cec034c84fc748c7be49bb15cac3dd43a57174bfdb7a4aec22c248f0dd",
    "https://deno.land/std@0.177.0/async/mod.ts": "f04344fa21738e5ad6bea37a6bfffd57c617c2d372bb9f9dcfd118a1b622e576",
    "https://deno.land/std@0.177.0/async/mux_async_iterator.ts": "70c7f2ee4e9466161350473ad61cac0b9f115cff4c552eaa7ef9d50c4cbb4cc9",
    "https://deno.land/std@0.177.0/async/pool.ts": "fd082bd4aaf26445909889435a5c74334c017847842ec035739b4ae637ae8260",
    "https://deno.land/std@0.177.0/async/retry.ts": "5efa3ba450ac0c07a40a82e2df296287b5013755d232049efd7ea2244f15b20f",
    "https://deno.land/std@0.177.0/async/tee.ts": "47e42d35f622650b02234d43803d0383a89eb4387e1b83b5a40106d18ae36757",
    "https://deno.land/std@0.177.0/http/server.ts": "cbb17b594651215ba95c01a395700684e569c165a567e4e04bba327f41197433",
    "https://deno.land/std@0.224.0/async/delay.ts": "f90dd685b97c2f142b8069082993e437b1602b8e2561134827eeb7c12b95c499",
    "https://deno.land/std@0.224.0/dotenv/load.ts": "587b342f0f6a3df071331fe6ba1c823729ab68f7d53805809475e486dd4161d7",
    "https://deno.land/std@0.224.0/dotenv/mod.ts": "0180eaeedaaf88647318811cdaa418cc64dc51fb08354f91f5f480d0a1309f7d",
    "https://deno.land/std@0.224.0/dotenv/parse.ts": "09977ff88dfd1f24f9973a338f0f91bbdb9307eb5ff6085446e7c423e4c7ba0c",
    "https://deno.land/std@0.224.0/dotenv/stringify.ts": "275da322c409170160440836342eaa7cf012a1d11a7e700d8ca4e7f2f8aa4615",
    "https://deno.land/std@0.224.0/http/server.ts": "f9313804bf6467a1704f45f76cb6cd0a3396a3b31c316035e6a4c2035d1ea514",
    "https://esm.sh/@supabase/auth-js@2.69.1/denonext/auth-js.mjs": "fb31c3925437753f5a8a90fc57ea24dc5b68b2b295e696123b1b6a635b7b3ada",
    "https://esm.sh/@supabase/functions-js@2.4.4/denonext/functions-js.mjs": "7adeb257410ef3c4a8a1eb9b4ff416c0075d1c32860ca04913c8a9dace1de6a6",
    "https://esm.sh/@supabase/node-fetch@2.6.15/denonext/node-fetch.mjs": "0bae9052231f4f6dbccc7234d05ea96923dbf967be12f402764580b6bf9f713d",
    "https://esm.sh/@supabase/node-fetch@2.6.15?target=denonext": "4d28c4ad97328403184353f68434f2b6973971507919e9150297413664919cf3",
    "https://esm.sh/@supabase/postgrest-js@1.19.4/denonext/postgrest-js.mjs": "2073b5552ba10c7a8302bffffae771e3aede1daf833382355dae239fb0ab2576",
    "https://esm.sh/@supabase/realtime-js@2.11.2/denonext/realtime-js.mjs": "c33ac375b6be89c893f9df844d2525a4ace015a35aa6ba236270d00c6605c7ba",
    "https://esm.sh/@supabase/storage-js@2.7.1/denonext/storage-js.mjs": "73ac8cdc95cfcd794fe603dbd7ce06d539ab51538ae6467eabe0f9cc26c993aa",
    "https://esm.sh/@supabase/supabase-js@2.49.4": "d52c4d06946766d328fdd0ac2e007f52bb6d2ef7ce6103ad9f0f57d92b73e978",
    "https://esm.sh/@supabase/supabase-js@2.49.4/denonext/supabase-js.mjs": "8c664dda021a5abc7c0b1f49d89d5886a7f9c63c9d365eb3764e1e27440bd781",
    "https://esm.sh/bufferutil@4.0.9/denonext/bufferutil.mjs": "13dca4d5bb2c68cbe119f880fa3bd785b9a81a8e02e0834dae604b4b85295cd8",
    "https://esm.sh/bufferutil@4.0.9?target=denonext": "e32574569ab438facfcc3f412c659b0719bbf05477136ca176938c9a3ac45125",
    "https://esm.sh/node-gyp-build@4.8.4/denonext/node-gyp-build.mjs": "9a86f2d044fc77bd60aaa3d697c2ba1b818da5fb1b9aaeedec59a40b8e908803",
    "https://esm.sh/node-gyp-build@4.8.4?target=denonext": "261a6cedf1fdbf159798141ba1e2311ac1510682c5c8b55dacc8cf5fdee4aa06",
    "https://esm.sh/tr46@0.0.3/denonext/tr46.mjs": "5753ec0a99414f4055f0c1f97691100f13d88e48a8443b00aebb90a512785fa2",
    "https://esm.sh/tr46@0.0.3?target=denonext": "19cb9be0f0d418a0c3abb81f2df31f080e9540a04e43b0f699bce1149cba0cbb",
    "https://esm.sh/utf-8-validate@6.0.5/denonext/utf-8-validate.mjs": "66b8ea532a0c745068f5b96ddb1bae332c3036703243541d2e89e66331974d98",
    "https://esm.sh/utf-8-validate@6.0.5?target=denonext": "071bc33ba1a58297e23a34d69dd589fd06df04b0f373b382ff5da544a623f271",
    "https://esm.sh/webidl-conversions@3.0.1/denonext/webidl-conversions.mjs": "54b5c2d50a294853c4ccebf9d5ed8988c94f4e24e463d84ec859a866ea5fafec",
    "https://esm.sh/webidl-conversions@3.0.1?target=denonext": "4e20318d50528084616c79d7b3f6e7f0fe7b6d09013bd01b3974d7448d767e29",
    "https://esm.sh/whatwg-url@5.0.0/denonext/whatwg-url.mjs": "29b16d74ee72624c915745bbd25b617cfd2248c6af0f5120d131e232a9a9af79",
    "https://esm.sh/whatwg-url@5.0.0?target=denonext": "f001a2cadf81312d214ca330033f474e74d81a003e21e8c5d70a1f46dc97b02d",
    "https://esm.sh/ws@8.18.2/denonext/ws.mjs": "b9211ecb1511b09f418c1330920c66800b66710b2cd2997b64b7e0525bd895d2",
    "https://esm.sh/ws@8.18.2?target=denonext": "2ee7b1bb11543dda3e7e1c685ad8599b6f18aea785302374c3def5da468a1e51"
  },
  "workspace": {
    "packageJson": {
      "dependencies": [
        "npm:@google/generative-ai@~0.24.1",
        "npm:@notionhq/client@^3.0.1",
        "npm:@slack/web-api@^7.9.1",
        "npm:@supabase/supabase-js@^2.49.4",
        "npm:@types/uuid@10",
        "npm:formdata-node@^6.0.3",
        "npm:openai@^4.100.0",
        "npm:uuid@^11.1.0"
      ]
    },
    "members": {
      "apps/aimtg": {
        "packageJson": {
          "dependencies": [
            "npm:@google/generative-ai@~0.24.1",
            "npm:@notionhq/client@^3.0.1",
            "npm:@slack/web-api@^7.9.1",
            "npm:@supabase/supabase-js@^2.49.4",
            "npm:@types/node@^22.15.18",
            "npm:@types/react@^19.1.4",
            "npm:@types/uuid@10",
            "npm:formdata-node@^6.0.3",
            "npm:next@^15.3.2",
            "npm:openai@^4.100.0",
            "npm:typescript@^5.8.3",
            "npm:uuid@^11.1.0"
          ]
        }
      }
    }
  }
}

================
File: supabase/config.toml
================
[functions.process-video-task]
enabled = true
verify_jwt = false
entrypoint = "./functions/process-video-task/index.ts"

[functions.transcribe_with_whisper]
enabled = true
verify_jwt = false
entrypoint = "./functions/transcribe_with_whisper/index.ts"

[functions.upload_file_to_storage]
enabled = true
verify_jwt = false
entrypoint = "./functions/upload_file_to_storage/index.ts"

[functions.summarize_dispatch]
enabled = true
verify_jwt = false
entrypoint = "./functions/summarize_dispatch/index.ts"

================
File: supabase/migrations/20231105_create_upload_logs.sql
================
-- supabase/migrations/20231105_create_upload_logs.sql

-- アップロードの進捗と状態を追跡するテーブル
CREATE TABLE IF NOT EXISTS public.upload_logs (
  id TEXT PRIMARY KEY, -- 一意のアップロードID
  task_id UUID REFERENCES public.transcription_tasks(id), -- 関連するタスクID（後から設定される可能性あり）
  file_name TEXT NOT NULL, -- アップロードされたファイル名
  storage_path TEXT, -- Supabase Storage内のパス
  status TEXT NOT NULL, -- アップロードステータス (preparing/uploading/uploaded/processing/completed/failed)
  content_type TEXT NOT NULL, -- ファイルのContent-Type
  file_size BIGINT, -- ファイルサイズ（バイト）
  progress INTEGER, -- アップロード進捗（パーセント）
  error_message TEXT, -- エラー発生時のメッセージ
  metadata JSONB, -- 追加情報（任意）
  slack_file_id TEXT, -- Slack File ID
  slack_download_url TEXT, -- Slack ダウンロードURL
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(), -- 作成日時
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now() -- 更新日時
);

-- インデックス
CREATE INDEX IF NOT EXISTS idx_upload_logs_status ON public.upload_logs(status);
CREATE INDEX IF NOT EXISTS idx_upload_logs_created_at ON public.upload_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_upload_logs_task_id ON public.upload_logs(task_id);

-- Row Level Security
ALTER TABLE public.upload_logs ENABLE ROW LEVEL SECURITY;

-- 認証済みユーザーのみ読み取り可能
CREATE POLICY "Authenticated users can read upload logs" 
  ON public.upload_logs FOR SELECT 
  USING (auth.role() = 'authenticated');

-- 認証済みユーザーが挿入可能
CREATE POLICY "Authenticated users can insert upload logs" 
  ON public.upload_logs FOR INSERT 
  WITH CHECK (auth.role() = 'authenticated');

-- 認証済みユーザーが自分の作成したレコードを更新可能
CREATE POLICY "Authenticated users can update own upload logs" 
  ON public.upload_logs FOR UPDATE
  USING (auth.role() = 'authenticated');

-- 更新日時自動更新トリガー
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_upload_logs_updated_at
BEFORE UPDATE ON public.upload_logs
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column();

-- サービスロールはすべての操作が可能
CREATE POLICY "Service role can perform all operations" 
  ON public.upload_logs FOR ALL 
  USING (auth.role() = 'service_role')
  WITH CHECK (auth.role() = 'service_role');

COMMENT ON TABLE public.upload_logs IS '動画ファイルのアップロード進捗と状態を追跡するテーブル';

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "noEmit": true,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "supabase/functions/**/*"
  ]
}

================
File: app/api/notion-sync/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { Client as NotionClient } from '@notionhq/client';
import type { CreatePageParameters, BlockObjectRequest } from '@notionhq/client/build/src/api-endpoints';
import { createClient, SupabaseClient } from '@supabase/supabase-js';

// 環境変数
const NOTION_API_KEY = process.env.NOTION_API_KEY;
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

// 初期化
const notion = NOTION_API_KEY ? new NotionClient({ auth: NOTION_API_KEY }) : null;
const supabase: SupabaseClient | null = (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY)
  ? createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, { auth: { persistSession: false } })
  : null;

interface NotionSyncPayload { taskId: string; }

interface TranscriptionTask {
  id: string;
  consultant_name?: string;
  company_name?: string;
  company_type?: string;
  company_problem?: string;
  meeting_date?: string;
  meeting_count?: number;
  meeting_type?: string; // lintで未使用指摘があったが、もし使うならこの型定義は残す
  support_area?: string;
  company_phase?: string;
  internal_sharing_items?: string;
  final_summary: string;
  status: string;
  error_message?: string;
  notion_page_id?: string;
  created_at?: string;
  updated_at?: string;
}

interface NotionDbMap {
  id: string;
  kind: 'all' | 'consultant' | 'company';
  name: string;
  page_id: string;
  db_id: string;
  updated_at: string;
}

export async function POST(req: NextRequest) {
  // 認可
  if (!WEBHOOK_SECRET) return NextResponse.json({ error: 'Server misconfig' }, { status: 500 });
  const auth = req.headers.get('Authorization');
  if (!auth || !auth.startsWith('Bearer ') || auth.substring(7) !== WEBHOOK_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  if (!supabase || !notion) {
    return NextResponse.json({ error: 'Server not configured (supabase or notion)' }, { status: 500 });
  }

  let payload: NotionSyncPayload;
  try { payload = await req.json(); }
  catch { return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 }); }
  const { taskId } = payload;
  if (!taskId) return NextResponse.json({ error: 'taskId required' }, { status: 400 });

  // 1. transcription_tasks 取得
  const { data: taskData, error: tErr } = await supabase
    .from('transcription_tasks')
    .select('*')
    .eq('id', taskId)
    .single();

  const task = taskData as TranscriptionTask | null;

  if (tErr || !task) {
    return NextResponse.json({ error: 'Task not found' }, { status: 404 });
  }

  const {
    consultant_name = 'なし',
    company_name = 'なし',
    company_type = 'エラー',
    company_problem = 'なし',
    meeting_date = 'なし',
    meeting_count,
    meeting_type: _meeting_type = 'エラー',
    support_area = 'エラー',
    company_phase = 'なし',
    internal_sharing_items = 'なし',
    final_summary,
  } = task;

  if (!final_summary) {
    return NextResponse.json({ error: 'final_summary missing' }, { status: 400 });
  }

  // 2. map 取得
  const { data: mapsRaw, error: mErr } = await supabase
    .from('notion_db_map')
    .select('*')
    .in('kind', ['all', 'consultant', 'company'])
    .in('name', [consultant_name, company_name, 'all']);

  if (mErr) {
    return NextResponse.json({ error: mErr.message }, { status: 500 });
  }

  const maps = (mapsRaw ?? []) as NotionDbMap[];

  const getDb = (
    mapsArr: NotionDbMap[],
    kind: 'all' | 'consultant' | 'company',
    nameVal: string,
  ): NotionDbMap | undefined => mapsArr.find((m) => m.kind === kind && m.name === nameVal);

  const allMap = getDb(maps, 'all', 'all');
  const consMap = getDb(maps, 'consultant', consultant_name);
  const compMap = getDb(maps, 'company', company_name);

  if (!allMap || !consMap || !compMap) {
    await supabase.from('transcription_tasks').update({ status: 'notion_failed', error_message: 'Mapping not found' }).eq('id', taskId);
    return NextResponse.json({ error: 'Mapping not found for some target DB' }, { status: 400 });
  }

  // この時点で allMap, consMap, compMap は NotionDbMap 型であることが保証される
  const targets: NotionDbMap[] = [allMap, consMap, compMap];

  const buildProperties = () => ({
    '面談日': { title: [{ text: { content: `${meeting_date}` } }] },
    '企業名': { rich_text: [{ text: { content: company_name || 'なし' } }] },
    'コンサルタント名': { rich_text: [{ text: { content: consultant_name || 'なし' } }] },
    '企業タイプ': { status: { name: company_type || 'エラー' } },
    '企業の課題': { rich_text: [{ text: { content: company_problem || 'なし' } }] },
    '面談回数': { number: meeting_count ?? null },
    '支援領域': { status: { name: support_area || 'エラー' } },
    '企業のフェーズ': { rich_text: [{ text: { content: company_phase || 'なし' } }] },
    '社内共有が必要な事項': { rich_text: [{ text: { content: internal_sharing_items || 'なし' } }] },
  });

  const children: BlockObjectRequest[] = [
    {
      type: 'paragraph',
      paragraph: {
        rich_text: [{ type: 'text', text: { content: final_summary } }],
      },
    },
  ];

  const createPage = async (dbId: string) => {
    const properties = buildProperties() as CreatePageParameters['properties'];
    return await notion.pages.create({ parent: { database_id: dbId }, properties, children });
  };

  try {
    const results = await Promise.all(targets.map(t => createPage(t.db_id)));
    await supabase.from('transcription_tasks').update({ notion_page_id: JSON.stringify({ all: results[0].id, consultant: results[1].id, company: results[2].id }) }).eq('id', taskId);
    return NextResponse.json({ message: 'Notion pages created', ids: results.map(r => r.id) });
  } catch (e) {
    await supabase.from('transcription_tasks').update({ status: 'notion_failed', error_message: (e as Error).message }).eq('id', taskId);
    return NextResponse.json({ error: 'Failed to create notion pages', details: (e as Error).message }, { status: 500 });
  }
}

================
File: app/api/upload-url/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// 内部API呼び出し認証用のシークレットキー (環境変数から取得)
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

const STORAGE_BUCKET_NAME = 'videos'; // Supabase Storageのバケット名
const SIGNED_URL_TTL = 60 * 30; // 署名付きURLの有効期間（秒）：30分

export async function POST(request: NextRequest) {
  console.log(`[${new Date().toISOString()}] /api/upload-url: POST request received.`);

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

  if (!supabaseUrl || !supabaseAnonKey) {
    console.error(`[${new Date().toISOString()}] /api/upload-url: Missing Supabase URL or anon key environment variables.`);
    return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
  }

  const supabase = createClient(supabaseUrl, supabaseAnonKey);

  // 1. 認可チェック
  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.substring(7) !== WEBHOOK_SECRET) {
    console.warn(`[${new Date().toISOString()}] /api/upload-url: Unauthorized access attempt.`);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  console.log(`[${new Date().toISOString()}] /api/upload-url: Authorization successful.`);

  // 2. リクエストボディのパース
  let fileName: string;
  let contentType: string;
  try {
    const body = await request.json();
    fileName = body.fileName;
    contentType = body.contentType;
    if (!fileName || typeof fileName !== 'string' || !contentType || typeof contentType !== 'string') {
      throw new Error('Invalid request body: fileName and contentType are required and must be strings.');
    }

    // 追加：fileNameが.mp4で終わるかチェック
    if (!fileName.endsWith('.mp4')) {
      console.warn(`[${new Date().toISOString()}] /api/upload-url: Invalid fileName: ${fileName}. Only .mp4 files are accepted.`);
      return NextResponse.json({ error: 'Only .mp4 files are accepted (filename must end with .mp4)' }, { status: 400 });
    }

    // 追加：contentTypeがvideo/mp4かチェック
    if (contentType !== 'video/mp4') {
      console.warn(`[${new Date().toISOString()}] /api/upload-url: Invalid contentType: ${contentType}. Only video/mp4 is accepted.`);
      return NextResponse.json({ error: 'Only video/mp4 content type is accepted' }, { status: 400 });
    }

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error parsing request body.';
    console.error(`[${new Date().toISOString()}] /api/upload-url: Error parsing request body: ${errorMessage}`);
    return NextResponse.json({ error: 'Invalid request body', details: errorMessage }, { status: 400 });
  }
  console.log(`[${new Date().toISOString()}] /api/upload-url: Parsed request body:`, { fileName, contentType });

  // 3. 署名付きアップロードURLの生成
  // storagePathの例: public/mtg-assets/videos/{task_id}/{fileName}
  // ここでは {task_id} の部分はまだないので、一旦ランダムなプレフィックスまたはfileNameのみでパスを生成する。
  // task_idはintake側で生成されるため、upload-url側ではファイル名の一意性を保つパスを生成する。
  // 例: videos/YYYY/MM/DD/uuid_or_timestamp_fileName
  const timestamp = Date.now();
  const uniqueFileName = `${timestamp}_${fileName.replace(/[^a-zA-Z0-9._-]/g, '_')}`;
  const storagePath = `videos/${uniqueFileName}`; // バケット直下のvideosフォルダに保存する例
                                              // 設計書の storagePath: "public/mtg-assets/videos/{task_id}/{fileName}" とは異なるので注意
                                              // ここはintake側で最終的なパスを決定し、DBに保存する。
                                              // upload-urlはあくまでアップロード先を一時的に提供する。

  try {
    console.log(`[${new Date().toISOString()}] /api/upload-url: Attempting to create signed upload URL for: ${storagePath}`);
    const { data, error } = await supabase.storage
      .from(STORAGE_BUCKET_NAME)
      .createSignedUploadUrl(storagePath);

    if (error) {
      console.error(`[${new Date().toISOString()}] /api/upload-url: Supabase storage error (createSignedUploadUrl):`, error);
      return NextResponse.json({ error: 'Failed to create upload URL', details: error.message }, { status: 500 });
    }

    if (!data || !data.signedUrl) {
        console.error(`[${new Date().toISOString()}] /api/upload-url: Supabase storage did not return a signedUrl.`);
        return NextResponse.json({ error: 'Failed to obtain upload URL from storage provider'}, { status: 500 });
    }

    console.log(`[${new Date().toISOString()}] /api/upload-url: Signed upload URL created successfully for path: ${storagePath}`);
    return NextResponse.json({
      uploadUrl: data.signedUrl,
      storagePath: data.path, // Supabaseが返した実際のパス (createSignedUploadUrlの第一引数と同じはず)
    });

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown server error.';
    console.error(`[${new Date().toISOString()}] /api/upload-url: Unexpected server error: ${errorMessage}`);
    return NextResponse.json({ error: 'Unexpected server error', details: errorMessage }, { status: 500 });
  }
}

================
File: package.json
================
{
  "name": "dagitoru-mtglog",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.2.0",
    "@notionhq/client": "^2.2.14",
    "@supabase/auth-helpers-nextjs": "^0.9.0",
    "@supabase/supabase-js": "^2.39.0",
    "dotenv": "^16.4.5",
    "next": "14.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "@types/react": "^18.2.45",
    "@types/react-dom": "^18.2.17",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-config-next": "14.0.4",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.3.3"
  }
}

================
File: supabase/functions/upload_file_to_storage/index.ts
================
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient, SupabaseClient } from "npm:@supabase/supabase-js@2.43.4"; // バージョンを固定または適切に管理
import "https://deno.land/std@0.224.0/dotenv/load.ts"; // ローカル開発用に .env を読み込む場合

// SupabaseダッシュボードのSecrets名に合わせる
const SUPABASE_URL_FROM_ENV = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY_FROM_ENV = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
const SLACK_BOT_TOKEN_FROM_ENV = Deno.env.get("SLACK_BOT_TOKEN");

interface TaskPayload {
  taskId: string;
  slack_file_id?: string; // APIから呼ばれる場合は必須ではないかもしれないのでオプショナル
  slack_download_url: string;
  original_file_name: string;
  mimetype: string;
  filetype: string;
}

async function updateTaskStatus(
  supabase: SupabaseClient,
  taskId: string,
  status: string,
  updatePayload: Record<string, unknown> = {}
): Promise<void> {
  const { error } = await supabase
    .from("transcription_tasks")
    .update({ status, ...updatePayload, updated_at: new Date().toISOString() })
    .eq("id", taskId);
  if (error) {
    console.error(`Error updating task ${taskId} to ${status}:`, error.message);
    // ここでさらに堅牢なエラー通知処理を入れることも検討 (例: Slack通知)
  }
}

serve(async (req: Request) => {
  if (!SUPABASE_URL_FROM_ENV || !SUPABASE_SERVICE_ROLE_KEY_FROM_ENV || !SLACK_BOT_TOKEN_FROM_ENV) {
    console.error("Missing one or more required environment variables. Check SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, SLACK_BOT_TOKEN.");
    return new Response(JSON.stringify({ error: "Internal server configuration error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  const supabaseAdmin = createClient(SUPABASE_URL_FROM_ENV, SUPABASE_SERVICE_ROLE_KEY_FROM_ENV);
  let payload: TaskPayload;

  try {
    payload = await req.json();
    console.log("Received payload:", payload);
  } catch (e) {
    console.error("Failed to parse request body:", e);
    return new Response(JSON.stringify({ error: "Invalid request body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  const {
    taskId,
    slack_download_url,
    original_file_name,
    mimetype,
    filetype,
  } = payload;

  if (!taskId || !slack_download_url || !original_file_name || !mimetype || !filetype) {
    console.error("Missing required fields in payload:", payload);
    return new Response(JSON.stringify({ error: "Missing required fields in payload" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    console.log(`[${taskId}] Starting file download from Slack: ${slack_download_url}`);
    const slackFileResponse = await fetch(slack_download_url, {
      headers: {
        Authorization: `Bearer ${SLACK_BOT_TOKEN_FROM_ENV}`,
      },
    });

    if (!slackFileResponse.ok || !slackFileResponse.body) {
      const errorBody = await slackFileResponse.text();
      console.error(
        `[${taskId}] Failed to download file from Slack: ${slackFileResponse.status}`,
        errorBody
      );
      await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
        error_message: `Slack download failed: ${slackFileResponse.status} - ${errorBody.substring(0, 200)}`,
      });
      return new Response(
        JSON.stringify({ error: "Failed to download file from Slack" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }
    console.log(`[${taskId}] File downloaded from Slack. Preparing to stream to Supabase Storage...`);

    let fileExtension = filetype || "dat";
    // MIMEタイプからの拡張子推測ロジック (Vercel APIからコピー＆改善も検討)
    if (mimetype.startsWith("video/")) {
      fileExtension = mimetype.split("/")[1];
    } else if (mimetype.startsWith("audio/")) {
      fileExtension = mimetype.split("/")[1] === "mpeg" ? "mp3" : mimetype.split("/")[1];
    }
    if (fileExtension === "quicktime") fileExtension = "mov";
    // 不明な拡張子の場合のフォールバックや、より堅牢なマッピングが必要な場合も

    const storagePath = `uploads/${taskId}.${fileExtension}`;
    console.log(`[${taskId}] Uploading to Supabase Storage: ${storagePath} with type ${mimetype} using stream`);

    const { data: uploadResult, error: uploadError } =
      await supabaseAdmin.storage
        .from("videos")
        .upload(storagePath, slackFileResponse.body, {
          contentType: mimetype,
          upsert: false, // true にして再試行を許容するか検討
          duplex: "half", // DenoのReadableStreamを扱うために追加
        });

    if (uploadError) {
      console.error(`[${taskId}] Failed to upload to Supabase Storage:`, uploadError);
      await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
        error_message: `Supabase Storage upload failed: ${uploadError.message}`,
      });
      return new Response(
        JSON.stringify({ error: "Failed to upload to Supabase Storage" }),
        { status: 500, headers: { "Content-Type": "application/json" } }
      );
    }

    console.log(`[${taskId}] File uploaded to Supabase Storage:`, uploadResult);
    await updateTaskStatus(supabaseAdmin, taskId, "uploaded", { // ステータスを 'uploaded' に変更
      storage_path: storagePath,
      error_message: null, // エラーが解消された場合はクリア
    });

    return new Response(JSON.stringify({ message: "File uploaded and task updated successfully", taskId, storagePath }), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });

  } catch (error) {
    console.error(`[${taskId}] Unexpected error in upload_file_to_storage:`, error);
    await updateTaskStatus(supabaseAdmin, taskId, "upload_failed", {
      error_message: error instanceof Error ? error.message : String(error),
    });
    return new Response(JSON.stringify({ error: "Unexpected server error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
});

================
File: .gitignore
================
# Local environment variables
.env.local

# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json

# IDE files
.vscode/
.idea/

# OS generated files
.DS_Store
Thumbs.db
node_modules

# Deno
.deno_cache/

# Next.js build output
.next/

# Compiled JS dist
/dist/

================
File: cloudrun-transcriber/index.js
================
require('dotenv').config({ path: '../.env.local' }); // .env.local はCloud Runでは使われません
const express = require('express');
const { Storage } = require('@google-cloud/storage');
const speech = require('@google-cloud/speech');
const fetch = require('node-fetch'); // package.json とバージョン一致
const ffmpeg = require('fluent-ffmpeg');
const ffmpegPath = require('ffmpeg-static'); // ← 存在します
const fs = require('fs');
const path = require('path');
const os = require('os');

if (process.env.GOOGLE_CREDENTIALS_BASE64) {
  try {
    const decodedCredentials = Buffer.from(process.env.GOOGLE_CREDENTIALS_BASE64, 'base64').toString('utf-8');
    const credsPath = '/tmp/gcp-creds.json'; // Cloud Runでは /tmp が書き込み可能なメモリファイルシステムです
    fs.writeFileSync(credsPath, decodedCredentials);
    process.env.GOOGLE_APPLICATION_CREDENTIALS = credsPath;
    console.log(`GOOGLE_APPLICATION_CREDENTIALS set to ${credsPath}`); // 起動ログで確認用
  } catch (error) {
    console.error('CRITICAL: Failed to process GOOGLE_CREDENTIALS_BASE64. Application may not authenticate with Google Cloud services.', error);
    // エラー発生時の挙動を考慮（例: プロセス終了も検討）
    // process.exit(1);
  }
}

const app = express();
app.use(express.json());

const storage = new Storage();
const speechClient = new speech.SpeechClient();

ffmpeg.setFfmpegPath(ffmpegPath);

app.post('/transcribe', async (req, res) => {
  // 追加: 受信ヘッダーを全てログ出力
  console.log("Headers received:", req.headers);

  // 認証ヘッダーの防御的検証
  const authHeader = req.headers["x-vercel-secret"];
  if (!authHeader) {
    console.warn("/transcribe: Missing x-vercel-secret header", authHeader);
    return res.status(401).send("Missing x-vercel-secret header");
  }
  if (authHeader !== process.env.WEBHOOK_SECRET) {
    console.warn("/transcribe: Unauthorized - token mismatch");
    return res.status(401).send("Unauthorized");
  }

  console.log(`/transcribe: Received request. Body:`, JSON.stringify(req.body, null, 2));
  const { signedUrl, gcsBucket, gcsDestPath, taskId } = req.body;
  if (!signedUrl || !gcsBucket || !gcsDestPath || !taskId) {
    console.error('/transcribe: Missing required parameters', req.body);
    return res.status(400).json({ error: 'Missing required parameters' });
  }

  const tmpVideoPath = path.join(os.tmpdir(), `input_${Date.now()}.mp4`);
  const tmpAudioPath = path.join(os.tmpdir(), `audio_${Date.now()}.mp3`);

  try {
    // 1. Supabase署名付きURLから動画ダウンロード
    console.log(`/transcribe: Downloading video from signed URL for task ${taskId}`);
    const videoRes = await fetch(signedUrl);
    if (!videoRes.ok) throw new Error(`Failed to download video from Supabase: ${videoRes.status} ${videoRes.statusText}`);
    const fileStream = fs.createWriteStream(tmpVideoPath);
    await new Promise((resolve, reject) => {
      videoRes.body.pipe(fileStream);
      videoRes.body.on('error', reject);
      fileStream.on('finish', resolve);
    });
    console.log(`/transcribe: Video downloaded successfully to ${tmpVideoPath}`);

    // 2. FFmpegで音声抽出
    console.log(`/transcribe: Extracting audio from video for task ${taskId}`);
    await new Promise((resolve, reject) => {
      ffmpeg(tmpVideoPath)
        .noVideo()
        .audioCodec('libmp3lame')
        .audioFrequency(16000)
        .audioChannels(1)
        .audioBitrate('64k')
        .save(tmpAudioPath)
        .on('end', resolve)
        .on('error', reject);
    });
    console.log(`/transcribe: Audio extracted successfully to ${tmpAudioPath}`);

    // 3. GCSにアップロード
    console.log(`/transcribe: Uploading audio to GCS bucket ${gcsBucket}/${gcsDestPath}`);
    await storage.bucket(gcsBucket).upload(tmpAudioPath, {
      destination: gcsDestPath,
    });
    const gcsUri = `gs://${gcsBucket}/${gcsDestPath}`;
    console.log(`/transcribe: Audio uploaded successfully to ${gcsUri}`);

    // 4. Speech-to-Text
    console.log(`/transcribe: Starting speech recognition for task ${taskId}`);
    const request = {
      audio: { uri: gcsUri },
      config: {
        encoding: 'MP3',
        sampleRateHertz: 16000,
        languageCode: 'ja-JP',
      },
    };
    const [operation] = await speechClient.longRunningRecognize(request);
    console.log(`/transcribe: Waiting for speech recognition to complete for task ${taskId}`);
    const [response] = await operation.promise();
    const finalTranscript = response.results.map(r => r.alternatives[0].transcript).join('\n');
    console.log(`/transcribe: Speech recognition completed for task ${taskId}, transcript length: ${finalTranscript.length} chars`);

    // 5. /api/summarize-task へPOST
    if (finalTranscript && process.env.SUMMARIZE_TASK_ENDPOINT && process.env.WEBHOOK_SECRET) {
      console.log(`/transcribe: Posting transcript to summarize-task endpoint for task ${taskId}`);
      const summarizeRes = await fetch(process.env.SUMMARIZE_TASK_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.WEBHOOK_SECRET}`
        },
        body: JSON.stringify({
          taskId,
          transcript: finalTranscript
        })
      });
      if (!summarizeRes.ok) {
        const errText = await summarizeRes.text();
        console.error(`/transcribe: /api/summarize-task failed: ${summarizeRes.status} ${errText}`);
        throw new Error(`/api/summarize-task failed: ${summarizeRes.status} ${errText}`);
      }
      console.log(`/transcribe: Transcript successfully sent to summarize-task endpoint for task ${taskId}`);
    } else {
      console.warn(`/transcribe: Not sending to summarize-task - Missing endpoint URL or webhook secret, or empty transcript`);
    }

    // 6. クリーンアップ
    console.log(`/transcribe: Cleaning up temporary files for task ${taskId}`);
    fs.unlinkSync(tmpVideoPath);
    fs.unlinkSync(tmpAudioPath);
    // await storage.bucket(gcsBucket).file(gcsDestPath).delete(); // 必要なら

    console.log(`/transcribe: Process completed successfully for task ${taskId}`);
    res.status(200).json({ message: 'Transcription and summarize-task POST successful', taskId });

  } catch (err) {
    // クリーンアップ
    console.error(`/transcribe: Error processing task ${taskId}:`, err);
    if (fs.existsSync(tmpVideoPath)) fs.unlinkSync(tmpVideoPath);
    if (fs.existsSync(tmpAudioPath)) fs.unlinkSync(tmpAudioPath);
    res.status(500).json({ error: err.message });
  }
});

// ヘルスチェック用のエンドポイント
app.get('/', (req, res) => {
  res.status(200).json({ status: 'ok', message: 'Cloud Run transcriber service is running' });
});

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Cloud Run transcription service listening on port ${PORT}`);
});

================
File: README.md
================
# Slack 動画要約プロジェクト

このプロジェクトは、Slackに投稿された動画を自動で文字起こしし、要約を作成して通知するシステムです。

## 構成

- `apps/webhook-vercel`: Slackイベントを受信し、Supabaseに処理要求を登録するNext.jsアプリケーション (Vercelデプロイ想定)
- `services/transcriber`: 動画の文字起こしと要約を行うPythonバッチ処理
- `scripts`: 補助スクリプト (例: 特定動画の再処理)
- `docs`: 仕様書など
ああああああ
## セットアップと実行

(各サービスごとの詳細を記述)

### `webhook-vercel`

...

### `transcriber`

... 
(Ensuring commit for package-lock.json move.) 

# Edge / Node アーキテクチャについて

このプロジェクトでは、Edge（Deno）環境とNode.js環境を適切に使い分けています。

## 環境分離と責務

| 処理内容 | 環境 | 実装パス | 理由 |
|--------|------|---------|------|
| Slack → Supabase アップロード | **Node.js** | `app/utils/slack-to-supabase-uploader.ts` | ストリーム処理や大容量ファイル転送はNodeが適している |
| 文字起こし処理 | **Edge (Deno)** | `supabase/functions/transcribe_with_whisper/index.ts` | 軽量なAPIリクエスト処理に最適化 |
| 要約処理 | **Edge (Node API)** | `app/api/summarize-task/route.ts` | 複雑なAI処理と複数の非同期処理 |
| Notion連携 | **Edge (Node API)** | `app/api/notion-sync/route.ts` | 外部APIとのインテグレーション |

## 開発環境設定

### Deno (Edge Functions)

```bash
# Supabase Edge Functions の依存関係チェック
cd supabase
deno cache --reload functions/**/*.ts

# Edge Functions をローカルで実行
supabase functions serve --env-file ../.env.local
```

### Node.js (API Routes)

```bash
# 開発サーバー起動
npm run dev:webhook

# Slack ファイルアップロード
npm run upload-slack -- <slack-file-url>
```

================
File: supabase/functions/process-video-task/index.ts
================
/// <reference lib="deno.ns" />
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient, SupabaseClient } from "npm:@supabase/supabase-js@2.43.4";
import "https://deno.land/std@0.224.0/dotenv/load.ts";

function getEnvVar(key: string): string {
  const value = Deno.env.get(key);
  if (!value) throw new Error(`Environment variable ${key} not set`);
  return value;
}

async function _updateTaskStatus(
  supabase: SupabaseClient,
  taskId: string,
  status: string,
  errorMessage?: string | null
): Promise<void> {
  const updates: { status: string; error_message?: string; notified_at?: string } = {
    status,
    // notified_at: new Date().toISOString(), // カラムが存在し、更新したい場合のみ有効化
  };
  if (errorMessage) {
    updates.error_message = errorMessage;
  }
  const { error } = await supabase
    .from("transcription_tasks")
    .update(updates)
    .eq("id", taskId);
  if (error) console.error(`Error updating task to ${status}:`, error.message);
  else console.log(`Task ${taskId} status updated to ${status}.`);
}

serve(async (req: Request) => {
  const cors = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
  };

  if (req.method === "OPTIONS") return new Response("ok", { headers: cors });

  let supabase: SupabaseClient | null = null;
  let taskId: string | null = null; 

  try {
    const { taskId: receivedTaskId, storagePath } = await req.json();
    
    if (!receivedTaskId || !storagePath) {
      console.error("taskId or storagePath missing in payload:", { receivedTaskId, storagePath });
      throw new Error("taskId or storagePath missing in payload");
    }
    taskId = receivedTaskId; 

    const supabaseUrl = getEnvVar("SUPABASE_URL");
    const serviceRoleKey = getEnvVar("SUPABASE_SERVICE_ROLE_KEY");
    supabase = createClient(supabaseUrl, serviceRoleKey);

    // VERCEL_WEBHOOK_URL を使用した通知処理を削除
    console.log(`Task ${taskId} (storagePath: ${storagePath}) received by process-video-task. Vercel notification via VERCEL_WEBHOOK_URL is now disabled.`);

    // このFunctionが他に担っていた処理があればここに残ります。
    // 現状、Vercelへの通知が主目的だった場合、このFunctionはほとんど何もしないことになります。
    // 必要に応じて、完了を示すステータス更新などをここで行うことができます。
    // 例: await updateTaskStatus(supabase, taskId!, "processed_by_task_function_no_webhook");


    return new Response(JSON.stringify({ message: "process-video-task executed. Notification via VERCEL_WEBHOOK_URL has been removed." }), {
      headers: { ...cors, "Content-Type": "application/json" },
      status: 200,
    });

  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);
    console.error("Error in process-video-task (Vercel notification part removed):", msg);
    if (taskId && supabase) { 
      // 必要に応じてエラー時のステータス更新
      // await updateTaskStatus(supabase, taskId, "function_error_no_webhook", msg);
    }
    return new Response(JSON.stringify({ error: `Error in process-video-task: ${msg}` }), {
      headers: { ...cors, "Content-Type": "application/json" },
      status: 500,
    });
  }
});

================
File: vercel.json
================
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "https://tqeprgfaybkvknmzeraj.supabase.co"
  },
  "regions": ["hnd1"],
  "github": {
    "silent": true
  }
}

================
File: app/api/start-task/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// 環境変数
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const CLOUD_RUN_TRANSCRIBE_URL = process.env.CLOUD_RUN_TRANSCRIBE_URL;
const GCS_BUCKET = process.env.GCS_BUCKET || 'transcription-audio';

// Supabaseクライアント初期化
let supabase: ReturnType<typeof createClient> | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
} else {
  console.error('[start-task/route.ts] Missing Supabase URL or Service Role Key env vars.');
}

interface StartTaskPayload {
  taskId: string;
  slackFileUrl?: string;
}

export async function POST(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] >>> /api/start-task called`);
  
  // 1. Authorizationヘッダー検証
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET) {
    console.error(`[${timestamp}] /api/start-task: WEBHOOK_SECRET is not configured on the server.`);
    return NextResponse.json({ error: 'Internal Server Configuration Error: Webhook secret not set.' }, { status: 500 });
  }
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.split(' ')[1] !== WEBHOOK_SECRET) {
    console.warn(`[${timestamp}] /api/start-task: Unauthorized access attempt. Auth Header: '${authHeader}'`);
    return NextResponse.json({ error: 'Unauthorized: Invalid or missing token.' }, { status: 401 });
  }
  console.log(`[${timestamp}] /api/start-task: Authorization successful.`);

  // 2. Cloud Run URLの確認
  if (!CLOUD_RUN_TRANSCRIBE_URL) {
    console.error(`[${timestamp}] /api/start-task: CLOUD_RUN_TRANSCRIBE_URL is not configured.`);
    return NextResponse.json({ error: 'Server Configuration Error: Cloud Run URL not set.' }, { status: 500 });
  }

  // 3. リクエストボディのパース
  let payload: StartTaskPayload;
  try {
    payload = await request.json();
    console.log(`[${timestamp}] /api/start-task: Received payload:`, JSON.stringify(payload, null, 2));
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown parsing error';
    console.error(`[${timestamp}] /api/start-task: JSON parse failed:`, errorMessage, err);
    return NextResponse.json({ error: 'Invalid JSON body', details: errorMessage }, { status: 400 });
  }

  // 4. 必須フィールドの検証
  const { taskId } = payload;
  if (!taskId) {
    console.error(`[${timestamp}] /api/start-task: Missing required fields in parsed payload.`);
    return NextResponse.json({ error: 'Missing required fields in payload' }, { status: 400 });
  }

  try {
    // 5. Supabaseからタスク情報の取得
    if (!supabase) {
      console.error(`[${timestamp}] /api/start-task: Supabase client not initialized.`);
      return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
    }

    console.log(`[${timestamp}] /api/start-task: Fetching task info for taskId: ${taskId}`);
    const { data: taskData, error: taskError } = await supabase
      .from('transcription_tasks')
      .select('*')
      .eq('id', taskId)
      .single();

    if (taskError) {
      console.error(`[${timestamp}] /api/start-task: Failed to fetch task data:`, taskError);
      return NextResponse.json({ error: 'Failed to fetch task data', details: taskError.message }, { status: 404 });
    }

    if (!taskData || !taskData.storage_path) {
      console.error(`[${timestamp}] /api/start-task: Task data missing or storage_path not found.`);
      return NextResponse.json({ error: 'Task data missing or invalid' }, { status: 400 });
    }

    // === 冪等性チェック: 既に処理中・完了済みならスキップ ===
    if (["processing", "transcribed", "completed", "failed"].includes(taskData.status as string)) {
      console.warn(`[${timestamp}] /api/start-task: Task ${taskId} is already in status '${taskData.status}'. Skipping duplicate execution.`);
      return NextResponse.json({
        message: `Task already processed or in progress (status: ${taskData.status})`,
        taskId,
        status: taskData.status
      }, { status: 200 });
    }

    // 6. ステータスを 'processing' に更新
    const { error: updateError } = await supabase
      .from('transcription_tasks')
      .update({ status: 'processing', updated_at: new Date().toISOString() })
      .eq('id', taskId);

    if (updateError) {
      console.error(`[${timestamp}] /api/start-task: Failed to update task status:`, updateError);
      return NextResponse.json({ error: 'Failed to update task status', details: updateError.message }, { status: 500 });
    }

    // 7. 動画ファイルへの署名付きURLを取得
    console.log(`[${timestamp}] /api/start-task: Getting signed URL for ${taskData.storage_path}`);
    const { data: signedUrlData, error: signedUrlError } = await supabase
      .storage
      .from('videos')
      .createSignedUrl(taskData.storage_path as string, 60 * 30); // 30分有効

    if (signedUrlError || !signedUrlData?.signedUrl) {
      console.error(`[${timestamp}] /api/start-task: Failed to get signed URL:`, signedUrlError);
      return NextResponse.json({ error: 'Failed to get signed URL', details: signedUrlError?.message || 'No signed URL returned' }, { status: 500 });
    }

    // 8. Cloud Runへの転送先パスを生成
    const gcsDestPath = `audio/${taskId}/${Date.now()}.mp3`;
    
    // 9. Cloud Runへ文字起こしリクエストを送信
    console.log(`[${timestamp}] /api/start-task: Sending transcription request to Cloud Run`);
    const cloudRunPayload = {
      signedUrl: signedUrlData.signedUrl,
      gcsBucket: GCS_BUCKET,
      gcsDestPath,
      taskId
    };
    
    const response = await fetch(CLOUD_RUN_TRANSCRIBE_URL, {
      method: 'POST',
      headers: {
        'x-vercel-secret': WEBHOOK_SECRET,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(cloudRunPayload),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[${timestamp}] /api/start-task: Cloud Run request failed:`, response.status, errorText);
      
      // ステータスを 'error' に更新
      await supabase
        .from('transcription_tasks')
        .update({ 
          status: 'failed', 
          error_message: `Cloud Run request failed: ${response.status} - ${errorText}`,
          updated_at: new Date().toISOString() 
        })
        .eq('id', taskId);
        
      return NextResponse.json({ 
        error: 'Cloud Run request failed', 
        details: errorText,
        status: response.status 
      }, { status: 502 });
    }

    const cloudRunResult = await response.json();
    console.log(`[${timestamp}] /api/start-task: Cloud Run request successful:`, JSON.stringify(cloudRunResult, null, 2));

    return NextResponse.json({
      message: 'Transcription task started successfully',
      taskId,
      status: 'processing'
    });

  } catch (error) {
    // 予期せぬエラーの処理
    const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : 'Unknown internal server error';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(`[${timestamp}] /api/start-task: Unhandled internal error:`, errorMessage, errorStack, error);
    
    // エラー発生時はタスクステータスを更新
    if (supabase && taskId) {
      await supabase
        .from('transcription_tasks')
        .update({ 
          status: 'failed', 
          error_message: errorMessage,
          updated_at: new Date().toISOString() 
        })
        .eq('id', taskId);
    }
    
    return NextResponse.json({ error: 'Internal server error', details: errorMessage }, { status: 500 });
  }
}

================
File: app/api/slack/events/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import process from 'node:process';

// WEBHOOK_SECRETはVercelの環境変数から取得することを想定
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const NEXT_PUBLIC_BASE_URL = process.env.NEXT_PUBLIC_APP_URL; // NEXT_PUBLIC_BASE_URLの代わりにNEXT_PUBLIC_APP_URLを使用

export async function POST(req: NextRequest) { // NextRequestを使用
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}][slack/events] >>> /slack/events called`);
  console.log(`[${timestamp}][slack/events] Headers:`, Object.fromEntries(req.headers.entries()));

  let body;
  try {
    body = await req.json();
    console.log(`[${timestamp}][slack/events] Parsed body:`, JSON.stringify(body, null, 2));
  } catch (e) {
    const error = e instanceof Error ? e : new Error('Unknown parsing error');
    console.error(`[${timestamp}][slack/events] Failed to parse body:`, error.message, error.stack);
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }

  // SlackのURL検証リクエストに対応
  if (body.type === "url_verification") {
    console.log(`[${timestamp}][slack/events] URL verification challenge received`);
    return NextResponse.json({ challenge: body.challenge });
  }

  // Slackイベントの署名検証 (オプショナルだが推奨)
  // ここではWEBHOOK_SECRETによる認証をintake側で行うため、event側では省略も可能
  // もしSlackの署名検証も行いたい場合は、元のverifySlackSignature関数を復活させる

  const event = body.event;

  if (event?.type === "message" && event.subtype === "file_share") {
    const files = event.files || [];
    console.log(`[${timestamp}][slack/events] Processing ${files.length} file(s) in message event.`);

    const videoPayloads = files
      .filter((file: any) => {
        const isVideo = file.mimetype?.startsWith("video/");
        if (!isVideo) {
          console.log(`[${timestamp}][slack/events] Skipping non-video file: ${file.name} (type: ${file.mimetype})`);
        }
        return isVideo;
      })
      .map((file: any) => ({
        file_id: file.id,
        original_file_name: file.name,
        mimetype: file.mimetype,
        filetype: file.filetype,
        slack_download_url: file.url_private_download,
        slack_user_id: event.user,
        slack_channel_id: event.channel,
        slack_team_id: body.team_id, // body.team_id から取得
        slack_event_ts: event.event_ts,
        metadata: extractMetadata(event.text)
      }));

    if (videoPayloads.length === 0) {
      console.log(`[${timestamp}][slack/events] No video files found in the message.`);
    } else {
      console.log(`[${timestamp}][slack/events] Found ${videoPayloads.length} video file(s) to process.`);
    }

    const promises = videoPayloads.map(async (payload: any) => {
      const fileIdForLog = payload.file_id || 'unknown_file';
      if (!NEXT_PUBLIC_BASE_URL) {
        console.error(`[${timestamp}][slack/events] CRITICAL: NEXT_PUBLIC_APP_URL (as NEXT_PUBLIC_BASE_URL) is not defined. Cannot call /api/slack/intake for file ${fileIdForLog}.`);
        return; // このPromiseはここで終了
      }
      if (!WEBHOOK_SECRET) {
        console.error(`[${timestamp}][slack/events] CRITICAL: WEBHOOK_SECRET is not defined. Cannot authorize call to /api/slack/intake for file ${fileIdForLog}.`);
        return; // このPromiseはここで終了
      }
      const url = `${NEXT_PUBLIC_BASE_URL}/api/slack/intake`;

      try {
        console.log(`[${timestamp}][slack/events] Fetching: ${url} for file ${fileIdForLog}`);
        const res = await fetch(url, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${WEBHOOK_SECRET}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const resBody = await res.text(); // Always get text first, as .json() might fail if not json
        if (!res.ok) {
          console.error(`[${timestamp}][slack/events] Intake failed for file ${fileIdForLog}. Status: ${res.status} ${res.statusText}. Response Body:`, resBody);
        } else {
          console.log(`[${timestamp}][slack/events] Intake succeeded for file ${fileIdForLog}. Status: ${res.status}. Response Body:`, resBody);
        }
      } catch (err) {
        const error = err instanceof Error ? err : new Error('Unknown fetch error');
        console.error(`[${timestamp}][slack/events] Intake error for file ${fileIdForLog}: ${error.message}`, error.stack, err);
      }
    });
    
    // Slackへのレスポンスをブロックしないために、Promise.all の結果を待たずに返すことも検討できるが、
    // Vercelのサーバーレス関数の実行時間制限（通常10秒～）を考慮し、ここでは完了を待つ。
    // もし多数のファイルを同時に処理し、タイムアウトが懸念される場合は、intake側をキューイングシステムに繋ぐなどの更なる対策が必要。
    try {
      await Promise.all(promises);
      console.log(`[${timestamp}][slack/events] All intake promises processed for message event.`);
    } catch (error) {
      // このcatchは map 内の individual catch で捕捉されなかった場合に備える (通常は到達しないはず)
      console.error(`[${timestamp}][slack/events] Error processing Promise.all for intake calls:`, error);
    }
  }

  // Slackには常に200 OKを速やかに返す
  return NextResponse.json({ message: "Event received and processing initiated" }, { status: 200 });
}

function extractMetadata(text: string | undefined) {
  if (!text) return {};
  return {
    consultant_name: extractByPattern(text, /コンサルタント名\s*([^\n]+)/),
    client_name: extractByPattern(text, /企業名(?:株式)?\s*([^\n]+)/),
    meeting_date: extractByPattern(text, /面談日\s*(\d{4}\/\d{2}\/\d{2})/),
    meeting_type: extractByPattern(text, /面談タイプ\s*([^\n]+)/),
    company_problem: extractByPattern(text, /企業の課題\s*([^\n]+)/), 
    company_phase: extractByPattern(text, /企業のフェーズ\s*([^\n]+)/), 
    company_type: extractByPattern(text, /企業タイプ\s*([^\n]+)/), 
    meeting_count: extractByPattern(text, /面談回数\s*(\d+)/), 
    support_area: extractByPattern(text, /支援領域\s*([^\n]+)/), 
    internal_sharing_items: extractByPattern(text, /社内共有が必要な事項\s*([^\n]+)/)
  };
}

function extractByPattern(text: string, regex: RegExp) {
  const match = text.match(regex);
  return match?.[1]?.trim() || null;
}

================
File: app/api/slack/intake/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// 環境変数
const NEXT_PUBLIC_SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;
const SLACK_BOT_TOKEN = process.env.SLACK_BOT_TOKEN;
const NEXT_PUBLIC_APP_URL = process.env.NEXT_PUBLIC_APP_URL;

let supabase: ReturnType<typeof createClient> | null = null;
if (NEXT_PUBLIC_SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) {
  supabase = createClient(NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
} else {
  console.error('[intake/route.ts] Missing Supabase URL or Service Role Key env vars.');
  // ここでsupabaseがnullの場合、後続の処理でエラーになるため、早期リターンやデフォルトの動作を検討する必要があるかもしれません。
  // ただし、現状のコードではDB操作前にnullチェックがあるので、致命的ではないかもしれません。
}

interface IntakePayload {
  file_id: string;
  original_file_name: string;
  mimetype: string;
  filetype: string;
  slack_download_url: string;
  slack_user_id: string;
  slack_channel_id?: string;
  slack_team_id?: string;
  slack_event_ts?: string;
  metadata: {
    consultant_name?: string;
    client_name?: string;
    meeting_date?: string;
    meeting_type?: string;
    company_problem?: string;
    company_phase?: string;
    company_type?: string;
    meeting_count?: string; 
    support_area?: string;
    internal_sharing_items?: string;
  };
}

export async function POST(request: NextRequest) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] >>> /api/slack/intake called`);
  
  // 1. Authorizationヘッダー検証
  const authHeader = request.headers.get('Authorization');
  if (!WEBHOOK_SECRET) {
    console.error(`[${timestamp}] /api/slack/intake: WEBHOOK_SECRET is not configured on the server.`);
    // WEBHOOK_SECRET が設定されていないのは致命的なサーバー設定エラー
    return NextResponse.json({ error: 'Internal Server Configuration Error: Webhook secret not set.' }, { status: 500 });
  }
  if (!authHeader || !authHeader.startsWith('Bearer ') || authHeader.split(' ')[1] !== WEBHOOK_SECRET) {
    console.warn(`[${timestamp}] /api/slack/intake: Unauthorized access attempt. Auth Header: '${authHeader}'`);
    return NextResponse.json({ error: 'Unauthorized: Invalid or missing token.' }, { status: 401 });
  }
  console.log(`[${timestamp}] /api/slack/intake: Authorization successful.`);

  // 2. リクエストボディのパース
  let payload: IntakePayload;
  try {
    payload = await request.json();
    console.log(`[${timestamp}] /api/slack/intake: Received payload:`, JSON.stringify(payload, null, 2));
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'Unknown parsing error';
    console.error(`[${timestamp}] /api/slack/intake: JSON parse failed:`, errorMessage, err);
    return NextResponse.json({ error: 'Invalid JSON body', details: errorMessage }, { status: 400 });
  }

  // 3. 必須フィールドの検証 (ペイロードパース後)
  const {
    file_id: slackFileId,
    original_file_name,
    mimetype,
    filetype,
    slack_download_url,
    slack_user_id,
    slack_channel_id,
    slack_team_id,
    slack_event_ts,
    metadata,
  } = payload;

  if (!slackFileId || !original_file_name || !mimetype || !filetype || !slack_download_url || !slack_user_id) {
    console.error(`[${timestamp}] /api/slack/intake: Missing required fields in parsed payload. Payload:`, payload);
    return NextResponse.json({ error: 'Missing required fields in payload' }, { status: 400 });
  }
  
  // 4. ファイルタイプチェック (ビデオファイルのみ処理)
  if (!mimetype.startsWith('video/')) {
      console.warn(`[${timestamp}] /api/slack/intake: Received non-video file type: ${mimetype} for file ${original_file_name}. Skipping.`);
      return NextResponse.json({ message: 'Non-video file type, processing skipped.' }, { status: 200 }); 
  }

  // --- ここからメイン処理 (try-catchで全体を囲むことも検討) ---
  try {
    // 5. Supabase Storageへのアップロード用署名付きURLの取得
    if (!NEXT_PUBLIC_APP_URL) {
      console.error(`[${timestamp}] /api/slack/intake: Missing NEXT_PUBLIC_APP_URL for internal API call to /api/upload-url.`);
      // これはサーバー設定エラーなので500を返す
      return NextResponse.json({ error: 'Server configuration error: App URL not set.' }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Requesting upload URL from ${NEXT_PUBLIC_APP_URL}/api/upload-url.`);
    const uploadUrlResponse = await fetch(`${NEXT_PUBLIC_APP_URL}/api/upload-url`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${WEBHOOK_SECRET}`, // /api/upload-url も同じシークレットで保護
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ fileName: original_file_name, contentType: mimetype }),
    });

    if (!uploadUrlResponse.ok) {
      const errorBody = await uploadUrlResponse.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to get upload URL from /api/upload-url. Status: ${uploadUrlResponse.status}, Body: ${errorBody}`);
      return NextResponse.json({ error: 'Failed to get upload URL', details: errorBody }, { status: uploadUrlResponse.status });
    }

    const { uploadUrl, storagePath } = await uploadUrlResponse.json();
    if (!uploadUrl || !storagePath) {
        console.error(`[${timestamp}] /api/slack/intake: Invalid response from /api/upload-url. Missing uploadUrl or storagePath. Response:`, {uploadUrl, storagePath});
        return NextResponse.json({ error: 'Invalid response from upload URL service' }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Received uploadUrl: ${uploadUrl}, storagePath: ${storagePath}`);

    // 6. Slackからのファイルダウンロード
    console.log(`[${timestamp}] /api/slack/intake: Fetching file from Slack: ${slack_download_url}`);
    if (!SLACK_BOT_TOKEN) {
      console.error(`[${timestamp}] /api/slack/intake: SLACK_BOT_TOKEN is not set. Cannot download from Slack.`);
      return NextResponse.json({ error: 'Server configuration error: SLACK_BOT_TOKEN missing' }, { status: 500 });
    }
    const slackRes = await fetch(slack_download_url, {
      headers: { Authorization: `Bearer ${SLACK_BOT_TOKEN}` },
    });

    if (!slackRes.ok || !slackRes.body) {
      const errorBody = await slackRes.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to download Slack file. Status: ${slackRes.status}, Body: ${errorBody}`);
      // TODO: この時点で transcription_tasks にエラーを記録することも検討 (status: 'download_failed')
      return NextResponse.json({ error: 'Failed to download Slack file', details: errorBody }, { status: slackRes.status });
    }
    console.log(`[${timestamp}] /api/slack/intake: Successfully fetched file stream from Slack.`);

    // 7. Supabase Storageへのアップロード
    console.log(`[${timestamp}] /api/slack/intake: Streaming upload to Supabase: ${uploadUrl}`);
    const supabaseUploadRes = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'Content-Type': mimetype,
      },
      body: slackRes.body,
      duplex: 'half',
    } as any);

    if (!supabaseUploadRes.ok) {
      const errorBody = await supabaseUploadRes.text();
      console.error(`[${timestamp}] /api/slack/intake: Failed to upload to Supabase. Status: ${supabaseUploadRes.status}, Body: ${errorBody}`);
      // TODO: この時点で transcription_tasks にエラーを記録することも検討 (status: 'upload_failed')
      return NextResponse.json({ error: 'Failed to upload to Supabase', details: errorBody }, { status: supabaseUploadRes.status });
    }
    console.log(`[${timestamp}] /api/slack/intake: Successfully uploaded to Supabase. Path: ${storagePath}`);

    // 8. Supabaseデータベースへのタスク記録
    if (!supabase) {
      console.error(`[${timestamp}] /api/slack/intake: Supabase client not initialized. Cannot insert task to DB.`);
      return NextResponse.json({ error: 'Server configuration error: Supabase client not available.' }, { status: 500 });
    }
    
    const taskData = {
      original_file_name: original_file_name,
      mimetype: mimetype,
      filetype: filetype,
      slack_file_id: slackFileId,
      slack_download_url: slack_download_url,
      slack_user_id: slack_user_id,
      slack_channel_id: slack_channel_id, // 追加
      slack_team_id: slack_team_id, // 追加
      slack_event_ts: slack_event_ts, // 追加
      storage_path: storagePath,
      status: 'uploaded', // トリガーが期待するステータス
      consultant_name: metadata.consultant_name ?? null,
      client_name: metadata.client_name ?? null, 
      company_type: metadata.company_type ?? null,
      company_problem: metadata.company_problem ?? null, 
      meeting_date: metadata.meeting_date ? new Date(metadata.meeting_date).toISOString().split('T')[0] : null, // YYYY-MM-DD形式
      meeting_count: metadata.meeting_count ? parseInt(metadata.meeting_count, 10) : null,
      meeting_type: metadata.meeting_type ?? null,
      support_area: metadata.support_area ?? null,
      company_phase: metadata.company_phase ?? null,
      internal_sharing_items: metadata.internal_sharing_items ?? null,
    };
    console.log(`[${timestamp}] /api/slack/intake: Inserting task into DB 'transcription_tasks':`, JSON.stringify(taskData, null, 2));
    const { data: insertedTask, error: dbInsertError } = await supabase
      .from('transcription_tasks')
      .insert(taskData)
      .select()
      .single();

    if (dbInsertError) {
      console.error(`[${timestamp}] /api/slack/intake: Failed to insert task to DB 'transcription_tasks':`, dbInsertError);
      return NextResponse.json({ error: 'DB insert failed for transcription_tasks', details: dbInsertError.message }, { status: 500 });
    }
    console.log(`[${timestamp}] /api/slack/intake: Task inserted to DB 'transcription_tasks' successfully. Task ID: ${insertedTask?.id}`);

    // 9. 文字起こしタスクの開始リクエスト（新しい部分）
    if (insertedTask?.id) {
      try {
        console.log(`[${timestamp}] /api/slack/intake: Starting transcription task for ID: ${insertedTask.id}`);
        
        const startTaskResponse = await fetch(`${NEXT_PUBLIC_APP_URL}/api/start-task`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${WEBHOOK_SECRET}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ taskId: insertedTask.id }),
        });
        
        if (!startTaskResponse.ok) {
          const errorBody = await startTaskResponse.text();
          console.error(`[${timestamp}] /api/slack/intake: Failed to start transcription task. Status: ${startTaskResponse.status}, Body: ${errorBody}`);
          // タスク開始に失敗してもファイルのアップロードは成功しているので、警告として続行
        } else {
          const startTaskResult = await startTaskResponse.json();
          console.log(`[${timestamp}] /api/slack/intake: Transcription task started. Result:`, startTaskResult);
        }
      } catch (startTaskError) {
        const errorMessage = startTaskError instanceof Error ? startTaskError.message : 'Unknown error starting task';
        console.error(`[${timestamp}] /api/slack/intake: Error starting transcription task:`, errorMessage);
        // タスク開始に失敗してもファイルのアップロードは成功しているので、警告として続行
      }
    }

    return NextResponse.json({ message: 'Upload successful and task created', taskId: insertedTask?.id, storagePath });

  } catch (error) {
    // このcatchは主に予期せぬ内部エラー (上記で個別に処理されなかったもの) を捕捉
    const errorMessage = error instanceof Error ? `${error.name}: ${error.message}` : 'Unknown internal server error';
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error(`[${timestamp}] /api/slack/intake: Unhandled internal error:`, errorMessage, errorStack, error);
    return NextResponse.json({ error: 'Internal server error', details: errorMessage }, { status: 500 });
  }
}




================================================================
End of Codebase
================================================================
